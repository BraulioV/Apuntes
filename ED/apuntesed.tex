%Compilar: pdflatex -synctex=1 -interaction=nonstopmode --shell-escape apuntesed.tex 
\documentclass[10pt,a4paper,spanish]{report}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm}
\usepackage{amsfonts, amssymb, latexsym}
\usepackage{enumerate}
\usepackage[official]{eurosym}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{pseudocode}
\usepackage[all]{xy}
\usepackage{minted}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{multirow}

\pgfplotsset{compat=1.5}

% a4large.sty -- fill an A4 (210mm x 297mm) page
% Note: 1 inch = 25.4 mm = 72.27 pt
%       1 pt = 3.5 mm (approx)

% vertical page layout -- one inch margin top and bottom
\topmargin      0 mm    % top margin less 1 inch
\headheight     0 mm    % height of box containing the head
\headsep        10 mm    % space between the head and the body of the page
\textheight     250 mm
\footskip       14 mm    % distance from bottom of body to bottom of foot

\usepackage[bookmarks=true,
            bookmarksnumbered=false, % true means bookmarks in
                                     % left window are numbered
            bookmarksopen=false,     % true means only level 1
                                     % are displayed.
            colorlinks=true,
            linkcolor=webblue]{hyperref}
\definecolor{webgreen}{rgb}{0, 0.5, 0} % less intense green
\definecolor{webblue}{rgb}{0, 0, 0.5}  % less intense blue
\definecolor{webred}{rgb}{0.5, 0, 0}   % less intense red

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % regla horizontal para  el titulo

\pagestyle{fancy}
%con esto nos aseguramos de que las cabeceras de capítulo y de sección vayan en minúsculas

\renewcommand{\chaptermark}[1]{%
      \markboth{#1}{}}
\renewcommand{\sectionmark}[1]{%
      \markright{\thesection\ #1}}
\fancyhf{} %borra cabecera y pie actuales
\fancyhead[LE,RO]{\textcolor[rgb]{0.5,0.8,0.9}{\bfseries\thepage}}
\fancyhead[LO]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} %espacio para la raya
\fancypagestyle{plain}{%
      \fancyhead{} %elimina cabeceras en páginas "plain"
      \renewcommand{\headrulewidth}{0pt} %así como la raya
}

%%%%% Para cambiar el tipo de letra en el título de la sección %%%%%%%%%%%
\usepackage{sectsty}
\chapterfont{\fontfamily{pag}\selectfont} %% for chapter if you want
\sectionfont{\fontfamily{pag}\selectfont}
\subsectionfont{\fontfamily{pag}\selectfont}
\subsubsectionfont{\fontfamily{pag}\selectfont}


%Definimos autor y título
\title{Estructura de Datos}
\author{Marta Gómez Macías}

\begin{document}
      \begin{titlepage}
            \begin{center}
                  \HRule \\[0.4cm]
                  \textsc{\Huge \textcolor[rgb]{0.2,0.8,0.4}Estructura \textcolor[rgb]{0.5,0.1,0.5}de\\[0.5cm] \textcolor[rgb]{0.7,0.8,0.9}Datos}\\[1.5cm]
                  \HRule \\[1cm]
                  \begin{flushleft}
                        \emph{Hecho por:}\\
                        Marta \textsc{Gómez Macías}
                  \end{flushleft}
                  \vspace{10cm}
                  {\Large \today}
                  \vspace{5mm}
                  \\
                  \htmladdnormallink{\includegraphics[width=2cm]{88x31.png}}
            {http://creativecommons.org/licenses/by-nc/4.0/}\\
            \texttt{Estructura de Datos by
            \href{mailto:mgmacias95@gmail.com}{Marta Gómez Macías}
            is licensed under a \htmladdnormallink{Creative Commons
            Reconocimiento-NoComercial-CompartirIgual 4.0 Internacional License}
            {http://creativecommons.org/licenses/by-nc/4.0/}}.
            \end{center}
      \end{titlepage}

      \setcounter{chapter}{-1}

      \tableofcontents

\chapter{\textcolor[rgb]{0.5,0.8,0.1}{Introducción}}
      \section{\textcolor[rgb]{0.5,0.8,0.1}Qué hacer ante un problema real}
      \noindent
            Cuando tenemos un problema real, lo primero que tenemos que preguntarnos es si se puede resolver con la ayuda de un ordenador, en caso afirmativo, debemos modelizar el problema. Para ello, diseñamos un algoritmo siguiendo unas técnicas de diseño, que estudiaremos en la asignatura Algorítmica, procurando que tenga la máxima eficiencia. Para ello haremos una abstracción del problema usando los T.D.A. que se dividen en dominio (conjunto de datos que puede representar), especificación e implementación. Todo esto dará lugar a un programa que una vez hecho debemos ver si funciona correctamente y si da una buena solución al problema que teníamos.

            \[\begin{xy}
            ,(0,0)*+=<10mm>[F]\txt<2cm>{Problema\\real}
            ,(30,0)*+=<10mm>[F]\txt<2cm>{Modelización}
            ,(15,-30)*+=<20mm>[F]\txt<3cm>{¿Se puede resolver con un ordenador?}
            ,(60,0)*+=<10mm>[F]\txt<2cm>{Algoritmo}
            ,(60,-30)*+=<10mm>[F]\txt<2cm>{Eficiencia}
            ,(60,30)*+=<10mm>[F]\txt<2cm>{Técnicas de\\diseño}
            ,(85,20)*+=<10mm>[F]\txt<2cm>{Control}
            ,(85,-20)*+=<10mm>[F]\txt<2cm>{Datos\\T.D.A.}
            ,(70,-40)*+=<10mm>[]\txt<2cm>{Abstracción}
            ,(110,-10)*+=<10mm>[]\txt<2cm>{Dominio}
            ,(110,-20)*+=<10mm>[]\txt<2cm>{Especificación}
            ,(110,-30)*+=<10mm>[]\txt<2cm>{Implementación}
            ,(130,0)*+=<10mm>[F]\txt<2cm>{Programa}
            ,(130,30)*+=<10mm>[]\txt<2cm>{Validar}
            ,(130,-35)*+=<10mm>[]\txt<2cm>{Fiabilidad}

            \ar@{->} (10,0);(20,0)
            \ar@{->} (15,-20);(15,0)
            \ar@{->} (40,0);(50,0)
            \ar@{->} (55,-25);(55,-5)
            \ar@{->} (55,25);(55,5)
            \ar@{->} (70,0);(80,15)
            \ar@{->} (70,0);(80,-15)
            \ar@{->} (72,-39);(72,-3)
            \ar@{->} (90,-20);(100,-10)
            \ar@{->} (90,-20);(100,-20)
            \ar@{->} (90,-20);(100,-30)
            \ar@{->} (90,0);(120,0)
            \ar@{->} (130,5);(130,28)
            \ar@{->} (130,-5);(130,-33)
            \end{xy}\]

      \section{\textcolor[rgb]{0.5,0.8,0.1}Elección de la estructura de Datos}
      \noindent
            Para elegir la estructura de datos, vamos a basarnos en las operaciones más frecuentes que vamos a realizar. Por ejemplo, si tenemos un conjunto de enteros y la operación más frecuente es la inserción, utilizaremos un conjunto de celdas enlazadas, pero, si la operación más frecuente es la consulta, utilizaremos un vector dinámico.
            \noindent
            Los algoritmos que tenemos para realizar operaciones mas comunes son:
            \subsection{\textcolor[rgb]{0.5,0.8,0.1}Algoritmos de búsqueda o consulta}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Búsqueda binaria}
                  \noindent
                        Se aplica sobre un vector ordenado. El elemento que estamos buscando se compara con el elemento que ocupa la mitad del vector, si coinciden se termina la búsqueda, si no, se determina la mitad del vector en la que puede estar el elemento y se repite el proceso.
                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      //El metodo devuelve la posicion del elemento buscado
      int BusquedaBinaria (char buscado)
      {
            int izda, dcha, centro;
            bool encontrado = false;

            izda = 0;
            dcha = total_utilizados - 1;
            //Donde total_utilizados es el numero de elementos del vector
            //(dato miembro privado)
            centro = (izda + dcha) / 2;

            while (izda <= dcha && !encontrado)
            {
                  //donde vector_privado es el vector de la clase (dato miembro privado)
                  if (vector_privado[centro] == buscado)
                        encontrado = true;

                  else if (buscado < vector_privado[centro])
                        dcha = centro - 1;

                  else
                        izda = centro + 1;

                  centro = (izda + dcha) / 2;
            }

            if (encontrado)
                  return centro;

            else
                  return -1;
      }
      \end{minted}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Búsqueda secuencial}
                  \noindent
                        El vector no tiene que estar ordenado. Vamos recorriendo el vector hasta encontrar el elemento que buscamos o hasta llegar al final, en cuyo caso devolvemos un -1.
                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      int BusquedaSecuencial (char buscado)
      {
            bool encontrado = false;
            int pos_encontrado;

            for (int i=0; i<total_utilizados && !encontrado; i++)
            {
                  if (buscado == vector_privado[i])
                  {
                        encontrado = true;
                        pos_encontrado = i;
                  }
            }

            if (encontrado)
                  return pos_encontrado;

            else
                  return -1;
      }
      \end{minted}
            \subsection{\textcolor[rgb]{0.5,0.8,0.1}Algoritmo de inserción}
            \noindent
                  Para insertar un dato en una lista (celdas enlazadas), creamos una celda para el valor que vamos a insertar, recorremos la lista hasta encontrar la posición donde vamos a insertar nuestro dato (la posición tal que la celda anterior sea menor y la siguiente mayor a nuestro dato) y lo insertamos enlazando la celda anterior con la que hemos creado y la que hemos creado con la siguiente.

                  \noindent
                  Su código sería:
      \begin{minted}[linenos]{c++}
      //Siendo Valores el nombre de la lista de celdas enlazadas
      void InsertaPosicion (Valores * &inicio, double insertado)
      {
            Valores *anterior=0, *actual = inicio;

            //Creamos una celda para el valor que vamos a insertar
            Valores *celda_nueva = new Valores;
            celda_nueva->numero=insertado;
            int i=0, total=NumTotalElementos(inicio);

            //Si el valor es menor que la de la  la primera celda, enlazamos nuestra
            //celda con la que empieza la lista
            if (inicio->numero < insertado){
                  celda_nueva->sig = inicio;
                  inicio = celda_nueva;
            }

            else
            {
                  //Recorremos la lista para buscar la posicion
                  //donde insertar nuestro valor:
                  
                  while ((i<total) && ((actual->numero) < insertado))
                  {
                        anterior=actual;
                        actual=actual->sig;
                        i++;
                  }

                  //una vez encontrada la posicion donde
                  //queremos insertar nuestro, lo insertamos:
                  anterior->sig=celda_nueva;
                  celda_nueva->sig=actual;
            }
      }

      int NumTotalElementos (Valores li)
      {
            //recorremos la lista hasta el final
            Valores aux = li;
            int i=0;

            while (aux != 0)
            {
                  aux=aux->sig;
                  i++;
            }

            return i;
      }
      \end{minted}
                  \noindent
                  En el caso de un vector dinámico, el algoritmo consistiría en recorrer el vector hasta encontrar la casilla en la que vamos a insertar nuestro dato (tiene que cumplir que el dato anterior sea menor y el siguiente mayor al que vamos a insertar), después reservamos memoria para un vector con una casilla más y copiamos en él todos los elementos hasta la casilla anterior a la insertada, después copiamos el valor a insertar y por último el resto del vector. Eliminamos por último el vector antiguo.

                  \noindent
                  Su código sería:
      \begin{minted}[linenos]{c++}
      void Inserta (int insertado)
      {
            int posicion_insertado, i=0;

            while (v[i]<=insertado && i<total_utilizados)
                  i++;

            posicion_insertado = i;

            int * nuevo_v = new VectorDinamico [total_utilizados+1];

            //Ahora insertamos todos los valores hasta el anterior a insertado:
            for (i=0; i<posicion_insertado; i++)
                  nuevo_v[i] = v[i];

            //Despues insertamos nuestro valor:
            nuevo_i[posicion_insertado] = insertado;

            //Y luego el resto de valores:
            //Recorremos hasta total_utilizados+1 porque el
            //vector ahora tiene un valor mas
            for (i=posicion_insertado+1; i<total_utilizados+1; i++)
                  nuevo_v[i] = v[i-1];

            //Eliminamos el vector:
            //Aqui actuaria el operador de asignacion que tenemos sobrecargado
            delete [] v;
            v = nuevo_v;
      }
      \end{minted}
            \subsection{\textcolor[rgb]{0.5,0.8,0.1}Algoritmo de borrado}
            \noindent
                  Para eliminar un dato de una lista, debemos recorrer la lista hasta encontrar el dato que queremos eliminar. Entonces, enlazamos la celda anterior a la que contiene ese dato, con la siguiente y después liberamos la memoria que ocupa esa celda. Si el dato a eliminar está en la primera celda, hacemos que la lista empiece en la segunda celda.

                  \noindent
                  Su código sería:
      \begin{minted}[linenos]{c++}
      void EliminaDato (Valores * &inicio, double eliminado)
      {
            Valores *aux = inicio, *anterior=0;
            int i=0, total=NumTotalElementos(inicio);

            //si el valor coincide con el primer elemento de la lista,
            //hacemos que la lista empiece directamente en la segunda celda
            //y eliminamos la primera
            if (eliminado == inicio->numero)
            {
                  aux=inicio;
                  inicio=inicio->sig;
                  delete aux;
            }
            else
            {
                  //Buscamos en la lista hasta encontrar el valor
                  //que buscamos para eliminar
                  while (i<total && eliminado != aux->numero)
                  {
                        anterior=aux;
                        aux=aux->sig;
                        i++;
                  }
                  if (eliminado != aux->numero) //hemos salido sin encontrar el valor
                        cout << "No se puede eliminar " << eliminado
                        << " porque no esta en la lista" << endl;

                  else //lo hemos encontrado
                  {
                        anterior->sig=aux->sig;

                        delete aux;
                  }
            }
      }
      \end{minted}

                  \noindent
                  Para un vector, tendríamos que desplazar todos los elementos siguientes al elemento que queremos eliminar para ``machacar'' ese valor.

                  \noindent
                  Su código sería
      \begin{minted}[linenos]{c++}
      void Borrar(int pos)
      {
            TipoBase vector_copia = 0;

            int i, j;

            vector_copia = new TipoBase[total_utilizados - 1];

            for(i = 0, j = 0; i < total_utilizados; i++, j++)
            {
                  if(i == pos)
                        i++;
                  vector_copia[j] = vector_privado[i];
            }

            delete [] vector_privado;

            vector_privado = vector_copia;

            total_utilizados--;

      }
      \end{minted}
            \subsection{\textcolor[rgb]{0.5,0.8,0.1}Algoritmos de ordenación}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Inserción}
                        \noindent
                        El vector se divide en dos subvectores: el de la izquierda ordenado y el de la derecha desordenado. Cogemos el primer elemento del subvector desordenado y lo insertamos de forma ordenada en el subvector de la izquierda. Para ello, vamos fijando el inicio del vector derecho con un índice izda, seleccionamos el valor de v[izda] y lo insertamos en el vector izquierdo.

            \noindent
            Su código sería:
      \begin{minted}[linenos]{c++}
      void Ordena_Insercion ()
      {
            int izda, i;
            char a_desplazar;

            for (izda = 1; izda < total_utilizados; izda++)
            {
                  a_desplazar = vector_privado[izda];

                  for (i = izda; i>0 && a_desplazar < vector_privado[i-1]; i--)
                        vector_privado[i] = vector_privado[i-1];

                  vector_privado[i] = a_desplazar;
            }
      }
      \end{minted}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Selección}
                        \noindent
                        Nuestro vector está dividido en dos subvectores, uno que está ordenado y otro que no. Para ello, vamos comparando los valores que hay al principio del vector con los del resto y los menores, los movemos al principio. Acabamos cuando el subvector de elementos ordenados ocupe ya todo el vector.

                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      //Este es un metodo de la clase VectorDeCaracteres
      void Ordena_Seleccion ()
      {
            int pos_min;

            //Donde total_utilizados es el numero de elementos del vector
            for (int izda=0; izda<total_utilizados; izda++)
            {
                  pos_min = PosicionMinimoEntre (izda, total_utilizados-1);
                  Intercambia (izda, pos_min);
            }
      }

      void Intercambia (int pos_izda, int pos_dcha)
      {
            char intercambia;

            intercambia = vector_privado[pos_izda];
            vector_privado[pos_izda] = vector_privado[pos_dcha];
            vector_privado[pos_dcha] = intercambia;
      }

      int PosicionMinimoEntre (int izda, int dcha)
      {
            int posicion_minimo;
            char minimo;

            minimo = vector_privado[izda];
            posicion_minimo = izda;

            for (int i=izda+1; i<=dcha; i++)
                  if (vector_privado[i] < minimo)
                  {
                        minimo = vector_privado[i];
                        posicion_minimo = i;
                  }

            return posicion_minimo;
      }
      \end{minted}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Burbuja}
                  \noindent
                        A la izquierda se va dejando un subvector ordenado. Desde el final y hacia atrás, se van comparando los elementos dos a dos y se deja a la izquierda el más pequeño (intercambiándolos). Para ello, vamos fijando el inicio del subvector derecho con un contador, recorremos el subvector de la derecha desde el final hasta el principio con un contador i y si v[i] menor que v[i-1] se intercambian.

                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      void Ordena_Burbuja ()
      {
            int izda, i;
            //Esta variable comprueba si se ha hecho un cambio en un bucle,
            //en caso negativo ya tendriamos el vector ordenado.
            bool cambio;

            for (izda = 0; izda < total_utilizados && cambio; izda++)
            {
                  cambio = false;
                  for (i = total_utilizados-1; i>izda; i--)
                        if (vector_privado[i] < vector_privado[i-1])
                        {
                              Intercambia(i, i-1);
                              cambio = true;
                        }
            }
      }
      \end{minted}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Quicksort}
                  \noindent
                        Este método utiliza la recursividad para ir fijando los rangos del vector sobre los que otro método (al que llamaremos partir) realizará los intercambios necesarios para ir ordenándolos, para ello, establecemos un pivote para ir partiendo el vector. Hacemos esto de manera recursiva cambiando el pivote.

                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      void QuickSort (int inicio, int final)
      {
            int pos_pivote;

            if (inicio < final)
            {
                  pos_pivote = partir (inicio, final);
                  //Ordena primera mitad
                  QuickSort (inicio, pos_pivote-1);
                  //Ordena segunda mitad
                  QuickSort (pos_pivote + 1, final);
            }
      }
      \end{minted}

                        \noindent
                        La función partir toma un elemento arbitrario del vector (pivote), recorre el vector de izda a dcha hasta encontrar un elemento situado en izda tal que v[izda] mayor que pivote. Después, recorre el vector de dcha a izda hasta encontrar otro elemento tal que v[dcha] menor que pivote e intercambia los elementos de izda y dcha. Se repite el proceso hasta que izda mayor que dcha y se coloca el pivote donde corresponde.

                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      int partir (int primero, int ultimo)
      {
            int intercambia, izda, cha;
            int pivote = vector_privado[primero];

            izda = primero + 1; //avanza hacia delante
            dcha = ultimo; //retrocede hacia atras

            while (izda <= dcha)
            {
                  while (izda <= dcha && vector_privado[izda] <= pivote)
                        izda++;

                  while (izda <= dcha && vector_privado[dcha] >= pivote)
                        dcha--;

                  if (izda < dcha)
                  {
                        intercambia = vector_privado[izda];
                        vetor_privado[izda] = vector_privado[dcha];
                        vector_privado[dcha] = intercambia;
                        dcha--;
                        izda++;
                  }
            }
            intercambia = vector_privado[primero];
            vector_privado[primero] = vector_privado[dcha];
            vector_privado[dcha] = intercambia;

            return dcha;
      }
      \end{minted}
                  \subsubsection{\textcolor[rgb]{0.5,0.8,0.1}Mergesort}
                  \noindent
                        Si tenemos un vector de x elementos y queremos ordenarlos, dividimos el vector por la mitad hasta llegar a un número mínimo de elementos en el que el vector se ordena y luego se fusiona con el nivel superior. Es una función recursiva.

                        \noindent
                        Su código sería:
      \begin{minted}[linenos]{c++}
      void Orden_MergeSort (int * v, int n)
      {
            if (n == 2)
            {
                  if (v[0] > v[1])
                        Intercambiar (v[0],v[1]);
            }
            else if (n>2)
            {
                  int ni=(n/2), nd=n-(n/2);
                  int * vi=new int [ni];
                  int * vd=new int [nd];

                  for(int i=0;i<ni;i++)
                        vi[i]=v[i];
                  for(int i=0;i<nd;i++)
                        vd[i]=v[i+(n/2)];

                  //Ordenamos a la izquierda
                  Orden_MergeSort (vi,ni);

                  //Ordenamos a la derecha
                  Orden_MergeSort (vd,nd);

                  //Fusionamos en v, vi y vd
                  Fusion(v,vi,vd,ni,nd);
                  delete [] vi;
                  delete [] vd;
            }
      }

      void Fusion (int * vout, int * vi, int * vd, int ni, int nd)
      {
            int pi=0, pd=0, p=0;

            while (pi < ni && pd < nd)
            {
                  if (vi[pi] < vd[nd])
                  {
                        vout[p] = vi[pi];
                        pi++;
                  }

                  else
                  {
                        vout[p] = vd[pd];
                        pd++;
                  }
                  p++;
            }
            //si queda algo en vi
            while (pi < ni)
            {
                  vout[p] = vi[pi];
                  p++;
                  pi++;
            }

            //si queda algo en vd
            while (pd < nd)
            {
                  vout[p] = vd[pd];
                  p++;
                  pd++;
            }
      }
      \end{minted}

\chapter{\textcolor[rgb]{0.1,0.2,0.6}{Introducción a la eficiencia de algoritmos}}
\section{\textcolor[rgb]{0.1,0.2,0.6}Qué es la eficiencia}
\noindent
La eficiencia nos permite medir qué recursos (tiempo de ejecución ó memoria que necesita) gasta un algoritmo. Además, nos permite comparar dos algoritmos que resuelven un problema.

\noindent
Por ejemplo, si tuvieramos 50 trabajadores y 50 trabajos, y tuviéramos que asignarle a cada trabajador un trabajo dependiendo de factores como sus habilidades, experiencia, etc, las posibilidades se elevarían hasta la cifra de $50!$. Si tuviéramos un ordenador que evaluase un billón de posibilidades por segundo y hubiéramos empezado a evaluar en la era de los dinosaurios, aún estaría nuestro ordenador evaluando, por tanto, este problema no es viable resolverlo con un ordenador.

\noindent
Vamos a ver la diferencia entre algoritmo e implementación:
\begin{description}
\item[Algoritmo]: conjunto de pasos ordenados que resuelven un problema.
\item[Implementación]: traducción de esa secuencia a un lenguaje de programación
\end{description}

\noindent
\textbf{Principio de invarianza}: si hay dos implementaciones de un mismo algoritmo, la eficiencia va a cambiar por una constante, es decir, tienen la misma eficiencia.

\section{\textcolor[rgb]{0.1,0.2,0.6}Cómo calcular la eficiencia}
\noindent
Podemos calcular la eficiencia por tres métodos:
\begin{enumerate}[---]
\item Eficiencia teórica: mediante un estudio asintótico (estudiar la eficiencia cuando  n tiende a infinito)
\item Eficiencia empírica: estudio experimental
\item Eficiencia híbrida: una mezcla de las dos anteriores, la estudiaremos en prácticas.
\end{enumerate}

\subsection{\textcolor[rgb]{0.1,0.2,0.6}Eficiencia empírica}
\noindent
Para calcularla, implementamos el algoritmo y hacemos una gráfica para medir los segundos que tarda según el tamaño. Según la entrada que le metamos, el algoritmo se comportará mejor o peor (por ejemplo, no es lo mismo buscar un valor que sea el primero del vector a que directamente, no esté en el vector).
\newpage
\noindent
Para calcular los segundos en C++, usamos la librería ctime. El código sería el siguiente:
\begin{minted}[linenos]{c++}
#include <ctime>
#include <iostream>
using namespace std;

int main ()
{
      time_t t_antes, t_despues;

      time(&t_antes); //medimos el tiempo
      Busqueda (*v, n, x); //buscamos en el vector v de tamanio n el valor x
      time(&t_despues); //lo volvemos a medir
      cout << difftime(t_despues, t_antes); //obtenemos la diferencia

      return 0;
}
\end{minted}
\noindent
Este método presenta varios problemas:
\begin{enumerate}[1.]
\item Depende de los casos ejecutados
\item Depende del hardware y librerías usadas
\item Para comprobar dos algoritmos hay que ejecutarlos en las mismas condiciones (hardware, librerías, casos...)
\end{enumerate}

\noindent
Este método es menos objetivo que la eficiencia teórica.

\subsection{\textcolor[rgb]{0.1,0.2,0.6}Eficiencia teórica}
\noindent
Antes de hablar de la eficiencia teórica, vamos a introducir el siguiente concepto:

\noindent
\textbf{Orden de eficiencia ($T(n)$)}: un algoritmo tiene un orden de eficiencia $T(n)$ si existe una implementación del algoritmo cuyo tiempo de ejecución, $f(n)$, está acotado superiormente por $c \cdot T(n)$, siendo $c$ una constante mayor o igual que $n$ y siendo $n$ el tamaño del problema.

\begin{center}
\begin{math}
f(n) \leq c \cdot T(n)
\end{math}
\end{center}

\noindent
Por ejemplo, si tenemos una función $f(n) = 2n + 3$ y queremos calcular la n y la c:

\begin{center}
$2n + 3 \leq c \cdot n$

Lo igualamos para saber el punto exacto en el que se cruzan las funciones:

$2n + 3 = c \cdot n$

Despejamos:

$2n - c \cdot n + 3 = 0$

Sacamos factor común:

$n(2-c) + 3 = 0$

Y despejamos la n:

$n = \frac{3}{c - 2}$

Por tanto, tenemos que $c > 2$, le damos entonces $c = 3$ y obtenemos que $n = 3$
\end{center}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Ordenes de eficiencia más comunes}
\noindent
De más eficiente a menos:
\begin{enumerate}[---]
\item Orden constante: $T(n) = a$
\item Orden logarítmico: $T(n) = log(n)$
\item Raíz cuadrada: $T(n)=\sqrt{n}$
\item Orden lineal: $T(n)=n$
\item Polinomios: $T(n)=n^{2}, n^{3},.... n^{k}$
\item Tiempo exponencial: $T(n) = c^{n}$
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Clases de eficiencia}
\noindent
Ejemplo: $f(n) = 3n + 4log_{2}(n) + 5\sqrt{n}$

\noindent
Para saber qué clase de eficiencia tiene un polinomio seguimos los siguientes pasos:
\begin{enumerate}[1.]
\item Quitamos las constantes
\item Miramos el que tarde más en forma funcional (en este ejemplo, $n$)
\item Siguiendo el ejemplo, nuestro polinomio es de orden $n$
\end{enumerate}

\noindent
Las funciones se agrupan según su eficiencia en clases de eficiencia, que son:

\begin{enumerate}[$\bullet$]
\item Lineal: $T(n) = n$
\item Constante: $T(n) = a$
\item Logarítmica: $T(n) = log(n)$
\item Otros
\end{enumerate}

\noindent
Ejemplo: Hacemos un estudio asintótico de dos algorítmos distintos con $f(n) = n^{2}$ y $g(n)=10n$ y obtenemos la siguiente gráfica:

\begin{tikzpicture}
\begin{axis}[
    axis lines = left,
    xlabel = $n$,
    ylabel = {$s$},
]
%Below the red parabola is defined
\addplot [
    domain=0:20,
    samples=100,
    color=red,
]
{x^2};
\addlegendentry{$f(n)=n^{2}$}
%Here the blue parabloa is defined
\addplot [
    domain=0:20,
    samples=100,
    color=blue,
    ]
    {10*x};
\addlegendentry{$g(n)=10n$}

\end{axis}
\end{tikzpicture}

\noindent
g(n) es más eficiente siempre y cuando $n>n_{0}$ (como vemos en la gráfica, sería 10). Vamos a calcular $n_{0}$:

\begin{center}
$10n \leq n^{2}$ \\
$10n = n^{2}$ \\
$n^{2} - 10n = 0$ \\
$n(n - 10) = 0$ \\
$n = 10$
\end{center}

\noindent
A partir de $n = 10$, $g(n)$ es más eficiente.

\noindent
Ejemplo:

\begin{displaymath}
f(n) = \left\{ \begin{array}{ll}
n^{2} & \textrm{si $n$ es par}\\
n^{4} & \textrm{si $n$ es impar} \\
\end{array} \right.
\end{displaymath}
\begin{center}
$g(n)=n^{3}$
\end{center}

\noindent
En este ejemplo no se puede establecer una relación de orsden ya que para $f(n)$ hay un número infinito de veces en los que se comportará de una manera y otro número infinito de veces en los que se comportará de la otra, ya que los números pares e impares son infinitos.

\noindent
En el caso anterior, $g(n)$ era peor en un número finito de datos ($n<100$) por eso nos hemos decantado por $g(n)$, era mejor en un número infinito de casos.

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}O-grande}

\noindent
Definimos como \textit{\textcolor[rgb]{0.1,0.2,0.6}{O-Grande}} al tiempo de ejecución de un algoritmo en el \textbf{peor} de los casos.

\noindent
Diremos que un algoritmo con tiempo de ejecución $g(n) \in O(f(n))$ si $\exists c \in \mathbb{R}_{0}^{+}$ y un $n_{0}$\footnote{Tamaño del problema} $\in \mathbb{N}$ tal que $\forall n \geq n_{0}$\footnote{Este párrafo se leería así: g(n) pertenece a O de f(n) si existe una constante en R positivo y un n sub cero en N tal que para todo N sea mayor que n sub cero.}

\noindent
Ejemplo: Vamos a calcular para cuando se cumple la definición:
\begin{center}
$g(n) = n^{2} + 5n \in O(n^{2})$

$n^{2} + 5n \leq c \cdot n^{2}$

$n^{2} + 5n = c \cdot n^{2}$

$n^{2} - c \cdot n^{2} + 5n = 0$

$n^{2}(1 - c) + 5n = 0$

$n(n(1-c) + 5) = 0$

Despejamos la n que está dentro del paréntesis:

$n = \frac{5}{c-1}$

Nos queda entonces que $c > 1$, si le damos $c = 2$ entonces obtenemos que $n = 5$. Para $n \geq 5$ y $c = 2$ se cumple la definición.
\end{center}

\noindent
Ejemplo: ¿Son ciertas las siguientes afirmaciones?
\begin{enumerate}[$\bullet$]
\item $3n^{3} + 2n^{2} \in O(n^{3}) \longrightarrow$ Sí.
\item $3^{n} \in O(2^{n}) \longrightarrow$ No.
\item $2^{n+1} \in O(2^{n}) \longrightarrow$ Sí, ya que $2^{n+1} = 2 \cdot 2^{n}$
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Relaciones entre órdenes}
\noindent
$O(a)\subset O(log(n))\subset O(\sqrt(n))\subset O(n)\subset O(nlog(n))\subset O(n^{2})\subset O(2^{n})\subset O(n^{n})$

\noindent
Para saber cuál de entre dos funciones es mayor, podemos calcular su limite cuando n tiende a infinito:
\begin{center}
$\lim\limits_{n\rightarrow \infty}\frac{f(n)}{g(n)}=0$ $\longrightarrow f(n) < g(n)$
\end{center}

\noindent
Ejemplo: Tenemos $f(n) = log(n)$ y $g(n) = n$, ¿cuál de los dos es más grande? Aplicamos L'hôpital:

$\lim\limits_{n\rightarrow \infty}\frac{log(n)}{n}=\lim\limits_{n\rightarrow \infty}\frac{\frac{1}{n}}{n}=\lim\limits_{n\rightarrow \infty}\frac{1}{n}=0$ $\longrightarrow g(n) > f(n)$

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Reglas del O-Grande}
\begin{enumerate}[1.]
\item $f(n) \in O(g(n))$ y $g(n) \in O(h(n)) \Longrightarrow f(n) \in O(h(n))$
\item $a_{d}n^{d} + a_{d-1}n^{d-1} + \cdots + a_{1}n^{1} + a \in O(n^{d})$
\item \textbf{No} importa la base de los logaritmos: $log_{a}(n) \in O(log_{b}(n))$
\item La base del exponente de las potencías \textbf{sí} importa: $3^{n} \notin O(2^{n}) \longrightarrow 3^{n} \in O(3^{n})$
\item El exponente de las potencías \textbf{sí} importa: $a^{n^{2}} \notin O(a^{n})$ ; $a^{2n} \notin O(a^{n}) \rightarrow 2^{2n} = 4^{n}$
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Normas para obtener la eficiencia de un código}
\noindent
Las \textit{\textcolor[rgb]{0.1,0.2,0.6}{operaciones elementales}} las contaremos como $O(1)$, dentro de este grupo se incluyen:
\begin{enumerate}[$\heartsuit$]
\item Declaración
\item Asignaciones
\item Comparaciones simples
\item Operaciones aritméticas
\item Entrada y salida de datos básicos
\item Acceso a un array
\item etc
\end{enumerate}

\noindent
Ejemplo: Vamos a ver cómo de eficiente es el siguiente código
\begin{minted}[linenos]{c++}
int A[MAX]; //O(1)

for (int i=0; i<n; i++) //O(2); O(1); O(1)
      A[i] = 0;   //O(2)
\end{minted}

\noindent
En la primera vuelta del bucle, hemos gastado dos O(1) para inicializar la i y otro compararla con n. A partir de ahí, en el resto de las vueltas gastaremos una O(1) para comparar i con n, otra para incrementar i y dos más para igualar la componente del vector a cero:

\begin{displaymath}
(1+1) + 1 + \sum_{i=0}^{n-1}[(1+1) + (1+1)] = 3 + \sum_{i=0}^{n-1}4 = 3 + 4 \sum_{i=0}^{n-1}1 = 3 + 4n \in O(n)
\end{displaymath}

\noindent
A efectos prácticos, se suele dejar así:

\begin{displaymath}
\sum_{i=0}^{n-1} 1 = n
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Regla de la suma}
\noindent
Sean dos trozos de código, $c_{1}$ y $c_{2}$, independientes con eficiencia $T_{1}(n)$ y $T_{2}(n)$ respectivamente:

\begin{displaymath}
T_{1}(n) + T_{2}(n) \in O(max(f(n),g(n))) \left\{ \begin{array}{ll}
T_{1}(n) \in O(f(n))\\
T_{2}(n) \in O(g(n))
\end{array} \right.
\end{displaymath}

\noindent
Ejemplo: sentencias if else:
\begin{minted}[linenos, mathescape]{c++}
int a=5, b=100;

if (a < b)        //O(1)
      cout << b;

else
      for (int i = 0; i < n; i++)   //O(n)
            A[i] = 0;

//$O(max(1,n)) = O(n)$
\end{minted}

\noindent
La eficiencia del algoritmo anterior es la suma de O(1) y O($n$), que es O($n$).

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Regla del producto}
\noindent
Sean dos trozos de código, $c1$ y $c2$, dependientes con tiempos de ejecución $T_{1}(n)$ y $T_{2}(n)$ respectivamente:

\begin{center}
$T_{1}(n) \cdot T_{2}(n) \in O(f(n) \cdot g(n)) \left\{ \begin{array}{ll}
T_{1}(n) \in O(f(n))\\
T_{2}(n) \in O(g(n))
\end{array} \right.$
\end{center}

\noindent
La diferencia con la regla de la suma es que la suma de los dos trozos de código son \textbf{\textcolor[rgb]{0.1,0.2,0.6}{independientes}} (como por ejemplo, una sentencia if else) mientras que en la regla del producto, son \textbf{\textcolor[rgb]{0.1,0.2,0.6}{dependientes}} (como por ejemplo, bucles anidados).

\noindent
Ejemplo:
\begin{minted}[linenos]{c++}
//Rellenar una matriz cuadrada
for (int i=0; i<n; i++) //Bucle for que empieza en 0 y acaba en n: O(n)
      for (int j=0; j<n; j++) //Bucle for que empieza en 0 y acaba en n: O(n)
            A[i][j] = 0; //Asignacion: O(1)
\end{minted}

\noindent
Al tener dos bucles anidados, para saber a qué O-Grande pertenecen debemos multiplicarlos: por lo que obtenemos que el código anterior pertenece a $O(n^{2})$:

\begin{displaymath}
\sum_{i=0}^{n-1} \sum_{j=0}^{n-1} 1 = \sum_{i=0}^{n-1} \underbrace{1+1+1+ \cdots + 1}_{n} = \sum_{i=0}^{n-1} n = n \sum_{i=0}^{n-1} 1 = n \cdot n = n^{2} \in O(n^{2})
\end{displaymath}

\noindent
Ejemplo: combinación de ambas reglas.

\noindent
Tenemos un if y un else, al ser códigos independientes debemos estudiarlos por separado:
\begin{minted}[linenos, mathescape]{c++}
//El if cuesta $O(n^{2})$ tal y como acabamos de estudiar
if(A[0][0] == 0)
{
      for (int i=0; i<n; i++)
            for (int j=0; j<n; j++)
                  A[i][j] = 0;
}

//El else, $O(n)$ tal y como acabamos de estudiar
else
      for (int k=0; k<n; k++)
            A[k][k] = 0;
\end{minted}

\noindent
Al ser una suma, debemos ver el $max(O(n^{2}), O(n))$, al ser el máximo $O(n^{2})$, el código anterior $\in O(n^{2})$

\noindent
¿Cuánto miden los siguientes fragmentos de código? Ambos miden lo mismo.
\begin{minted}[linenos]{c++}
for (int i=1; i<n; i*=2)            for (int i=n; i>=1; i/=2)
      A[i] = 0;                           A[i] = 0;
\end{minted}

\noindent
Las veces que ejecutamos los códigos son $log_{2}(n)$ veces:
\begin{displaymath}
\sum_{i=0}^{log_{2}n}1= log_{2}(n) \in O(log_{2}(n))
\end{displaymath}
\begin{displaymath}
\sum_{i=log_{2}n}^{0}1= log_{2}(n) \in O(log_{2}(n))
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Ejemplos}

\begin{minted}[linenos, mathescape]{c++}
int funcion1 (int n)
{
      int suma = 0; //O(1)

      for (int i=0; i<n; i++)
            suma += i; //O(1)

      return suma; //O(1)
}

int funcion2 (int n)
{
      int suma = 0; //O(1)

      for (int i=0; i<n; i++)
            suma += funcion1(i); //Aunque la suma sea O(1), funcion1 es O(n)

      return suma; //O(1)
}

int main ()
{
      int n; //O(1)
      cin >> n; //O(1)
      cout << funcion2(n); //$O(n^2)$
}
\end{minted}

\noindent
Empezamos analizando funcion1:

\noindent
En el for tenemos:
\begin{displaymath}
\sum_{i=0}^{n-1} 1 = n
\end{displaymath}

\noindent
Por lo que toda la funcion1 es de orden $O(n)$

\noindent
Analizamos funcion2:

\noindent
En el for tenemos:
\begin{displaymath}
\sum_{i=0}^{n-1} n = n \sum_{i=0}^{n-1} 1 = n^{2}
\end{displaymath}

\noindent
Por lo que toda la funcion2 es de orden cuadrático, $O(n^{2})$

\noindent
Al ser la funcion2 de orden cuadrático la operación de más orden, por la regla de la suma, todo el main es de orden cuadrático, $O(n^{2})$

\begin{minted}[linenos]{c++}
void Ordena_Seleccion (const int *v, int n)
{
      for (int i=0; i<(n-1); i++)
            for (int j=i+1; j<n; j++)
                  if (v[j] < v[i]) //Todo este if es de orden O(1)
                        Intercambiar (v[i], v[j]);
}

void Intercambiar (int &a, int &b)
{
      //Toda esta funcion es de orden O(1)
      int aux = a;
      a = b;
      b = aux;
}
\end{minted}

\noindent
En la función Ordena Seleccion tenemos dos bucles anidados, en el segundo for tenemos:

\begin{displaymath}
\sum_{j=i+1}^{n-1} 1 = n - i -1
\end{displaymath}

\noindent
Tras aplicar la regla del producto con el primer for, nos queda que:

\begin{displaymath}
\sum_{i=0}^{n-2} n - i - 1 = \sum_{i=0}^{n-2} n - \sum_{i=0}^{n-2} i - \sum_{i=0}^{n-2} 1 = n(n-1) - (n-2)\frac{(n-1)}{2} - (n-1) =
\end{displaymath}
\begin{displaymath}
= n(n-1) - \frac{(n-2)(n-1)}{2} - (n-1) = (n^{2}-1) - (\frac{n^{2}-3n+2}{2}) - n + 1 \in O(n^{2})
\end{displaymath}

\begin{minted}[linenos]{c++}
void funcion (int n)
{
      int x=0, y=0; //O(1)

      for (int i=1; i<n; i++)
      {
            if (i % 2 == 0)   //todo el if vale O(n)
            {
                  //Solo ejecutamos el contenido de este for la mitad de las
                  //veces, cuando se cumple la condicion del if

                  for (int j=i; j<n+1; j++)
                        x++;    //O(1)

                  for (int j=1; j<i+1; j++)
                        y++;    //O(1)
            }
      }
}
\end{minted}

\noindent
Empezamos analizando los for dentro del if:

\begin{displaymath}
\sum_{j=i}^{n} 1 = n - i + 1
\end{displaymath}
\begin{displaymath}
\sum_{j=1}^{i} 1 = i
\end{displaymath}

\noindent
Y por la regla de la suma tenemos que todo el if tiene orden de $O(n)$:
\begin{displaymath}
n - i + 1 + i = n + 1 \in O(n)
\end{displaymath}

\noindent
Y si analizamos el for vemos que:
\begin{displaymath}
\sum_{i=1}^{n/2} n = n \frac{n}{2} = \frac{n^{2}}{2} \in O(n^{2})
\end{displaymath}

\noindent
Concluimos que la función es cuadrática, $O(n^{2})$

\begin{minted}[linenos]{c++}
void funcion (int n)
{
      int x=2, contador=0;

      while (x <= n)
      {
            x *= 2;     //O(1)
            contador++; //O(1)
      }
      cout << contador;
}
\end{minted}

\noindent
Al ir aumentando $x$ multiplicándose por dos, el bucle lo repetiremos $log_{2}(n)$ veces, ya que la operación que hacemos en el bucle es $2^{x}=n$ y esa $x$ es $x=log_{2}(n)$:
\begin{displaymath}
\sum_{contador=0}^{log_{2}(n)} 1 = log_{2} n + 1 \in O(log_{2}(n))
\end{displaymath}

\label{eficiencia_sept2012}
\noindent
Ejercicio del examen de septiembre de 2012: ¿cuál es de mayor orden?
\begin{minted}[linenos]{c++}
int n, j;               int n, j;
int x=0, i=1;           int i=2, x=0;
do {                    do {
      j=1;                    j=1;
      while (j<=n)            while (j<=i)
      {                       {
            j *= 2;                 j*=2;
            x++;                    x++
      }                       }
      i++;                    i++;                               
} while (i<=n);         } while (i<=n)
\end{minted}

\noindent
El código de la izquierda repite su while $log_{2}(n+1)$ veces, y analizando el do while obtenemos que:
\begin{displaymath}
\sum_{i=1}^{n} log_{2} (n) + 1 = log_{2} (n) \sum_{i=1}^{n} 1 = nlog_{2}(n) + n \in O(nlog_{2}(n))
\end{displaymath}

\noindent
El código de la derecha repite su while $log_{2} i$ veces, y analizándolo junto al do while obtenemos que:
\begin{displaymath}
\sum_{i=2}^{n} log_{2} i = log_{2} (2) + log_{2} (3) + \cdots + log_{2}(n) = log_{2} (2 \cdot 3 \cdots n) = log_{2} (n!) \in O(log_{2}(n!))
\end{displaymath}

\noindent
Esta sumatoria puede acotarse por $nlog_{2} n$ ya que:
\begin{displaymath}
log_{2} (n!) = log_{2} 2 + log_{2} 3 + \cdots + log_{2} n \leq log_{2} n + log_{2} n + \cdots + log_{2} n  = nlog_{2} n
\end{displaymath}

\begin{minted}[linenos]{c++}
int suma = 0;
int k, j, n;
for (k=1; k<=n; k+=4)
      for (int j=1; j<=k; j*=2)
            suma++; //O(1)
\end{minted}

\noindent
Si estudiamos el segundo for anidado, vemos que:
\begin{displaymath}
\sum_{j=1}^{log_{2}k} 1 = log_{2}k
\end{displaymath}

\noindent
Y si ya estudiamos los bucles anidados en conjunto vemos que se ejecuta $\frac{n}{4}$ veces:
\begin{displaymath}
\sum_{k=1}^{n/4} log_{2}k = log_{2} 1 + log_{2} 2 + \cdots + log_{2} (\frac{n}{4}) = log_{2} (\frac{n}{4}!) \in O(log(n!))
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Cálculo de la eficiencia teórica en funciones recursivas}
\noindent
\begin{minted}[linenos]{c++}
int factorial (int n) //la eficiencia depende de n
{
      if (n<=1)
            return 1; //O(1)

      else
            return n*factorial(n-1);
}
\end{minted}

El tiempo de ejecución de la función es:
\begin{displaymath}
T(n) = \left\{ \begin{array}{ll}
T(n-1)+1  &  n \geq 2\\
1         &  n \leq 1
\end{array} \right.
\end{displaymath}

\noindent
Para calcular el orden del algoritmo, vamos descomponiendo el caso de $n \geq 2$:
\begin{center}
\begin{displaymath}
T(n) = 1 + T(n-1) \textrm{para $n \geq 2$}
\end{displaymath}
Para $n \geq 3$ sería $T(n-1) = T(n-2) + 1$
\begin{displaymath}
T(n) = 1 + 1 + T(n-2) \textrm{para $n \geq 3$}
\end{displaymath}
Para un caso general $k < n$ sería:
\begin{displaymath}
T(n) = T(n - k) + k
\end{displaymath}
Si hacemos que $k = n-1$:
\begin{displaymath}
T(n) = (n-1) + T(n - (n-1)) = (n - 1) + 1 = n \in O(n)
\end{displaymath}
\end{center}

\noindent
Así, concluimos que el factorial es de orden $O(n)$

\noindent
Otro ejemplo:
\begin{displaymath}
T(n) = \left\{ \begin{array}{ll}
T(n-1)+n  &  n \geq 2\\
1         &  n \leq 1
\end{array} \right.
\end{displaymath}

\noindent
Ejecutamos de igual manera que en el ejercicio anterior, sustituyendo $n$ por $n-1$

\begin{displaymath}
T(n) = n + T(n-1) \qquad\ n \geq 2
\end{displaymath}
\begin{displaymath}
T(n) = n + (n-1) + T(n-2) \qquad\ n \geq 3
\end{displaymath}
\begin{displaymath}
T(n) = n + (n-1) + (n-2) + T(n-3) \qquad\ n \geq 4
\end{displaymath}
\noindent
Para un $k < n$ tendríamos que:
\begin{displaymath}
T(n) = n+ (n-1) + \cdots + (n - (k + 1)) + T (n-k) \qquad\ n \geq k+1
\end{displaymath}
\noindent
Y si igualamos $n-1 = k $:
\begin{displaymath}
T(n) = n + (n - 1) + \cdots + n - (n-1) + T(1) =\underbrace{n + (n-1) + \cdots + 1}_{\textrm{progresión aritmética}} + 1 = (n+1)\frac{n}{2} + 1 \in O(n^{2})
\end{displaymath}

\newpage

\noindent
Algoritmo de Búsqueda Binaria:
\begin{minted}[linenos]{c++}
int BB (int * v, int n, int x)
{
      if (n > 0)
      {
            int m = (m/2);

            if (v[m]==x)
                  return m;

            else //hasta aqui, todo es O(1)
            {
                  if (v[m] > x)
                        return BB(v, (n/2), x); //T(n/2)

                  else
                        return BB(v+(n/2), n-(n/2), x); //T(n/2)

                  //toda la funcion es T(n/2) + 1
            }
      }

      else
            return -1; //O(1)
}
\end{minted}

\noindent
La función de Búsqueda Binaria se correspondería con la siguiente función
\begin{displaymath}
T(n) = \left\{ \begin{array}{ll}
T(\frac{n}{2})+1  &  n \geq 2\\
1         &  n \leq 1
\end{array} \right.
\end{displaymath}

\noindent
Ahora vamos a calcular su eficiencia. Tenemos que hacer un cambio de variable para cambiar el $\frac{n}{2}$ en función del valor anterior, como hemos hecho en los ejemplos anteriores:
\begin{displaymath}
n = 2^{m}
\end{displaymath}
\noindent
Y nos quedaría nuestra función así:
\begin{displaymath}
T(2^{m}) = 1 + T(\frac{2^{m}}{2}) \qquad\ 2^{m} \geq 2
\end{displaymath}
\noindent
Aplicamos logaritmos y así conseguimos que nuestra función esté en función del valor anterior:
\begin{displaymath}
T(2^{m}) = 1 + T(2^{m-1}) \qquad\ m \geq 1
\end{displaymath}
\begin{displaymath}
T(2^{m}) = 1 + 1 + T(2^{m-2}) \qquad\ m \geq 2
\end{displaymath}
\begin{displaymath}
T(2^{m}) = 3 + T(2^{m-3}) \qquad\ m \geq 3
\end{displaymath}
\noindent
Para un $k \leq m$ sería:
\begin{displaymath}
T(2^{m}) = k + T(2^{m-k}) \qquad\ m \geq k
\end{displaymath}
\noindent
Y si igualamos $k=m$ sería:
\begin{displaymath}
T(2^{m}) = m + T(2^{0}) = m + 1
\end{displaymath}
\noindent
Deshacemos el cambio de variable
\begin{displaymath}
n = 2^{m} \longrightarrow log_{2} n = log_{2} 2^{m} \longrightarrow log_{2} n = m log_{2} 2 \longrightarrow m = log_{2} n
\end{displaymath}
\noindent
Y sustituimos
\begin{displaymath}
T(log_{2} n) = log_{2} n+1 \in O(log_{2} n)
\end{displaymath}

\section{\textcolor[rgb]{0.1,0.2,0.6}Repaso de matemáticas}
\subsection{\textcolor[rgb]{0.1,0.2,0.6}Propiedades de los logaritmos}
\noindent
Un logaritmo es el número de veces que podemos dividir entre la base el número. Por ejemplo, $log_{2} (8) = 3$ porque podemos dividir ocho entre dos tres veces.
\begin{enumerate}[$\rightarrow$]
\item $log_{b}(x \cdot y) = log_{b} (x) + log_{b} (y)$
\item $log_{b} (\frac{x}{y}) = log_{b}(x) - log_{b}(y)$
\item $log_{b} (x^{y}) = y \cdot log_{b}(x)$
\item $log_{a} (x) = \frac{log_{b}(x)}{log_{b}(a)}$
\end{enumerate}

\subsection{\textcolor[rgb]{0.1,0.2,0.6}Propiedades de las exponenciales}
\begin{enumerate}[$\rightarrow$]
\item $a^{xy} = (a^{x})^{y}$
\item $a^{x+y} = a^{x} \cdot a^{y}$
\item $b^{x} = a^{xlog_{a}(b)}$
\item $b = a^{log_{a}(b)}$
\item $a^{x-y} = \frac{a^{x}}{a^{y}}$
\item $a^{log_{b}(n)} = n^{log_{b}(a)}$
\end{enumerate}

\noindent
$\lfloor x \rfloor \longleftarrow$ mayor entero menor o igual que x (en C++: floor)\\
$\lceil x \rceil \longleftarrow$ menor entero mayor o igual que x (en C++: ceil)\\
Ejemplo: $\lfloor 3.2 \rfloor = 3$ y $\lceil 3.5 \rceil = 4$

\subsection{\textcolor[rgb]{0.1,0.2,0.6}Sumatorias}
\begin{displaymath}
\sum_{i=S}^t f(i) = f(s) + f(s+1) + \cdots + f(t)
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Progresión aritmética}
\noindent
Para obtener el siguiente número sumanos uno al actual.

\begin{center}
\begin{displaymath}
\sum_{i=1}^n i = 1+2+3+4+ \cdots + n = \frac{n}{2}(n+1)
\end{displaymath}

Para deducirlo, nos debemos dar cuenta de que si sumamos el primero con el último, el segundo con el penúltimo, etc. obtenemos el mismo resultado(n+1). 
El $\frac{n}{2}$ se refiere al  numero de parejas,  sumando $n+1$,  que puedo formar con los $n$ términos. De tal forma obtengo:
\begin{displaymath}
n + 1 = (n-1) + 2 = (n-2) + 3 = \cdots = \frac{(n(n+1))}{2}
\end{displaymath}
\end{center}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Progresión geométrica}
\noindent
Para obtener el siguiente número multiplicamos el actual por a.

\begin{center}
\begin{displaymath}
\sum_{i=0}^h a^{i} = a^{0} + a^{1} + \cdots + a^{n} = \frac{a^{n+1} - 1}{2 - 1}
\end{displaymath}

Para deducirlo, multiplicamos todo por a y luego restamos:
\begin{displaymath}
\sum_{i=0}^h a^{i} = a^{0} + a^{1} + \cdots + a^{n} = S_{n}
\end{displaymath}
\begin{displaymath}
\sum_{i=0}^h a a^{i} = a^{1} + a^{2} + \cdots + a^{n+1} = aS_{n}
\end{displaymath}

Al restar nos queda que:
\begin{displaymath}
aS_{n} - S_{n} = a^{n+1} - a^{0}
\end{displaymath}

Sacamos factor común $S_{n}$:
\begin{displaymath}
S_{n}(a - 1) = a^{n+1} - a^{0}
\end{displaymath}

Y despejamos $S_{n}$:
\begin{displaymath}
S_{n} = \frac{a^{n+1} - 1}{a - 1}
\end{displaymath}
\end{center}

\subsubsection{\textcolor[rgb]{0.1,0.2,0.6}Suma de cuadrados}
\begin{center}
\begin{displaymath}
\sum_{i=1}^n i^{2} = 1^{2} + 2^{2} + 3^{2} + \cdots + n^{2} = \frac{n(n+1)(2n+1)}{6}
\end{displaymath}

Para deducirlo, primero debemos saber que: $(a+b)^{3} = a^{3} + b^{3} + 3a^{2}b + 3ab^{2}$. Con esto en mente, empezamos a calcular los cubos de los $n+1$ primeros números:
\begin{displaymath}
1^{3} = (1+0)^{3} = 1^{3}
\end{displaymath}
\begin{displaymath}
2^{3} = (1+1)^{3} = 1^{3} + 1^{3} + 3  1^{2} + 3  1^{2}
\end{displaymath}
.\\
.\\
.\\
\begin{displaymath}
(n+1)^{3} = (1+n)^{3} = 1^{3} + n^{3} + 3n + 3n^{2}
\end{displaymath}

Los sumamos:
\begin{displaymath}
1^{3} + 2^{3} + \cdots + (n+1)^{3} = (n+1) + (1^{3} + 2^{3} + \cdots + n^{3}) + 3(1+2+3+ \cdots + n) + 3 \sum_{i=1}^n i^{2}
\end{displaymath}
Ahora pasamos al otro miembro la parte de $(1^{3} + 2^{3} + \cdots + n^{3})$ y nos queda:
\begin{displaymath}
(n+1)^{3} = (n+1) + \frac{3n}{2}(n+1) + 3S_{n}
\end{displaymath}
Multiplicamos por 2:
\begin{displaymath}
2(n+1)^{3} = 2(n+1) + 3(n+1)n + 6S_{n}
\end{displaymath}
Por último, despejamos $S_{n}$:

\begin{displaymath}
S_{n} = \frac{(n+1)(2(n+1)^{2} - 2 - 3n)}{6}
\end{displaymath}
\begin{displaymath}
S_{n} = \frac{(n+1)(2n^{2} + 4n + 2 - 2 - 3n)}{6}
\end{displaymath}
\begin{displaymath}
S_{n} = \frac{(n+1)(2n^{2} + n)}{6}
\end{displaymath}
\begin{displaymath}
S_{n} = \frac{n(n+1)(2n+1)}{6}
\end{displaymath}
\end{center}

\chapter{\textcolor[rgb]{0.8,0.2,0.2}{Abstracción de datos}}
\section{\textcolor[rgb]{0.8,0.2,0.2}Concepto de Abstracción y documentación}
\noindent
La \textit{\textcolor[rgb]{0.8,0.2,0.2}{abstracción}} consiste en crear una capa sobre otra u otras capas. En MP la practicamos como \textit{\textcolor[rgb]{0.8,0.2,0.2}{ocultación de información}}.

\noindent
Un módulo se divide en dos partes: la interfaz es pública y la implementación y la representación del tipo de dato abstracto, privada. Si un módulo necesita de otro se comunica con éste a través de su interfaz.

\noindent
Ejemplo: clase Matriz
\begin{minted}[linenos]{c++}
class Matriz
{
      private:
            //Representacion del tipo Matriz

      public:
            Matriz();
            Matriz(Matriz &m);
            int Filas() const;
            //etc
}
\end{minted}
\noindent
En matriz.cpp estaría la implementación de los métodos, esto se considera también privado ya que cualquier módulo ajeno a Matriz no tiene por qué saber la implementación de las funciones:

\begin{minted}[linenos]{c++}
//operaciones.h
Matriz operator+ (const Matriz &m1, const Matriz &m2);

//operaciones.cpp
      /*Implementacion del operator+*/

//El main solo tiene que conocer la interfaz de Matriz, es decir el fichero .h
#include <iostream>
#include "Matriz.h"

int main ()
{
      Matriz m1, m2, m3;
      cin >> m1;
      cin >> m2;
      m3 = m1+m2;
}
\end{minted}

\noindent
La \textit{\textcolor[rgb]{0.8,0.2,0.2}{Documentación}} consiste en escribir con lenguaje natural qué hace cada método de nuestra clase/módulo. 
Para documentar existen diferentes herramientas. Nosotros  usaremos  \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Doxygen}} \url{http://www.doxygen.org}

\subsection{\textcolor[rgb]{0.8,0.2,0.2}Abstracción por especificación}
\noindent
En la abstracción por especificación, se dan los detalles del módulo independientemente de la implementación. Para ello debemos dar información sobre:
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Características sintácticas}}: indicar la cabecera de la función
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Características semánticas}}: indicar qué hace y qué devuelve la función con lenguaje natural. Aquí debemos tener en cuenta que el ¿Qué? \textbf{SÍ} importa mientras que el ¿CÓMO?, \textbf{NO}.
\end{enumerate}

\noindent
Ejemplo: operación suma de matrices.
\begin{enumerate}[$\spadesuit$]
\item \underline{COMENTARIO 1}: recorre la matriz mediante un for para las filas y otro for para las columnas y suma el elemento de la primera matriz con el de la segunda
\item \underline{COMENTARIO 2}: obtiene la matriz suma de las dos matrices de entrada.
\end{enumerate}

\noindent
La opción válida aquí es la segunda.

\noindent
Ejemplo de una función con su respectiva documentación:
\begin{minted}[linenos]{c++}
//busqueda.h

/**
* @ file ref_abst.h
* @ brief modulo de busqueda sobre un vector
**/
/**
* @ brief Busca en un vector un elemento dado
* @ param v: vector que contiene donde buscar el elemento de entrada \e x
* @ param n: numero de elementos del vector v
* @ param x: elemento a buscar en v
* @ pre
* - n \> 0
* - v tiene al menos n elementos
* @ return devuelve la posicion del elemento x en v
* @ exception devuelve -1 si x no esta en el vector
**/
int Busqueda (int *v, int n, int x);

//Las condiciones que se deben cumplir tras ejecutar la condicion se expresan con @ post
\end{minted}

\subsection{\textcolor[rgb]{0.8,0.2,0.2}Tipo de dato abstracto}
\noindent
Un tipo de dato abstracto es un conjunto de datos junto con unas operaciones proporcionando sobre estos una especificación que es independiente de la implementación.

\noindent
Ejemplo: Tipo de dato abstracto Matriz.
\begin{enumerate}[$\heartsuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: Conjunto de datos dispuestos en una serie de filas y columnas.
\begin{enumerate}[---]
\item Las operaciones que realizamos con el tipo Matriz son:
\begin{itemize}
\item Constructores (por defecto, copia, por parámetros...)
\item Operadores (asignación, suma...)
\item Operadores de consulta (GetFilas, GetColumnas...)
\item Operadores de modificación (SetFilas, SetColumnas...)
\item Operadores de E/S
\end{itemize}
\end{enumerate}
\end{enumerate}

\noindent
Debemos resaltar que sobre la implementación no se dice nada en la fase de especificación.
Para la implementación debemos seguir los siguientes pasos:
\begin{enumerate}[1.]
\item Elegir una representación.
\item Basándonos en la representación escogida, implementar las operaciones.
\end{enumerate}

\noindent
Dentro de los tipos de datos abstractos podemos diferenciar dos tipos:
\begin{enumerate}[$\spadesuit$]
\item T.D.A. dado en el especificación.
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}: tipo a usar para representar el T.D.A. dado en la especificación, 
está asociado con la implementación.
\end{enumerate}

\noindent
Ejemplo: implementación T.D.A. fecha:
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: representa una fecha en el calendario occidental ``d/m/a''
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}:
\begin{enumerate}[$\heartsuit$]
\item Posibilidad 1:
\begin{minted}[linenos]{c++}
class Fecha {
      private:
            int d, m, a;
\end{minted}
\item Posibilidad 2:
\begin{minted}[linenos]{c++}
class Fecha {
      private:
            string f;
\end{minted}
\item Posibilidad 3:
\begin{minted}[linenos]{c++}
enum Mes = {ENE, FEB, MAR, ABR, MAY, JUN, JUL, AGO, SEP, OCT, NOV, DIC}
class Fecha {
      private:
            int d, a;
            Mes m;
\end{minted}
\end{enumerate}
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Función de abstracción}
\noindent
Es una función que conecta el T.D.A. dado en la especificación con el tipo rep:
\begin{displaymath}
f_{A}: rep \longrightarrow \textrm{T.D.A. especificación}
\end{displaymath}

\noindent
Ejemplo: Fecha.

\noindent
Tras haber elegido la posibilidad 1, nuestra función de abstracción es:
\begin{displaymath}
f_{A} = \textrm{``r.d/r.m/r.a''}
\end{displaymath}

\noindent
Donde $r$ es una instancia de objeto abstracto de tipo ``representación'' ajeno al lenguaje de programación y que sirve para crear T.D.A.

\noindent
Ejemplo: T.D.A. Racional
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: representa a los números racionales de tal forma que, si $n$ es el numerador y $d$ es el denominador, el racional asociado es $\frac{n}{d}$
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}:
\begin{minted}[linenos]{c++}
class Racional {
      private:
            int num, dem;
\end{minted}
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Función de abstracción}}: \begin{displaymath} f_{A}(r) = \frac{r.num}{r.dem} \end{displaymath}
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Invariante de la representación}
\noindent
Son las condiciones que debe cumplir el tipo rep para representar el T.D.A. dado en la especificación.

\noindent
Ejemplo: T.D.A. Racional
\begin{enumerate}[$\spadesuit$]
\item El denominador debe ser distinto de cero
\end{enumerate}

\noindent
Ejemplo: fecha (con posibilidad 1)
\begin{enumerate}[$\spadesuit$]
\item $1 \leq d \leq 31$
\item $1 \leq m \leq 12$
\item Si $m=4, 6 ,9, 11$ y $bisiesto(a) \rightarrow m \leq 30$
\item Si $m=2$ y $bisiesto(a) \rightarrow d \leq 29$
\item Si $m=2$ y $\neg bisiesto(a) \rightarrow d \leq 28$
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Ejemplos completos}
\noindent
Ejemplo: T.D.A. Polinomio
\begin{enumerate}[$\heartsuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: sucesión de reales ${a_{0}, a_{1},\cdots,a_{n}}$ que representan polinomios con coeficientes reales del tipo $a_{n}x^{n}+a_{n-1}x^{n-1}+\cdots+a_{0}$

\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}:
\begin{minted}[linenos]{c++}
class Polinomio {
      private:
            float * p;
            int maxgrado;
\end{minted}

\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}Función de abstracción}
\begin{displaymath}
f_{A}(r) = r.p[r.maxgrado]x^{r.maxgrado} + r.p[r.maxgrado-1]x^{r.maxgrado-1} + \cdots + r.p[0]
\end{displaymath}

\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Invariante de la representación}}:
\begin{enumerate}[---]
\item maxgrado $\geq 0$
\item p tiene reservada, al menos, memoria para $maxgrado+1$
\item $p[maxgrado] \neq 0$
\item $\forall i > maxgrado \longrightarrow p[i]=0$
\end{enumerate}
\end{enumerate}

\noindent
Ejemplo: T.D.A. DNI
\begin{enumerate}[$\heartsuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: secuencia de 8 dígitos seguidos por una letra tal que el dígito más significativo es distinto de cero: $d_{7}d_{6}\cdots d_{0}l$
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Operaciones}}:
\begin{itemize}
\item Constructor por parámetros
\item Consulta ---Get DNI---
\item Modificación ---Set---
\item Operaciones E/S
\end{itemize}
\end{enumerate}
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}:
\begin{minted}[linenos]{c++}
class DNI {
      private:
            char * d;

class DNI {
      private:
            int num;
            char letra;

class DNI {
      private:
            char dni[9];
\end{minted}
Si escogemos esta última representación podemos definir la función de abstracción e invariante de la representación
de la siguiente manera.
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Función de abstracción}}:
\begin{displaymath}
f_{A} = D.dni[7] D.dni[6] \cdots D.dni[0] D.dni[8]
\end{displaymath}

\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Invariante de la representación}}:
\begin{enumerate}[$\spadesuit$]
\item $D.dni[i] \in ['0'-'9'] \forall i=0 \cdots 6 \bigwedge D.dni[7] \in ['1'-'9']$
\item $D.dni[8] \in ['A'-'Z']$
\end{enumerate}
\end{enumerate}

\noindent
Ejemplo: T.D.A. Números primos.
\begin{enumerate}[$\heartsuit$]
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Especificación}}: es una secuencia ordenada de enteros ${a_{0}, a_{1},\cdots,a_{n-1}}$ tal que $\forall i ~a_{i}$ es divisible sólo entre $1$ y él mismo.
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Tipo rep}}:
\begin{minted}[linenos]{c++}
class N_Primo {
      private:
            int *p;
            int n;
\end{minted}
\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Función de abstracción}}:
\begin{displaymath}
f_{A}(r) = {r.p[0], r.p[1], \cdots, r.p[r.n-1]}
\end{displaymath}

\item \textbf{\textcolor[rgb]{0.8,0.2,0.2}{Invariante de representación}}:
\begin{enumerate}[$\spadesuit$]
\item $\forall i, j$ tales que $i < j \longrightarrow r.p[i] < r.p[j], 0 \leq i, j < n$
\item $\forall i ~r.p[i]$ es divisible sólo por 1 y por él mismo, $0 \leq i < n$
\item $n \geq 0$
\item $p$ tiene que tener memoria suficiente para almacenar $n$ enteros
\end{enumerate}
\end{enumerate}

\section{\textcolor[rgb]{0.8,0.2,0.2}Abstracción por generalización (Funciones plantilla - Templates)}
\subsection{\textcolor[rgb]{0.8,0.2,0.2}Funciones plantilla}
\noindent
Proceso en el que se extraen características comunes a varios objetos con objeto de definir una generalización.

\noindent
Ejemplo: Función intercambiar para int y para float
\begin{minted}[linenos]{c++}
void Intercambiar (int &a, int &b) {        void Intercambiar (float &a, float &b) {
      int aux = a;                                 int aux = a;
      a = b;                                       a = b;
      b = aux;                                     b = aux;
}                                           }
\end{minted}

\noindent
El problema es que esas funciones sólo sirven para floats e int, si queremos una función ``universal'' podemos hacer una plantilla, en C++ sería:
\begin{minted}[linenos]{c++}
template <class T> //T es un objeto plantilla generico
void Intercambiar (T &a, T &b)
{
      T aux = a;
      a = b;
      b = aux;
}

int main ()
{
      float f1=5, f2=7;
      Intercambiar (f1,f2);
      string s1="hola", s2="adios";
      Intercambiar(s1, s2);
}
\end{minted}

\noindent
Ahora ambos llaman a la misma función intercambiar y es el compilador, en la precompilación, quien genera dos funciones con los distintos tipos.

\noindent
Ejemplo: función de ordenación
\begin{minted}[linenos]{c++}
template <class T>
void Ordenar_Seleccion (T *v, int n)
{
      int i, minimo;

      for (i=0; i<n-1; i++)
      {
            minimo = i;
            for (int j=i+1; j<n; j++)
                  if (v[j] < v[minimo])
                        Intercambiar(v[j], v[minimo]);
      }
}

int main ()
{
      int v_int[] = {5,3,7,15,1,2};
      Ordena_Seleccion (v_int, 6);

      char v_ch[] = {'e','f','d','a','i'};
      Ordena_Seleccion (v_ch, 5);
}
\end{minted}

\subsection{\textcolor[rgb]{0.8,0.2,0.2}Clases plantilla}
\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}TDA Vector Dinámico}
\noindent
Ejemplo: clase vector dinámico
\begin{minted}[linenos]{c++}
//VD.h
template <class T>
class VD
{
      private:

            T* datos;
            int n; //numero de datos almacenados
            int reservado; //espacio asignado a datos
            void resize (int nuevotam);
            void Copiar (const VD<T> &v);
            void Liberar ();

      public:
            VD (int tam=10);
            VD (const VD<T> &original); //constructor de copia
            ~VD ();
            VD<T> &operator= (const VD<T> &v);
            int size() const {return n;}
            T &operator[] (int i) {return datos[i];}
            const T &operator[] (int i) const {return datos[i];}
            void Insertar (const T &d, int pos);
            void Borrar (int pos);
};

#include "VD.cpp" //Ojo: Ahora es VD.h quien incluye al VD.cpp y no al contrario .

//principal.cpp
#include "VD.h"
int main ()
{
      VD<int> vint;
      VD<char> vch(100);
      VD<string> vs;
}
\end{minted}

\noindent
No podemos compilar VD y principal por separado porque no podemos saber lo que ``pesa'' T. Por eso, las plantillas no se compilan (NO existe VD.o). Compilariamos principal.cpp y en la fase de preprocesamiento incluiriamos VD.h y VD.cpp. Y en VD.h incluimos VD.cpp porque al no tener VD.o debemos incluir en el VD.h la implementación de las funciones
\begin{minted}[linenos]{c++}
//VD.cpp
//No ponemos #include "VD.h", ya hemos incluido VD.cpp en el VD.h
template <class T>
void VD<T> :: resize(int nuevotam)
{
      T *aux = new T [nuevotam];
      int minimo = (n<nuevotam)?n:nuevotam;
      for (int i=0; i<minimo; i++)
            aux[i] = datos[i];

      reservados = nuevotam;
      n = minimo;
      delete [] datos;
      datos = aux;
}

template <class T>
void VD<T> :: Copiar (const VD<T> &v)
{
      reservados = v.reservados;
      n = v.n;
      datos = new T [reservados];
      for (int i=0; i<n; i++)
            datos[i] = v.datos[i];
}

template <class T>
void VD<T> :: Liberar()
{
      delete [] datos;
}

template <class T> //en otros sitios el class se sustituye por typename
VD<T> :: VD (int tam)
{
      reservados = tam;
      datos = new T [reservados];
      n=0;
}

VD<T> :: VD(const VD<T> &original)
{
      Copiar(original);
}

template <class T>
VD<T> :: ~VD()
{
      Liberar();
}

template <class T>
VD<T> & VD<T> :: operator=(const VD<T> & v)
{
      if (this != &v)
      {
            Liberar();
            Copiar(v);
      }

      return *this;
}

template <class T>
void VD<T> :: Insertar (const T &d, int pos)
{
      /*segun estudios estadisticos, la mejor forma de usar un vector dinamico es
      que n < reservados/2, y cuando se supere esa cifra hacer un resize de
      2*reservados*/

      if (n >= (reservados/2))
            resize(2*reservados);

      for (int i=n; i > pos; i--)
            datos[i] = datos[i-1];

      datos[pos] = d;
      n++;
}

template <class T>
void VD<T> :: Borrar (int pos)
{
     for (int i=pos; i<n-1; i++)
        datos[i] = datos[i+1];

    n--;

    if (n < (reservados/4))
        resize (reservados/2);
}
\end{minted}

\subsection{\textcolor[rgb]{0.8,0.2,0.2}T.D.A. Conjunto de enteros}
\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Especificación}
\noindent
Un objeto de tipo de dato abstracto \textit{\textcolor[rgb]{0.8,0.2,0.2}{conjunto}}
es una colección ordenada de elementos de tipo entero en la que no existen elementos
repetidos
\begin{displaymath}
    \{a_{0}, a_{1}, \cdots, a_{n-1}\} \qquad\ \textrm{tales que} \qquad \forall i, j \quad i < j \Longrightarrow a_{i} < a_{j}
\end{displaymath}

\noindent
Es decir, es ordenada y no tiene elementos repetidos. Al número de elementos del conjunto
se le denomina \textit{\textcolor[rgb]{0.8,0.2,0.2}{cardinal}}. Si el cardinal del conjunto es $0$ se le denomina
\textit{\textcolor[rgb]{0.8,0.2,0.2}{conjunto vacío}}.

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Tipo rep}
\begin{minted}[linenos]{c++}
    class Conjunto {
        private:
            VD<int> d;
\end{minted}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Función de abstracción}
\begin{displaymath}
    f_{A}(r) = \{r.d[0], r.d[1], \cdots, r.d[r.d.size()-1]\}
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Invariante de representación}
\begin{enumerate}[$\bullet$]
    \item $r.d[i] < r.d[j] \quad \forall i < j$ \footnote{es decir, no hay elementos repetidos y todos los elementos están ordenados}
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.8,0.2,0.2}Implementación}
\begin{minted}[linenos]{c++}
//Conjunto.h
#include "VD.h"

struct pareja {
    int pos;
    bool esta;
};

class Conjunto {
    private:
        VD<int> d;

    public:
        /*Como no tenemos memoria dinamica, no tenemos que definir
        contructor por defecto, de copia o destructor. El que tiene memoria
        dinamica es VD y ya la gestiona.*/

        int size () const {return d.size();} //devuelve el cardinal
        //Devuelve si esta un elemento y su posicion, en caso de no
        //estarlo, devuelve el sitio en el que deberia estar
        pareja Esta (int x);
        void Insertar (int x);
        void Borrar (int x);
};
\end{minted}

\begin{minted}[linenos]{c++}
//Conjunto.cpp
#include "Conjunto.h"

pareja Conjunto :: Esta (int x) const {
    //Al estar ordenado podemos hacer una busqueda binaria
    int n = d.size();
    int inicio = 0, fin = n;

    while (inicio < fin) {
        int mitad = (inicio + fin)/2;
        if (d[mitad] == x) {
            pareja p = {mitad, true};
            return p;
        }

        else {
            if (x > d[mitad])
                inicio = mitad + 1;

            else
                fin = mitad;
        }

        pareja p = {inicio, false};
        return p;
    }
}

void Conjunto :: Insertar (int x) {
    pareja p = Esta (x);

    if (!p.esta)
        d.Insertar (p.pos, x);
}

void Conjunto :: Borrar (int x) {
    pareja p = Esta (x);

    if (p.esta)
        d.Borrar (d.pos);
}
\end{minted}

\chapter{\textcolor[rgb]{0.2,0.5,0.5}{Tipos de datos contenedores básicos}}
\section{\textcolor[rgb]{0.2,0.5,0.5}Contenedores lineales}
\noindent
Se caracterizan por ser:
\begin{description}
    \item[Contenedores]: estructuras que almacenan datos de un mismo tipo base. Ej: vectores y listas
    \item[Lineales]: contienen una secuencia de elementos dispuestos en una dimensión $\{a_{0}, a_{1}, \cdots, a_{n}\}$
\end{description}

\noindent
En este tema vamos a estudiar:
\begin{enumerate}[---]
    \item Pilas
    \item Colas
    \item Colas con prioridad
    \item Listas
    \item Vectores
\end{enumerate}

\section{\textcolor[rgb]{0.2,0.5,0.5}Pila}
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Especificación}}: contiene una secuencia de elementos $\{a_{0}, a_{1}, \cdots, a_{n}\}$ en la que las pilas están optimizadas para realizar inserciones, consultas y borrados por sólo uno de los extremos (Estructura LIFO: \textit{\textcolor[rgb]{0.2,0.5,0.5}{last input first output}})
\begin{itemize}
    \item Las consultas se realizan sobre $a_{n}$
    \item Los borrados se hacen sobre $a_{n}$
    \item Las inserciones se hacen sobre $a_{n}$
    \item No se puede acceder a la pila por otro lado que no sea el tope
\end{itemize}
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Operación}}:
\begin{itemize}
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Tope}}: consulta el elemento del tope
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Vacía}}: devuelve true si la pila no tiene ningún elemento
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Quitar(pop)}}: elimina el elemento en el tope
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Poner(put)}}: inserta un nuevo elemento en el tope
\end{itemize}
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Implementación}}:
\begin{itemize}
    \item Basada en vectores
    \item Basada en celdas enlazadas
\end{itemize}
\end{enumerate}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Vectores estáticos}
\begin{minted}[linenos]{c++}
#include <cassert>

template <class T>
class Pila {
    private:
        T datos[200]; //Cantidad real que nunca vamos a llenar
        int nelementos;

    public:
        Pila () {
            nelementos = 0;
        }

        T Tope () const {
            //el tope seria nelementos-1
            assert (nelementos > 0); //nos aseguramos de que hay, al menos, un elemento
            return datos[nelementos-1];
        }

        void Quitar () {
            assert (nelementos > 0);
            nelementos--;
        }

        void Poner (T v) {
            assert (nelementos < 200);
            datos[nelementos] = v;
            nelementos++;
        }

        int size() const {
            return nelementos;
        }

        bool Vacia () {
            return (nelementos == 0);
        }
};
\end{minted}

\noindent
Si tenemos pocos elementos estamos desaprovechando la memoria con tantos elementos
reservados pero todas las operaciones son $O(1)$, por lo que si, por ejemplo, tenemos un número de
elementos  en promedio de $150$ y nunca sobrepasamos los $200$ es útil.

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Celdas enlazadas}
\begin{minted}[linenos]{c++}
//Pila.h
#include <cassert>
template <class T>
struct Celda {
    T d;
    Celda<T> *sig;
};

template <class T>
class Pila {
    private:
        Celda<T> *datos;
        void Copiar (const Pila<T> &p);
        void Borrar ();

    public:
        Pila () {datos = 0;}
        Pila (const Pila<T> &P) {Copiar (P);}
        ~Pila () {Borrar();}
        Pila<T> operator= (const Pila<T> &P);
        T Tope () const;
        void Quitar ();
        void Poner (const T &v);
        bool Vacia () const {return datos==0;}
};
\end{minted}

\begin{minted}[linenos]{c++}
//Pila.cpp
template <class T>
void Pila<T> :: Copiar (const Pila &P) {
    if (P.datos == 0)
        datos = 0;

    else {
        datos = new Celda<T>;
        datos->d = P.datos->d;
        Celda<T> *p = datos;
        Celda<T> *q = P.datos->sig;
        while (q != 0) {
            p->sig = new Celda<T>;
            p = p->sig;
            p->d = q->d;
            q = q->sig;
        }

        p->sig = 0;
    }
}

template <class T>
void Pila<T> :: Borrar () {
    while (datos != 0) {
        Celda<T> *aux = datos;
        datos = datos->sig;
        delete aux;
    }
}

template <class T>
T Pila<T> :: Tope () const {
    assert (datos != 0);
    return datos->d;
}

template <class T>
void Pila<T> :: Quitar () {
    assert (datos != 0);
    Celda<T> *aux = datos;
    datos = datos->sig;
    delete aux;
}

template <class T>
void Pila<T> :: Poner (const T &v) {
    Celda<T> *aux = new Celda<T>;
    aux->d = v;
    if (datos == 0) {
        datos = aux;
        datos->sig=0;
    }

    else {
        aux->sig=datos;
        datos=aux;
    }
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Vector Dinámico}
\begin{minted}[linenos]{c++}
#include "VD.h"
#include <cassert>

//Pila.h
template <class T>
class Pila {
    private:
        VD<T> datos;

    public:
        /*Al igual que con la clase conjunto, no necesitamos implementar
        Un constructor ni nada de eso pues ya esta implementado en la clase
        Vector Dinamico*/
        T Tope () const {return datos[0];}
        void Quitar () {datos.Borrar(0);}
        void Poner (const T &v) {datos.Insertar(v, 0);}
        bool Vacia () const {return datos.size() == 0;}
};
\end{minted}
\begin{center}
\textbf{\textcolor[rgb]{0.2,0.5,0.5}{Eficiencia}}\\
\begin{tabular}{|c|c|c|}
    \hline
    \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Pila}} & VD & Celdas \\
    \hline
    \textit{\textcolor[rgb]{0.2,0.5,0.5}{Poner}} & $O(n)$ & $O(1)$ \\
    \hline
    \textit{\textcolor[rgb]{0.2,0.5,0.5}{Quitar}} & $O(n)$ & $O(1)$ \\
    \hline
    \textit{\textcolor[rgb]{0.2,0.5,0.5}{Vacia}} & $O(1)$ & $O(1)$ \\
    \hline
    \textit{\textcolor[rgb]{0.2,0.5,0.5}{Tope}} & $O(1)$ & $O(1)$ \\
    \hline
\end{tabular}
\end{center}

\noindent
Según la tabla anterior, la representación por Celdas Enlazadas es mucho mejor. Por otro lado
los tiempos de Poner y Quitar con VD podríamos suponer que son O(1) si tenemos en cuenta el tiempo
Amortizado (suponer en promedio el tiempo que gastaría insertar/borrar un elemento cuando se han
hecho $n$ insercciones y borrados consecutivos).

\section{\textcolor[rgb]{0.2,0.5,0.5}Cola}
\noindent
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Especificación}}: Son estructuras de datos lineales que contienen una secuencia de datos
\begin{displaymath}
    \{a_{0},a_{1},\cdots,a_{n}\}
\end{displaymath}
Y están especialmente diseñadas para hacer las inserciones por un extremo y los borrados
y consultas por otro. El extremo en el que están los primeros valores ($a_{0},a_{1},\cdots$)
se llama \textit{\textcolor[rgb]{0.2,0.5,0.5}{frente}}, y es por el que se hacen
las consultas y borrados. El extremo en el que están los últimos valores ($a_{n}$)
se llama \textit{\textcolor[rgb]{0.2,0.5,0.5}{última}} y es por el que se realizan las inserciones.
Las colas responden a la política FIFO (\textit{\textcolor[rgb]{0.2,0.5,0.5}{first input first output}}).

\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Operaciones típicas}}:
\begin{itemize}
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Frente}} $\longrightarrow$ consulta o accede al elemento en el frente
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Vacía}} $\longrightarrow$ devuelve true si la cola está vacía
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Quitar}} $\longrightarrow$ elimina el elemento que está en el frente
    \item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Poner}} $\longrightarrow$ añade un nuevo elemento por el final
\end{itemize}

\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Implementación}}:
\begin{itemize}
    \item Con celdas enlazadas y dos punteros (todas las operaciones nos cuestan $O(1)$)
    \item Con vectores
\end{itemize}
\end{enumerate}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Celdas enlazadas y dos punteros}
\begin{minted}[linenos]{c++}
//cola.h
#ifndef _COLA_H
#define _COLA_H

template <class T>
class Cola {
private:
    //Fuera del entorno de la clase, no existe celda
    //para que exista, lo definimos o bien fuera o en la parte publica
    struct Celda {
        T dato;
        Celda<T> *sig;
        Celda<T> (const T &d, Celda<T> *s) {
            dato = d;
            sig = s;
        }
    };
    Celda *primera, *ultima;
    void Copiar (const Cola<T> &c);
    void Borrar ();

public:
    Cola () {primera=ultima=0;}
    Cola (const Cola<T> &c) {Copiar(c);}
    ~Cola () {Borrar();}
    Cola<T> & operator= (const Cola<T> &c);
    void Poner (const T &d);
    void Quitar ();
    T Frente ();
    bool Vacia () const {return primera==0;}
};
#include "Cola.cpp"
#endif
\end{minted}

\begin{minted}[linenos]{c++}
//Cola.cpp
template <class T>
void Cola<T>::Copiar (const Cola<T> &c) {
    if (c.primera==0)
        primera = ultima = 0;
    else {
        primera = new Celda<T> (c.primera->dato, 0);
        ultima = primera;
        Celda<T> *q = c.primera->sig;
        while (q!=0) {
            ultima->sig = new Celda<T> (q->dato, 0);
            ultima = ultima->sig;
            q = q->sig;
        }
    }
}

template <class T>
void Cola<T>::Borrar() {
    while (primera != 0) {
        Celda<T> *aux = primera;
        primera = primera->sig;
        delete aux;
    }
    ultima = 0;
}

template <class T>
Cola<T> & Cola<T>::operator= (const Cola &c) {
    if (this != &c) {
        Borrar ();
        Copiar (c);
    }
    return *this;
}

template <class T>
void Cola<T>::Poner(const T &e) {
    Celda<T> *aux = new Celda<T>(e,0);
    if (primera == 0)
        primera = ultima = aux;
    else {
        ultima->sig = aux;
        ultima = aux;
    }
}

template <class T>
void Cola<T>::Quitar() {
    assert (primera != 0);
    Celda<T> *aux = primera;
    primera = primera->sig;
    delete aux;
}

template <class T>
T Cola<T>::Frente()const {
    assert(primera != 0);
    return primera->dato;
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Vectores}
\begin{description}
\item[Coste de las operaciones]: las operaciones típicas de una cola con una implementación basada en vectores tiene una eficiencia de:
\begin{enumerate}[$\bullet$]
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Vacía}} $\longrightarrow$ return $n==0$, tiene eficiencia $O(1)$
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Frente}} $\longrightarrow$ return $v[0]$, tiene eficiencia $O(1)$
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Poner}} $\longrightarrow$ $v[n] = nuevo\_elemento;$, si tenemos memoria suficiente, tiene eficiencia $O(1)$ y si tenemos que ampliar el vector, $O(n)$ 
Si tenemos en cuenta el tiempo Amortizado realmente nos costaría en promedio $O(1)$
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Quitar}} $\longrightarrow$ debemos hacer un for para desplazar todos los elementos por lo que tenemos eficiencia $O(n)$

\end{enumerate}
\end{description}

\noindent
Para mejorar la eficiencia de quitar nos replanteamos el vector. Debemos pasar de $O(n)$ a $O(1)$ para ello podemos tener dos índices extra: uno que apunte al primer elemento y otro que apunte al último. Así, cuando queramos quitar un elemento sólo debemos desplazar el primer índice dejando ese elemento como valor basura. El problema de esta solución es que puede llegar un momento en el que se colapse la memoria. Para solucionarlo, usamos \textit{\textcolor[rgb]{0.2,0.5,0.5}{vectores circulares}}: cuando nos quedamos sin espacio por el final (el índice del primer elemento y el del último se igualan), seguimos rellenando por el principio.

\begin{minted}[linenos]{c++}
//Cola.h
template <class T>
class Cola {
private:
      T *datos;
      int n; //elementos almacenados
      int capacidad; //espacio reservado para datos
      int primero, ultimo;
      void resize (int tam);
      void Copiar (const Cola<T> &c);

public:
      Cola (int tam=1);
      Cola (const Cola<T> &c);
      ~Cola();
      Cola<T> &operator= (const Cola<T> &c);
      int size () const {return n;}
      bool Vacia () const {return n==0;}
      bool Llena () const {return n==capacidad;}
      T Frente () const;
      void Poner (const T &v);
      void Quitar ();
}
#include "Cola.cpp"
\end{minted}

\begin{minted}[linenos]{c++}
//Cola.cpp
template <class T>
void Cola<T>::resize (int tam) {
      T *aux = new T [tam];
      int minimo = (n<tam)?n:tam;
      for (int i=0; i<minimo; i++)
            aux = datos[(i+primero)%capacidad]; //poner datos[i] estaria mal porque el 
                                                //primero de datos no tiene que 
                                                //coincidir con i
      primero=0;
      ultimo=minimo;
      capacidad=tam;
      delete [] datos;
      datos = aux;
}

template <class T>
void Cola<T>::Copiar (const Cola<T> &c) {
      capacidad = c.capacidad;
      primero = c.primero;
      ultimo = c.ultimo;
      n = c.n;
      datos = new T [capacidad];
      for (int i=0; i<n; i++)
            datos[(i+primero)%capacidad]=c.datos[(i+primero)%capacidad];
}

template <class T>
Cola<T>::Cola(int tam) {
      capacidad=tam;
      primero=ultimo=0;
      n=0;
      datos=new T [capacidad];
}

template <class T>
Cola<T>::Cola(const Cola<T> &c) {
      Copiar(c);
} 

template <class T>
Cola<T>::~Cola(){
      if (datos != 0) {
            delete [] datos;
      }
}

template <class T>
Cola<T> & Cola<T>::operator= (const Cola<T> &c) {
      if (this != &c) {
            if (datos != 0)
                  delete [] datos;

            Copiar(c);
      }
      return *this;
}


template <class T>
T Cola<T>::Frente()const {
      assert(n>0);
      return datos[0];
}

template <class T>
void Cola<T>::Poner(const T &v) {
      if (n==capacidad)
            resize (2*capacidad);

      datos[ultimo]=v;
      ultimo=(ultimo+1)%capacidad;
      n++;
}

template <class T>
void Cola<T>::Quitar () {
      primero = (primero+1)%capacidad;
      n--;
      if (n<(capacidad/4))
            resize(capacidad/2);
}

//Ahora, si no hacemos resize tenemos eficiencia O(1)
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Ejemplos}
\noindent
\underline{Ejercicio}: Tenemos una cola con enteros y queremos eliminar todos los elementos repetidos consecutivos en la cola.

\noindent
Nuestra cola $c$ sería:
\begin{center} 1 1 2 2 2 5 5 1 \end{center}

\noindent
Y el resultado que queremos obtener en nuestra cola $caux$ es:
\begin{center} 1 2 5 1 \end{center}

\noindent
Solución:
\begin{minted}[linenos]{c++}
#include "Cola.h"

void EliminarConsecutivos (Cola<int> &c)
{
      Cola<int> caux;

      while (!c.Vacia())
      {
            int d = c.Frente();
            c.Quitar();
            caux.Poner(d);
            while (!c.Vacia() && d==c.Frente())
                  c.Quitar();
      }

      while (!caux.Vacia())
      {
            int d = caux.Frente();
            c.Poner(d);
            c.Quitar();
      }
}
\end{minted}

\noindent
\underline{Ejercicio}: hacer una cola de enteros con dos pilas: una para consultas y borrados $P_{1}$ y otra para inserciones $P_{2}$.

\noindent
Vamos a ver, antes de la implementación, varios ejemplos de cómo funciona una cola con dos pilas.

\begin{enumerate}
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Insertar}}: 3 2 1 9

P1: 3 2 1 9 $\qquad$ donde 9 es el tope de la pila

P2:

\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Consultar frente}}: para ello debemos insertar los elementos en P2 para obtener el primer elemento que se insertó en la cola:

P1:

P2: 9 1 2 3 $\qquad$ en este caso, el frente sería 3

\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Insertar}}: 5 7

P1: 5 7

P2: 9 1 2 3

\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Quitar (el frente)}}:

P1: 5 7

P2: 9 1 2
\end{enumerate}

\noindent
Podemos quitar elementos de P2 hasta dejarla vacía, y si quisiésemos seguir quitando, insertaríamos los elementos de P1 en P2 y haríamos la operación de quitar el frente.

\begin{minted}[linenos]{c++}
#include "Pila.h"

class Cola
{
private:
      Pila<int> p1; //insertar
      Pila<int> p2; //frente y quitar

public:
      int Frente () {
            if (p2.Vacia()) {
                  while (!p1.Vacia()) {
                        int d = p1.Tope();
                        p2.Poner(d);
                        p1.Quitar();
                  }
            }
            return p2.Tope();
      }

      bool Vacia() const {
            return p1.Vacia() && p2.Vacia();
      }

      void Poner (int d) {
            p1.Poner(d);
      }

      void Quitar () {
            if (p2.Vacia()) {
                  while (!p1.Vacia()) {
                        int d = p1.Tope();
                        p2.Poner(d);
                        p1.Quitar();
                  }
            }
            p2.Quitar();
      }
};
\end{minted}

\section{\textcolor[rgb]{0.2,0.5,0.5}Cola con prioridad}
\noindent
Contienen una secuencia de valores especialmente diseñadas para realizar accesos y borrados por el frente. Pero a diferencia de las colas normales, las inserciones se realizan en cualquier punto de acuerdo a un criterio de prioridad. Cada dato que se guarda en la cola es un struct compuesto por el dato y su prioridad.

\noindent
Sus operaciones típicas son:
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Frente}}: devuelve el elemento en el frente
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Prioridad}}: devuelve la prioridad del elemento en el frente
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Quitar}}: elimina el elemento que está en el frente
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Vacía}}: indica si la cola está vacía
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{Poner}}: inserta un nuevo elemento con su prioridad
\end{enumerate}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Representación con celdas enlazadas}
\begin{minted}[linenos]{c++}
template <class Tprio, class T>
struct info {
      Tprio prio;
      T elemento;
};

template <class Tprio, class T>
struct Celda {
      info<Tprio, T> dato;
      Celda<Tprio, T> *sig;
};

template <class Tprio, class T>
class ColaPrio {
private:
      Celda<Tprio, T> *primera;
      void Copiar (const ColaPrio<Tprio, T> &p);
      void Borrar ();

public:
      ColaPrio() {primera=0;}
      ColaPrio(const ColaPrio<Tprio, T> &c);
      ~ColaPrio();
      ColaPrio<Tprio, T> & operator=(const ColaPrio<Tprio, T> &cp);
      T Frente() const;
      Tprio Prioridad_Frente() const;
      void Poner(const Tprio &tp, const T &elemento);
      void Quitar ();
      void size() const;
      bool Vacia() const {primera==0;}
};
#include "ColaPrio.cpp"

/*La mayoria de operaciones son igual que en las colas de siempre, vamos a estudiar
las que se diferencian de las operaciones de las colas de siempre*/
\end{minted}

\begin{minted}[linenos]{c++}
//ColaPrio.cpp
template <class Tprio, class T>
T Cola_Prio<Tprio,T>::Frente()const{
      assert(primera!=0); //nos aseguramos de que la cola no esta vacia
      return primera->dato.elemento;
}

template <class Tprio, class T>
Tprio Cola_Prio<Tprio,T>::Prioridad_Frente() const {
      assert(primera!=0);
      return primera->dato.prior;
}

template <class Tprio, class T>
void Cola_Prio<Tprio,T>::Poner(const Tprio &tp, const T &e) {
      //Creamos una nueva celda para guardar los datos que tenemos
      Celda<Tprio,T> *aux = new Celda<Tprio, T>;
      aux->dato.elemento = e;
      aux->dato.prior = tp;

      //Primer caso: la cola esta vacia
      if (primera == 0) {
            primera = aux;
            primera->sig = 0;
      }

      //Segundo caso: la prioridad es mayor a la prioridad del frente
      else {
            if (primera->dato.prior < tp) {
                  aux->sig = primera;
                  primera = aux;
            }

            //Tercer caso: la celda se inserta en cualquier parte de la cola
            else {
                  Celda<Tprio,T> *p = primera;

                  //buscamos la celda en la que insertar la nuestra
                  while (p->sig->dato.prior > tp && p->sig!=0)
                        p=p->sig;

                  //Una vez la encontramos insertamos la nuestra ahi
                  aux->sig = p->sig;
                  p->sig=aux;
            }
      }
}

template <class Tprio, class T>
void Cola_Prio <Tprio,T>::Quitar() {
      assert(primera!=0);
      Celda<Tprio,T> *aux=primera;
      primera=primera->sig;
      delete aux;
}
\end{minted}

\section{\textcolor[rgb]{0.2,0.5,0.5}Lista}
\noindent
Es un tipo de dato lineal que contiene una secuencia de elementos $\{a_{0},a_{1},\cdots,a_{n-1}\}$. Está especialmente diseñado para realizar inserciones, borrados y consultas desde cualquier posición.

\noindent
Sus operaciones típicas son:
\begin{enumerate}[---]
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Set}} $\longrightarrow$ modifica el elemento en una posición
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Get}} $\longrightarrow$ devuelve el elemento en una posición
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Borrar}} $\longrightarrow$ borra un elemento de una determinada posición
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{Insertar}} $\longrightarrow$ inserta un elemento en una determinada posición
\item \textit{\textcolor[rgb]{0.2,0.5,0.5}{size}} $\longrightarrow$ devuelve cuántos elementos hay en la lista
\end{enumerate}

\noindent
Su interfaz es:
\begin{minted}[linenos]{c++}
#ifndef __LISTA_H
#define __LISTA_H

template <class T>
class Lista {
      private:
      //Implementacion elegida

      public:
            Lista();
            Lista(const Lista &l);
            ~Lista();
            Lista & operator=(const Lista<T> &l);
            T get (int posision)const;
            void set(int posicion, const T &e);
            int size() const;
            void Insertar (int posicion, const T &e);
            void Borrar (int posicion);
};
#endif
\end{minted}

\noindent
Si implementamos la clase Lista como un vector, tener la posición como int está bien, pero si elegimos celdas enlazadas, cada vez que accedamos a un elemento nos costará $O(n)$. En vez de eso, sería más interesante hacer que posición fuera un puntero al elemento a acceder, para ello, implementamos un T.D.A. Posición que nos permita acceder más rápidamente a esa posición.

\begin{minted}[linenos]{c++}
#ifndef __LISTA_H
#define __LISTA_H

template <class T>
class Posicion {
      private:
            T *i;

      public:
            Posicion(): i(0) {}

            Posicion<T> & operator++() {
                  i++;
                  return *this;
            }

            Posicion<T> & operator--() {
                  i--;
                  return *this;
            }

            T & operator* () {
                  return *i;
            }

            bool operator== (const Posicion<T> &p) {
                  return i==pi;
            }

            bool operator != (const Posicion<T> &p) {
                  return i != pi;
            }

            friend class Lista;
};

/*Esta representacion de la clase Lista solo es valida para listas
representadas con vectores pues los operadores ++ y -- no nos valdrian
para una lista con celdas enlazadas*/
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Implementación con vectores}
\begin{minted}[linenos]{c++}
template <class T>
class Lista {
      private:
            T *datos;
            int n;
            int reservados;
            void resize(int tam);
            void Copiar(const Lista<T> &l);

      public:
            Lista (int tam = 0);
            Lista (const Lista<T> &l);
            ~Lista();
            Lista<T> & operator= (const Lista<T> &l);
            T Get(Posicion<T> p) const {return *p.i;}
            void Set(Posicion<T> p, const T &e);
            int size() const;
            void Insertar(Posicion<T> p, const T &e);
            void Borrar(Posicion<T> p);
            Posicion begin() const; //devuelve una posicion al inicio de la lista
            Posicion end() const; //devuele una posicion al final de la lista
};
#endif
\end{minted}

\begin{minted}[linenos]{c++}
//Lista.cpp
template <class T>
void Lista::Set(Posicion<T> p, const T&e) {
      assert(p.i!=0);
      *p.i=e;
}

template <class T>
Posicion<T> Lista<T>::Insertar (Posicion<T> p, const T&e) {
      if (n == reservados/2)
            resize (2*reservados);

      Posicion<T> q = end(), aux;
      aux = q;
      --aux;

      for (;q != p; q--, aux--)
            *q = *aux;

      *q=e;
      n++;
      return q;
}

template <class T>
Posicion<T> Lista<T>::Borrar(Posicion<T> p) {
      Posicion<T> siguiente = p;
      siguiente++;

      for (Posicion<T> q = p; siguiente != end(); q++, siguiente++)
            *q = *siguiente;

      n--;

      if (n < (reservados/4))
            resize(reservados/2);

      return p;
}

Lista::Posicion Lista::begin()const {
      Posicion p;
      p.i = &(datos[0]);
      return p;
}


Lista::Posicion Lista::end()const {
      Posicion p;
      p.i=&(datos[n]);
      return p;
}
\end{minted}

\noindent
Así, si por ejemplo queremos mostrar los elementos de una lista, lo único que tendríamos que hacer sería:
\begin{minted}[linenos]{c++}
for (Posicion p=L.begin(); p!=L.end(); ++p)
      cout << *p;
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Implementación con celdas enlazadas}
\noindent
En este caso, la clase Posicion cambia un poco, ya que el operator ++ y -- no se pueden implementar de igual manera, en este caso en vez de con template lo haremos para una lista de caracteres:
\begin{minted}[linenos]{c++}
#ifndef __LISTA_H
#define __LISTA_H
typedef char Tbase

struct Celda {
      Tbase ele;
      Celda *sig;
}

class Posicion {
      private:
            Celda *punt;      //apunta a la posicion que le digamos
            Celda *primera;   //apunta a la primera celda de la lista, 
                              //lo necesitamos para el operator --

      Posicion & operator ++ () {
            punt = punt->sig;
            return *this;
      }

      Posicion & operator -- () {
            //Buscamos la anterior a nuestra celda con el
            //puntero primera
            Celda *aux = primera;

            while (aux != 0 && aux->sig != punt)
                  aux++;

            punt = aux;

            return *this;
      }

      Tbase & operator * () {
            return punt->ele;
      }

      //El resto de funciones no cambian

      friend class Lista;
};
\end{minted}

\noindent
Usando esta implementación de la clase Posicion, nuestra Lista con celdas enlazadas sería:
\begin{minted}[linenos]{c++}
//Lista.h
class Lista {
      private:
            Celda primera;
            void Copiar (const Lista &l);
            void Borrar_All();

      public:
            Lista() {primera = 0;}
            Lista(const Lista &l) {Copiar(l);}
            ~Lista(){Borrar_All();}
            Lista & operator=(const Lista &l);
            void Insertar(Posicion p, Tbase e);
            void Borrar(Posicion p);
            Tbase Get(Posicion p)const {return *p;}
            void Set(Posicion p, Tbase v) {(*p)=v;}
            int size()const;
            Posicion begin()const;
            Posicion end()const; 
};
#endif
\end{minted}


\begin{minted}[linenos, firstnumber=1]{c++}
//Lista.cpp
#include "Lista.h"

void Lista::Copiar(const Lista &l) {
      //Primer caso: lista vacia
      if (l.primera == 0)
            primera = 0;

      else {
            //Al menos hay una celda en la lista
            primera = new Celda;
            primera->ele = l.primera->ele;

            Celda *p = primera, *q = l.primera->sig;

            while (q != 0) {
                  p->sig = new Celda;
                  p = p->sig;
                  p->ele = q->ele;
                  q = q->sig;
            }
            p->sig=0;
      }
}

void Lista::Borrar_All() {
      while (primera != 0) {
            Celda *aux = primera;
            primera = primera->sig;
            delete aux;
      }
}

Lista & Lista::operator=(const Lista &l) {
      if (this != &l) {
            Borrar_All();
            Copiar(l);
      }
      return *this;
}

void Lista::Insertar(Posicion p, Tbase e) {
      Celda *aux = new Celda;
      aux->ele=e;
      if (p==begin()) {
            aux->sig=primera;
            primera=aux;
      }

      else {
            Posicion q=p;
            --q;
            aux->sig=p.punt;
            q.punt->sig=aux;
      }
}

void Lista::Borrar(Posicion p) {
      if (p==begin()) {
            primera = p.punt->sig;
            delete p.punt;
      }

      else {
            Posicion q = p;
            --q;
            q.punt->sig = p.punt->sig;
            delete p.punt;
      }
}

int Lista::Size()const {
      int contador=0;
      Celda *aux=primera;

      while (aux!=0) {
            contador++;
            aux=aux->sig;
      }

      return contador;
}

Posicion Lista::begin()const {
      Posicion p;
      p.punt=primera;
      p.primera=primera;
      return p;
}

Posicion Lista::end()const {
      Posicion p;
      p.punt=0;
      p.primera=primera;
      return p;
}
\end{minted}

\noindent
Con esta representación tenemos varios problemas:
\begin{enumerate}[---]
\item Tenemos dos punteros para representar una posición
\item Gasto en eficiencia del operator - - de Posición, $O(n)$
\end{enumerate}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Implementación con celdas enlazadas con cabecera}
\noindent
La cabecera es una celda vacía que se coloca al principio de la lista, la función begin() nos devuelve un puntero a esta Celda y la clase Posicion siempre apunta al valor anterior al que tenemos. Su implementación sería:
\begin{minted}[linenos]{c++}
//Lista.h
#ifndef __LISTA_H
#define __LISTA_H

typedef char Tbase;
struct Celda
{
      Tbase ele;
      Celda *sig;
};

class Lista
{
      Class Posicion
      {
      private:
            Celda *punt;
            Celda *primera;

      public:
            Posicion(): punt(0), primera(0) {}
            bool operator== (const Posicion &op) {
                  return punt==op.punt;
            }
            bool operator!= (const Posicion &op) {
                  return punt!=op.punt;
            }
            Posicion & operator++(){
                  assert(punt!=0);
                  punt=punt->sig;
                  return *this;
            }
            Posicion & operator--(){
                  if (primera==punt)
                        punt=0;

                  else
                  {
                        Celda *q = primera;
                        while (q->sig!=punt)
                              q=q->sig;
                        punt=q;
                        return *this;
                  }
            }
            Tbase & operator*() {
                  return punt->sig->ele;
            }
            friend class Lista;
      };

private:
      Celda *cab;
      void Copiar (const Lista &l);
      void Borrar_All();

public:
      Lista();
      Lista(const Lista &l);
      ~Lista();
      Lista & operator=(const Lista &l);
      void Insertar (Posicion p, Tbase v);
      void Borrar (Posicion p);
      Tbase Get(Posicion p)const;
      void Set(Posicion p, Tbase v);
      int size()const;
      Posicion begin()const;
      Posicion end()const;
};

#endif
\end{minted}

\begin{minted}[linenos]{c++}
//Lista.cpp
void Lista::Copiar(const Lista &l)
{
      if (l.cab->sig==0)
      {
            cab=new Celda;
            cab->sig=0;
      }

      else
      {
            cab = new Celda;
            Celda *p=cab, *q=l.cab;
            while (q->sig != 0)
            {
                  p->sig=new Celda;
                  p->sig->ele = q->sig->ele;
                  p=p->sig;
                  q=q->sig;
            }
            p->sig=0;
      }
}

void Lista::Borrar_All()
{
      while (cab->sig!=0)
      {
            Celda *aux=cab->sig;
            cab->sig = cab->sig->sig;
            delete aux;
      }
      delete cab;
}

Lista::Lista()
{
      cab=new Celda;
      cab->sig=0;
}

Lista::Lista(const Lista &l)
{
      Copiar(l);
}

Lista::~Lista()
{
      Borrar_All();
}

Lista & Lista::operator=(const Lista &l)
{
      if (this != &l)
      {
            Borrar_All();
            Copiar(l);
      }

      return *this;
}

void Lista::Insertar(Posicion p, Tbase v)
{
      Celda *aux=p.punt->sig;
      p.punt->sig=new Celda;
      p.punt->sig->ele=v;
      p.punt->sig->sig=aux;
}

void Lista::Borrar(Posicion p)
{
      assert(p.punt->sig != 0);
      Celda *aux = p.punt->sig;
      p.punt->sig=p.punt->sig->sig;
      delete aux;
}

Posicion Lista::begin()const
{
      Posicion p;
      p.punt=cab;
      p.primera=primera;
      return p;
}

Posicion Lista::end()const
{
      Posicion p;
      Celda *aux = cab;
      while (aux->sig!=0)
            aux=aux->sig;

      p.punt=aux;
      p.primera=cab;
      return p;
}
\end{minted}

\noindent
Seguimos teniendo dos punteros para representar una posición, ya que lo seguimos necesitando para hacer el --, aunque ahora p apunte a la anterior. Además, la posición se no se refiere al nodo sino al siguiente. Otra representación alternativa para la lista sería:

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Implementación con celdas doblemente enlazadas}
\noindent
En esta representación, las celdas tienen dos punteros: uno que apunta a la celda anterior y otro que apunta a la celda siguiente. Lo que cambia en su implementación es:

\begin{minted}[linenos]{c++}
struct Celda
{
    char d;
    Celda *sig;
    Celda *ant;
};

void Lista::Insertar(Posicion p, char e)
{
    Celda *aux=new Celda;
    aux->d = e;

    if (p==begin())
    {
        aux->sig = primera;
        if(primera!=0)
        {
            aux->ant=0;
            primera=aux;
        }
    }

    else
    {
        aux->sig=p.punt;
        Posicion q=p;
        --q;
        q.punt->sig=aux;
        aux->ant=q.punt;
        if (p.punt != 0)
            p.punt->ant=aux;
    }
}

void Lista::Borrar(Posicion p)
{
    Celda *aux=p.punt;
    if (p==begin())
    {
        primera=primera->sig;
        if (primera!=0)
            primera->ant=0;

        delete aux;
    }

    else
    {
        p.punt->ant->sig=p.punt->sig;
        if (p.punt->sig!=0)
            p.punt->sig->ant=p.punt->ant;

        delete aux;
    }
}
\end{minted}

\noindent
El problema es que seguimos necesitando representar la Posicion con dos punteros y que hay un sólo caso en el que el operator -- nos costaría O(n): la función end(). Esta función nos devuelve cero y... cuál es la posición anterior a cero? Para saberlo necesitamos recorrer toda la lista hasta que punt$\rightarrow$sig == 0. Por lo que esta implementación tampoco resuelve nuestro problema.

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Listas circulares}
\noindent
En esta implementación el principio y el final coinciden, pero seguimos sin saber cuál es la celda anterior, por lo que tampoco resuelve nuestros problemas del todo.

\noindent
La solución más óptima, es juntar todo esto que hemos visto en una sola representación: listas con celdas doblemente enlazadas y circulares con cabecera.

\section{\textcolor[rgb]{0.2,0.5,0.5}Abstracción por iteración}
\noindent
Los \textit{\textcolor[rgb]{0.2,0.5,0.5}{contenedores}} son estructuras de datos que contienen almacenados una colección de elementos de un determinado tipo. Los contenedores que hemos visto son:
\begin{enumerate}[$\rightarrow$]
\item Vectores dinámicos
\item Pilas
\item Colas
\item Colas con prioridad
\item Listas
\end{enumerate}

\noindent
Para acceder a los datos de un contenedor de manera genérica tenemos dos opciones: o bien con el TDA Posición (que es una introducción a los iteradores), o bien los \textit{\textcolor[rgb]{0.2,0.5,0.5}{iteradores}}.

\noindent
Los iteradores son un TDA que abstrae la idea de acceder a los elementos de un contenedor de una forma parecida a la forma de actuar de los punteros. Los pasos a seguir para trabajar con iteradores son:
\begin{enumerate}[1.]
\item Iniciar el iterador a la primera posición del contenedor (función begin()).
\item Acceder al elemento que apunta (*it, donde it es de tipo iterador)
\item Avanzar el iterador al siguiente elemento del contenedor (++it)
\item Saber cuando hemos recorrido todos los elementos del contenedor (función end()).
\end{enumerate}

\noindent
Ahora nuestra clase posición estará dentro de la clase y se llamará iterator. La estructura general sería:

\begin{minted}[linenos]{c++}
class Lista {
private:
      ...
public:
      ...
      class iterator {
            ...
      }

      iterator begin() {
            ...
      }

      iterator end() {
            ...
      }
}
\end{minted}

\noindent
Así, en el main podríamos trabajar de la siguiente manera:

\begin{minted}[linenos]{c++}
Lista l;                //creamos nuestra lista
...                     //ejecutamos mas instrucciones
Lista::iterator it;     //Creamos nuestro iterador
//Recorremos la lista
for (it=l.begin();i!=l.end();++it)
      cout << *it;
\end{minted}

\section{\textcolor[rgb]{0.2,0.5,0.5}Listas con celdas doblemente enlazadas y circulares con cabecera}
\noindent
Es la representación que usa la STL. La función end devuelve la celda cabecera y la begin, la siguiente. Su implementación sería:

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Implementación}
\begin{minted}[linenos]{c++}
//Lista.h

struct Celda {
      char d;
      Celda *sig, *ant;
};

class Lista {
private:
      Celda *primera; //cabecera

public:
      Lista () {primera=0;};
      Lista (const Lista &l);
      ~Lista ();
      Lista & operator= (const Lista &l);

      class const_iterator;   //debemos pre-definir esta clase para
                              //avisar a iterator de su existencia
      class iterator {
      private:
            Celda *punt;

      public:
            iterator (): punt(0) {}
            iterator & operator++ () {
                  punt=punt->sig;
                  return *this;
            }
            iterator & operator-- () {
                  punt=punt->ant;
                  return *this;
            }
            char & operator* () {return punt->d;}
            bool operator== (const iterator &i) const {
                  return punt==i.punt;
            }
            bool operator!= (const iterator &i) const {
                  return punt!=i.punt;
            }
            friend class Lista;
            friend class const_iterator;
      };

      class const_iterator {
      private:
            Celda *punt;

      public:
            const_iterator(): punt(0) {}
            //podemos construir const_iterator a partir de
            //iteradores no constantes
            const_iterator (const iterator &i) {
                  punt = i.punt;
            }
            bool operator== (const const_iterator &i) {
                  return punt!=i.punt;
            }
            bool operator!= (const const_iterator &i) {
                  return punt != i.punt;
            }
            const char & operator* () {
                  return punt->d;
            }
            const_iterator & operator++ () {
                  punt = punt->sig;
                  return *this;
            }
            const_iterator & operator-- () {
                  punt = punt->ant;
                  return *this;
            }
            friend class Lista;
      };

      void Set (iterator it, char v) {
            (*it) = v;
      }
      char Get (iterator it) const {
            return *it;
      }
      void Insertar (iterator it, char e);
      void Borrar (iterator it);
      iterator begin() const {
            iterator it;
            it.punt = primera->sig; //devolvemos la siguiente
            return it;              //a la cabecera
      }
      iterator end() const {
            iterator it;
            it.punt = primera; //devolvemos la cabecera
            return it;
      }
};
\end{minted}

\begin{minted}[linenos, firstnumber=96]{c++}
//Lista.cpp
void Lista::Insertar (iterator it, char e) {
      //it apunta a la celda donde queremos insertar la nuestra
      Celda *aux = new Celda;       //Cremos una nueva celda
      aux->d = e;                   //Le insertamos el valor
      aux->sig = it.punt;           //La siguiente a la nuestra es
                                    //la que ocupa la posicion que vamos a insertar
      aux->ant = it.punt->ant;      //la anterior, la anterior de it
      it.punt->ant->sig = aux;      //y la siguiente de la anterior, la nuestra
      it.punt->ant = aux;           //y la siguiente a la nuestra, it
                                    //es la anterior a it.
}

void Lista::Borrar (iterator it) {
      it.punt->ant->sig = it.punt->sig;   //La siguiente de la anterior es 
                                          //la siguiente de la que queremos borrar
      it.punt->sig->ant = it.punt->ant;   //El anterior de la siguiente es
                                          //la anterior de la que queremos borrar
      delete it.punt;
}
\end{minted}

\noindent
¿Por qué definimos dos iterators? Porque debemos tener uno para tratar con listas constantes y otro para tratar con listas no constantes, ya que por ejemplo, en el siguiente código nos devolvería un error:
\begin{minted}[linenos]{c++}
#lista "lista.h"
void Imprimir (const Lista &l) {
      Lista::iterator it;
      for (it=l.begin();it!=l.end();++it)
            cout << *it;
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Ejemplos de funciones para nuestra lista}
\noindent
Con nuestra lista ya definida podriamos definir funciones template para hacer algunas cosas con ellas. Por ejemplo:

\noindent
Función template para imprimir listas de cualquier tipo \label{typename}
\begin{minted}[linenos]{c++}
//principal.cpp
#include "Lista.h"
#include <iostream>
using namespace std;

template <class T>
void Imprimir(const Lista<T> &l) {
    /*Lista<T>::const_iterator it; nos daria error
    de compilacion porque el compilador piensa que 
    es una definicion estatica dentro de lista. Para
    evitar este error, definimos nuestro iterador con
    typename*/

    typename Lista<T>::const_iterator it;

    for (it=l.begin();it!=l.end();++it)
        cout << *it;
}
\end{minted}

\noindent
También podemos definir una función para imprimir los elementos de nuestra lista al revés
\begin{minted}[linenos, firstnumber=19]{c++}
//Seguimos en principal.cpp
template <class T>
void Imprimir_invertido (const Lista<T> &l) {
    typename Lista<T>::const_iterator it=l.end();
    --it; //pasamos de la cabecera a la ultima celda
    for (;it!=l.end();--it)
        cout << *p;
}
\end{minted}

\noindent
Podemos definir una función que elimine los pares de una lista de enteros
\begin{minted}[linenos, firstnumber=27]{c++}
//Principal.cpp
template <class T>
void EliminaPares (Lista<int> &l)
{
    Lista<int>::iterator it;
    //Aqui no hace falta typename porque ya tenemos la lista definida
    it=l.begin();

    while (it!=l.end()) {
        if ((*it)%2==0)
            it=l.Borrar(it); //La funcion borrar nos devuelve un iterador
                             //Para no perder el iterador tras borrar el elemento

        else
            ++it;
    }
}
\end{minted}

\noindent
Y podemos definir también una función que nos de información sobre cualquier contenedor
\begin{minted}[linenos, firstnumber=44]{c++}
template <class InputIterator>
void ImprimirContenedor (const InputIterator &first, const InputIterator &last) {
    InputIterator it;
    for (it=first;it!=last;++it)
        cout << *it;
}
\end{minted}

\noindent
Podríamos usar nuestra Lista en la función main de la siguiente forma:
\begin{minted}[linenos, firstnumber=50]{c++}
//Principal.cpp

int main() {
    Lista<int> l;

    for (int i=0; i<10; i++)
        l.Insertar(l.end(),i);

    Imprimir(l);
    Imprimir_invertido(l);
    ImprimirContenedor(l.begin(),l.end());

    vector<char> mivector;

    for (char c='a';c!='z';c++)
        mivector.push_back(c);

    ImprimirContenedor(mivector.begin(),mivector.end());
    //Usamos la misma funcion para lista y vector

    return 0;
}
\end{minted}

\section{\textcolor[rgb]{0.2,0.5,0.5}Standard template library (STL)}
\noindent
Las estructuras de datos lineales que hemos estudiado están implementadas en la STL como:


\begin{tabular}{p{5cm} | p{4cm}}
\textbf{Clase} & \textbf{Librería} \\
\hline
vector & \#include$<$vector$>$ \\
list & \#include$<$list$>$ \\
queque / priority.queue & \#include$<$queue$>$ \\
stack & \#include$<$stack$>$ \\
\end{tabular}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Listas}
\begin{minted}[linenos]{c++}
#include <iostream>
#include <list>
using namespace std;

int main()
{
    list<int> milista;
    for (int i=1; i<=5; i++)
        milista.push_back(i); //insertamos elementos al final de la lista

    list<int>::reverse_iterator rit; //para recorrer la lista al reves
    
    for (rit=milista.rbegin();rit!=milista.rend();++rit)
        cout << *rit << " ";

    //Las funciones rbegin y rend son especificas para reverse iterator,
    //devuelven rbegin el final de la lista y rend el principio.

    //Tras el for tendriamos la siguiente salida: 5 4 3 2 1

    list<int> iterator r;

    for (ri=milista.begin(); ri!=milista.end(); ++ri)
        cout << *ri << " ";

    //Tras el for tendriamos la siguiente salida: 1 2 3 4 5

    cout << "El tamanio de mi lista es " << milista.size();

    //La funcion size devuelve el tamanio de una lista

    int sum=0;

    while (!milista.empty()) {
        sum+=milista.front();   //devuelve el inicio de la lista
        milista.pop_front();    //elimina el primer elemento de la lista
    }

    //Alternativamente, podriamos haber usado los metodos back para
    //obtener el final de la lista y pop_back para borrarlo.
}
\end{minted}

\noindent
Las funciones vistas hasta ahora son:
\begin{enumerate}[$\heartsuit$]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{push\_back(i)}}: añade el elemento i al final de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{reverse\_iterator}}: un objeto de la clase reverse\_iterator recorre la lista de final a principio.
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{rbegin()}}: método que devuelve un objeto reverse\_iterator que apunta al final de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{rend()}}: método que devuelve un objeto de reverse\_iterator que apunta al inicio de la lista.
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{size()}}: devuelve número de nodos de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{empty()}}: nos dice si la lista está vacía
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{front()}}: nos devuelve el primer nodo de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{back()}}: nos devuelve el último nodo de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{pop\_front()}}: borra el primer elemento de la lista
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{pop\_back()}}: borra el último elemento de la lista.
\end{enumerate}

\noindent
Ahora vamos a ver una función nueva: \textbf{\textcolor[rgb]{0.2,0.5,0.5}{erase}}.

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Erase}
\noindent
Tiene dos versiones:

\begin{enumerate}[$\longrightarrow$]
\item iterator erase (iterator posicion): borra un elemento con su posición
\item iterator erase (iterator first, iterator end): elimina todos los elementos desde first hasta end, end no incluido
\end{enumerate}

\noindent
Un ejemplo de MAL uso de esta función sería:
\begin{minted}[linenos]{c++}
void ErasePares (list<int> &l) {
    list<int>::iterator it;

    for (it=l.begin();it!=l.end();++it)
        if ((*it)%2==0)
            l.erase(it);
}
\end{minted}

\noindent
Al hacer un erase del primer elemento, perderíamos it y por tanto, podríamos estar borrando cualquier cosa menos los elementos pares de la lista. Lo correcto sería:

\begin{minted}[linenos]{c++}
void ErasePares (list<int> &l) {
    list<int>::iterator it;
    it=l.begin();
    while (it!=l.end()) {
        if ((*it)%2==0)
            it = l.erase(it);

        else
            ++it;
    }
}
\end{minted}

\noindent
Otro ejemplo de uso de la clase Lista sería:

\begin{minted}[linenos]{c++}
#include <iostream>
#include <list>
using namespace std;

int main() {
    int mienteros[] = {13,12,10,20};
    lista<int> milista;
    milista.assign(mienteros, mienteros+4); 

    //ahora mi lista tiene los valores 13 12 10 20
    //otra forma de inicializarla seria milista.assign(7,100);
    //y tendria 7 elementos iguales (100).

    list<int> otralista;

    otralista.assign(milista.begin(), milista.end());
    //otralista tiene los mismos elementos que milista

    list<int> l3;

    list<int>::iterator it;

    for (it=otralista.begin();it!=otralista.end();++it)
        l3.push_back(*it); //l3 tiene los mismos elementos que otralista y que milista

    it=l3.begin();
    ++it;       //it apunta al segundo elemento de l3, 12

    l3.insert(it,2,30); //ahora l3 tiene 13 30 30 12 10 20
                        //it sigue apuntando a 12

    l3.insert(it,4); //ahora l3 tiene 13 30 30 4 12 10 20
                    // it apunta al 4 ahora

    vector<int> v;

    v.assign(l3.begin(),l3.end()); //v = 13 30 30 4 12 10 20

    it = milista.begin();

    milista.insert(it,v.begin(),v.end()); //milista = 13 30 30 4 12 20 13 12 10 20

    milista.swap(l3); //intercambiamos el contenido de ambas

    l3.clear(); //limpiamos l3
}
\end{minted}

\noindent
Las funciones vistas en este ejemplo son:
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{assign}}: según los parámetros, asigna a la lista unos valores u otros:
\begin{enumerate}[---]
\item Dos parámetros: el inicio y el final de una serie de elementos $\rightarrow$ asigna a la lista los valores de ese rango.
\item Dos parámetros: dos enteros $\rightarrow$ asigna a la lista el segundo parámetro tantas veces como diga el primer parámetro.
\end{enumerate}
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{insert}}: según los parámetros funciona de una manera u otra:
\begin{enumerate}[---]
\item tres parametros: una posicion y dos enteros: inserta en it el segundo entero tantas veces como sea el primer entero. it sigue apuntando al valor que apuntaba antes de la inserción
\item dos parametros: una posicion y un entero: inserta en it el entero e it pasa a apuntar a ese entero
\item tres parametros: tres posiciones: inserta en la primera posicion todos los elementos desde la segunda hasta la tercera posicion
\end{enumerate}
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{swap}}: intercambia dos listas.
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{clear}}: deja la lista que llama a este método vacía
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Splice}
\noindent
Mueve los elementos de una lista a otra. Según sus parámetros puede ser:
\begin{enumerate}[---]
\item Dos parámetros: un iterador y una lista: a partir del iterador coge todos los elementos de la lista que llama al método splice y los mueve a la lista del segundo parámetro
\item Tres parámetros: una posición (iterador), una lista y un iterador: de todos los elementos de la lista del segundo parámetro, coge el elemento que apunta it y copialo en la posición del primer parámetro de la lista que llama al método. Después de esto el iterador se invalida (pierde su valor).
\item Cuatro parámetros: una posición, una lista, un iterador y otra posición: mueve a la posición del primer parámetros los elementos de la lista del segundo parámetro que van desde el iterador a la posición del último parámetro.
\end{enumerate}

\begin{minted}[linenos]{c++}
#include <iostream>
#include <list>
using namespace std;

int main () {
    list<int> l1, l2;
    list<int>::iterator it;

    for (int i=1;i<=4;i++)
        l1.push_back(i);    //l1 =  1 2 3 4

    for (int i=1;i<=3;i++)
        l2.push_back(i*10);     //l2 = 10 20 30

    it = l1.begin();
    ++it;

    l1.splice(it,l2);   //a partir de it, coge todos los elementos de
                        //l2 y los pone en l1:
                        //l1 = 1 10 20 30 2 3 4 (it apunta a 2)
                        //l2 = (vacia)

    l2.splice(l2.begin(), l1, it); //de los elementos de l1 coge el elemento it
                                   //l1 = 1 10 20 30 3 4
                                   //l2 = 2
                                   //el iterador se invalida

    it=l1.begin();

    advance(it,3); //avanza el iterador en tres posiciones *it=30

    l1.splice(l1.begin(),l1,it,l1.end()); //l1 = 30 3 4 1 10 20
} 
\end{minted}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Remove}
\noindent
void remove (const value \&val) $\longrightarrow$ Elimina de una lista  todos los elementos con valor val.

\begin{minted}[linenos]{c++}
int mienteros[] = {3,4,79,15};
list<int> l (mienteros,mienteros+4); //l = {3,4,79,15}
l.remove(79); //l = 3 4 15
\end{minted}

\noindent
Si queremos ejecutar remove sobre objetos que hemos creado debemos sobrecargar el operator== en la clase. Por ejemplo, para hacer l.remove(P) (donde P es un objeto de tipo Palabra), debemos sobrecargar el operator== en la clase Palabra.

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Remove\_if}
\noindent
Elimina los elementos que cumplan una determinada condición. Por ejemplo, para eliminar números pares, definimos lo que significa ser número Par y después llamamos a Remove\_if:
\begin{minted}[linenos]{c++}
bool Par (int v) {
    return (v%2==0);
}

int main () {
    list<int> l;
    for (int i=1;i<10;i++)
        l.push_back(i);

    l.remove_if(Par)
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Unique}
\noindent
Elimina valores duplicados que se encuentran consecutivamente, dejando una única ocurrencia.
\begin{displaymath}
\{1,1,2,2,3,4,4\} \longrightarrow \{1,2,3,4\}
\end{displaymath}

\noindent
Tenemos distintas formas de usar la función:
\begin{enumerate}[---]
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{unique()}}: establece la igualdad con lo que esté predefinido en el operator==
\item \textbf{\textcolor[rgb]{0.2,0.5,0.5}{unique(funcion)}}: establece la igualdad según la hayamos definido en funcion.
\end{enumerate}

\begin{minted}[linenos]{c++}
#include <list>
using namespace std;

bool iguales_enteros (double v1, double v2) {
      return (int)v1 == (int)v2;
}

int main() {
      double m[] = {12.15, 2.72, 73.0, 12.77, 3.14, 12.77, 73.55, 72.25, 15.3, 72.25};
      list<double> l1(m,m+10);
      l1.sort(); // l1 = 2.72 3.14 12.15 12.77 12.77 15.3 72.25 72.25 73.0 73.35
      l1.unique(); // l1 = 2.72 3.14 12.15 12.77 15.3 72.25 73.0 73.35
      l1.unique(iguales_enteros); // l1 = 2.72 3.14 12.15 15.3 72.25 73.0
}
\end{minted}
Con respecto a sort, que ordena los elementos, podemos pasarle una función que teniendo dos parámetros del tipo
base de la lista devuelve un booleano indicando si se cumple o no una propiedad entre los dos parámetros de entrada.

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Merge}
\noindent
Mezcla dos listas ordenadas. Si no le pasamos ningún argumento, usa el operator $<$ predefinido para saber quién es menor, pero podemos pasarle una función en la que hayamos lo hayamos definido nosotros.

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Reverse}
\noindent
Invierte la lista

\begin{minted}[linenos]{c++}
#include <list>
using namespace std;

bool miComparacion (double v1, double v2)
{
      return (int)v1 < (int)v2;
}

int main()
{
      list<double> l1, l2;

      l1.push_back(3.1);
      l1.push_back(2.2);
      l1.push_back(2.9);

      l2.push_back(3.7);
      l2.push_back(7.1);
      l2.push_back(1.4);

      l1.sort(); // l1 = 2.2 2.9 3.1
      l2.sort(); // l2 = 1.4 3.7 7.1
      l1.merge(l2); // l2 queda vacia y l1 = 1.4 2.2 2.9 3.1 3.7 7.1

      l2.push_back(2.1); // l2 = 2.1

      l1.merge(l2,micomparacion); // l1 = 1.4 2.2 2.9 2.1 3.1 3.7 7.1
      // Como solo comparamos el valor entero, inserta el 2.1 
      // despues del 2.9, porque ambos son iguales
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Pair: par de valores}
\noindent
Es una estructura muy utilizada sobre todo cuando queremos representar datos que van en pares de valores diferentes. Su estructura es la siguiente:

\begin{minted}[linenos]{c++}
template <class T1, class T2>
struct pair {
      typedef T1 first_type; //alias de T1
      typedef T2 second_type; //alias de T2

      T1 first;
      T2 second;

      pair(): fist(T1()), second(T2()) {}
      pair (const T1 &x, const T2 &y): first(x), second(y) {}
      template <class u, class v>
      pair (const pair<u,v> &p): first(p.first), second(p.second);
};
\end{minted}

\noindent
El hecho de que el constructor de copia sea un template de otro tipo nos da la posibilidad de construir un objeto pair de un tipo a partir de otro con otro tipo distinto pero que sea compatible. Por ejemplo int y double:

\begin{minted}[linenos]{c++}
pair <double, double> pair_1 (5.3, 7.2);
pair <int, int> p2 (pair_1);
\end{minted}

\noindent
Un ejemplo de uso de pair sería:
\begin{minted}[linenos]{c++}
#include <vector>
#include <iostream>
#include <utility> //permite hacer comparaciones de tipos pair
#include <string>

using namespace std;

int main() {
      pair <string, double> product1 ("tomates",3.25);
      pair <string, double> product2;
      pair <string, double> product3;

      product2.first="naranjas";
      product2.second=1.3;
      product3=make_pair("ciruelas", 2.2);

      vector < pair<string, double> > miv = {product1,product2,product3};

      for (int i=0; i<miv.size(); i++)
            cout << "Product " << i << ':' << miv[i].first
                  << " Precio: " << miv[i].second << endl;

      //version con iteradores
      vector < pair<string, double> >::iterator it;

      for (it=miv.begin();it!=miv.end();++it)
            cout << (*it).first << ' ' << (*it).second;
            //tambien valdria:
            //cout << it->first << ' ' << it->second;
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Pilas y colas}
\noindent
Las funciones típicas de las pilas y las colas en la stl son:
\begin{enumerate}[$\longrightarrow$]
\item size
\item empty
\item top
\item pop
\item push
\end{enumerate}

\noindent
Como ejemplo vamos a implementar una cola con una pila:
\begin{minted}[linenos]{c++}
#include <stack>
using namespace std;

template <class T>
class Cola {
private:
      stack<T> datos;

public:
      T front() {
            stack<T> aux;
            T v;
            while (!datos.empty()) {
                  v=datos.top();
                  aux.push(v);
                  datos.pop();
            }

            aux.pop();
            while (!aux.empty()) {
                  T s = aux.top();
                  datos.push(s);
                  aux.pop();
            }

            return v;
      }

      bool empty () const {
            return datos.empty();
      }

      int size () const {
            return datos.size();
      }

      void push (const T &v) {
            datos.push(v);
      }

      void pop() {
            stack<T> aux;
            while (!datos.empty()) {
                  v=datos.top();
                  aux.push(v);
                  datos.pop();
            }

            aux.pop();
            while (!aux.empty()) {
                  T s = aux.top();
                  datos.push(s);
                  aux.pop();
            }
      }
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Colas con prioridad}
\noindent
Vamos a ver un ejemplo de uso:

\begin{minted}[linenos]{c++}
#include <iostream>
#include <queue> //incluye tanto cola como cola de prioridad

using namespace std;

int main(){
      priority_queue<int> mypq;

      mypq.push(30);
      mypq.push(100);
      mypq.push(25);
      mypq.push(40);

      while (!mypq.empty()) {
            cout << mypq.top() << ' ';
            mypq.pop();
      }
}
\end{minted}

\noindent
La salida del programa será:
\begin{displaymath}
100 \quad\ 40 \quad\ 30 \quad\ 25
\end{displaymath}
ya que la salida se basa en la prioridad, es decir, en qué número es mayor. Si definimos la prioridad en un objeto nuestro, debemos definir el operator$>$ para saber qué objeto tiene más prioridad.

\section{\textcolor[rgb]{0.2,0.5,0.5}Contenedores asociativos}
\subsection{\textcolor[rgb]{0.2,0.5,0.5}Set/multiset}
\noindent
La clase \textit{\textcolor[rgb]{0.2,0.5,0.5}{set}} representa un conjunto de elementos que se disponen de manera ordenada y en el que no se repiten elementos. Los datos que insertamos en el set se llaman \textit{\textcolor[rgb]{0.2,0.5,0.5}{claves}}. La clase \textit{\textcolor[rgb]{0.2,0.5,0.5}{multiset}} es lo mismo pero que permite incluir elementos repetidos en el conjunto. Las funciones más destacadas son:

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Count}
\noindent
Devuelve el número de elementos que son iguales a un valor de entrada. Si lo ejecutamos con un set como mucho obtendremos un 1, pero si lo ejecutamos con un objeto multiset, podemos obtener cualquier valor mayor que cero.
\begin{minted}[linenos]{c++}
#include <iostream>
#include <set>

using namespace std;

int main()
{
      set<int> micnj; //Para un multiset seria: multiset<int> micnj;

      for (int i=1; i<5; i++)
            micnj.insert(i*3); //micnj = 3 6 9 12

      for (int i=0;i<10;i++) {
            if (micnj.count(i)!=0)
                  cout << "Esta en el conjunto";

            else
                  cout << "no esta";
      }
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Swap}
\noindent
Intercambia dos conjuntos.
\begin{minted}[linenos]{c++}
#include <iostream>
#include <set>

using namespace std;

int main()
{
      int myv[] = {12,75,10,32,20,25};

      set<int> s1(myv,myv+3); //s1 = 10 12 75
      set<int> s2(myv+3,myv+6); //s2 = 20 25 32

      s1.swap(s2); //s1 = 20 25 32 y s2 = 20 12 75
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Find}
\noindent
Busca en el conjunto un elemento y devuelve un iterador a el elemento. Si no lo encuentra, devuelve un iterador a end().

\begin{minted}[linenos]{c++}
#include <iostream>
#include <set>

using namespace std;

int main() {
      set<int> micnj;

      for (int i=1;i<5;i++)
            micnj.insert(i*3);

      set<int>::iterator it=micnj.find(9);

      micnj.erase(it); //micnj = 3 6 12
      //tambien valdria: micnj.erase(micnj.find(9));

      //imprimimos por pantalla todos los elementos del conjunto
      for (it=micnj.begin();it!=micnj.end();++it)
            cout << *it;
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Equal\_range}
\noindent
Su cabecera es:
\begin{minted}{c++}
      pair<iterator,iterator> equal_range (const value_type &val)const;
\end{minted}

\noindent
El primer iterador apunta al primer elemento del conjunto que coincida con val y el segundo, al primer elemento del conjunto distinto de val. Por ejemplo, si hacemos un equal\_range del siguiente multiset:
\begin{displaymath}
3 \quad\ 6 \quad\ 6 \quad\ 9
\end{displaymath}
El primer iterador apuntaría al 6 que va después del 3 y, el segundo, al 9. Si lo ejecutamos sobre un set, el primer iterador estará en una posición y el segundo, en la siguiente, ya que no puede haber elementos repetidos.

\begin{minted}[linenos]{c++}
#include <iostream>
#include <set>

using namespace std;

int main() {
      set<int> micnj;

      for (int i=1;i<5;i++)
            micnj.insert(i*10); //micnj = 10 20 30 40 50

      pair<set<int>::const_iterator,set<int>::const_iterator> ret;

      ret = micnj.equal_range(30);

      cout << "Limite inferior " << (*ret).first << endl; // 30
      cout << "Limite superior " << (*ret).second << endl; //40
}
\end{minted}

\noindent
Alternativa a equal\_range:

\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Lower\_bound y upper\_bound}
\noindent
\textit{\textcolor[rgb]{0.2,0.5,0.5}{lower\_bound}} devuelve un iterador al primer elemento que coincide con el elemento de entrada, si no existe devuelve un iterador al valor menor más próximo. Y \textit{\textcolor[rgb]{0.2,0.5,0.5}{upper\_bound}} devuelve un iterador al primer elemento mayor al valor de entrada, si no existe devuelve un iterador al mayor más próximo.
\begin{minted}[linenos]{c++}
#include <iostream>
#include <set>

using namespace std;

int main() {
      set<int> micnj;

      for (int i=1;i<5;i++)
            micnj.insert(i*10);

      set<int>::iterator itlow, itup;

      itlow = micnj.lower_bound(30);
      itup = micnj.upper_bound(60);

      micnj.erase(itlow,itup); //si le pasamos solo itlow borra el elemento 
                              //al que apunta itlow solo.
}
\end{minted}
\subsubsection{\textcolor[rgb]{0.2,0.5,0.5}Value\_comp}
\noindent
Devuelve un objeto comparador de set. El objeto se puede usar para comparar dos elementos del conjunto de manera que al comparar, el objeto comparador devuelve true si el primer objeto es menor que el segundo. Por ejemplo, vamos a hacer una función que nos diga cuántos elementos menores a $x$ hay en el conjunto $s$:
\begin{minted}[linenos]{c++}
int menores (const set<int> &s, int x) {
      set<int>::value_compare micomp = s.value_comp();
      set<int>::const_iterator it = s.begin();
      int cnt = 0;

      while (micomp(*it,x)) {
            cnt++;
            ++it;
      }
}
\end{minted}

\subsection{\textcolor[rgb]{0.2,0.5,0.5}Map/multimap}
\noindent
Un \textit{\textcolor[rgb]{0.2,0.5,0.5}{map}} está formado por parejas de valores: al primero se lo conoce como 
\textbf{\textcolor[rgb]{0.2,0.5,0.5}{clave}}, y al segundo como el valor \textbf{\textcolor[rgb]{0.2,0.5,0.5}{asociado}} 
a dicha clave. No permite valores de clave repetidos y se ordena según su clave. Podemos acceder al valor asociado a la clave 
a través de la clave, pero no al revés, no podemos acceder a la clave a través del valor asociado a ésta.
Los \textit{\textcolor[rgb]{0.2,0.5,0.5}{multimap}} son lo mismo pero permiten valores de clave repetidos. Usan los mismos métodos que set y multiset. Podemos usar el operator[] para acceder a los elementos asociados a las claves o modificarlos. Por ejemplo:
\begin{minted}[linenos]{c++}
map<char,string> mymap;
mymap['a'] = "un elemento";
mymap['c'] = mymap['a'];
cout << mymap['a'];
\end{minted}

\noindent
Vamos a hacer un ejemplo con una guía de teléfonos:

\begin{minted}[linenos]{c++}
#include <map>
#include <iostream>
#include <string>

class Guiadetelefonos {
private:
      map<string,string> datos;
      //el primer string es el nombre de la persona y el segundo su tlf
      //la clave seria el nombre de la persona

public:
      string & operator[] (const string &nombre) {
            return datos[nombre];
      }

      //para saber los telefonos asociados a un nombre con un multimap
      vector<string> operator[] (const string &nombre) {
            pair<map<string,string>::const_iterator,
                  map<string,string>::const_iterator> ret;

            ret = datos.equal_range(nombre);

            vector<string> vaux;

            multimap<string,string>::const_iterator it;

            for (it=ret.first;it!=ret.second;++it)
                  vaux.push_back(it->second);

            return vaux;
      }

      string getTelefono (const string &nombre) {
            map<string,string>::iterator it=datos.find(nombre);

            if (it==datos.end())
            //si no lo encuentra devolvemos un string vacio
                  return string("");

            else
                  return it->second; //(*it).second;
      }

      //insertamos un numero de telefono y devolvemos true si se ha insertado con exito
      pair <map<string,string>::iterator,bool> insert (string noombre, string tlf) {
            pair<string,string> p(nombre, tlf);
            pair<map<string,string>::iterator, bool> ret;

            //solo tenemos que llamar a la funcion insert de map que devuelve true
            //si el telefono apuntado por it ha sido insertado con exito en la guia
            ret=datos.insert(p);

            return ret;
      }

      //para borrar un telefono de la guia
      void borrar (const string &nombre) {
            map<string,string>::iterator itlow=datos.lower_bound(nombre);
            map<string,string>::iterator itup=datos.upper_bound(nombre);

            /*Para asegurarnos de que el nombre esta en la guia debemos 
            comprobar que nombre coincide con itlow.first o habernos
            asegurado antes de llamar a la funcion, porque si no, 
            podemos borrar a otra persona*/
            if(itlow.first == nombre)
                  datos.erase(itlow,itup);

            /*otra forma:
            pair<map<string,string>::const_iterator,
                  map<string,string>::const_iterator> ret;
            ret = datos.equal_range(nombre);
            datos.erase(ret.first,ret.second);*/
      }

      int size()const {
            return datos.size();
      }

      //para saber cuanta gente en nuestra guia tiene el mismo nombre
      unsigned int contabiliza (const string &nombre) {
            return datos.count(nombre);
      }

      void clear() {
            datos.clear();
      }

      //mirar el resto de funciones en el cvg

      class iterator {
      private:
            map<string,string>::iterator it;

      public:
            iterator & operator++() {
                  ++it;
                  return *this;
            }

            iterator & operator--() {
                  --it;
                  return *this;
            }

            pair<string,string> & operator*() {
                  return *it;
            }

            bool operator== (const iterator &i)const {
                  return it==i.it;
            }

            bool operator!= (const iterator &i)const {
                  return it!=i.it;
            }

            friend class Guiadetelefono;
      };

      iterator begin() {
            iterator i;
            i.it=datos.begin();
            return i;
      }

      iterator end() {
            iterator i;
            i.it=datos.end();
            return i;
      }
};
\end{minted}

\chapter{\textcolor[rgb]{0.3,0.4,0.8}{Estructuras de datos no lineales}}
\section{\textcolor[rgb]{0.3,0.4,0.8}Estructura de datos jerárquica: árboles}
\noindent
Desde el punto de vista de la teoría de grafos, definimos un \textbf{\textcolor[rgb]{0.3,0.4,0.8}{árbol}} como un grafo acíclico donde cada nodo tiene grado de entrada\footnote{número de líneas que entran al nodo} 1 (excepto el nodo raíz que tiene grado de entrada 0) y el grado de salida\footnote{número de líneas que salen de un nodo. Las hojas tienen grado de salida 0} 0 o mayor que cero.

\noindent
Un árbol se compone de \textit{\textcolor[rgb]{0.3,0.4,0.8}{nodos}}. Hay tres tipos de nodos:
\begin{enumerate}[$\heartsuit$]
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{raíz}}: no tiene padre, es el nodo que está en la parte superior de la jerarquía.
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{hoja}}: no tienen hijos, son los nodos que están en la parte inferior de la jerarquía.
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{interiores}}: el resto de nodos.
\end{enumerate}

\noindent
Algunas características de los árboles son:
\begin{enumerate}[---]
\item Todos los nodos descienden de la raíz.
\item Los descendientes directos se llaman hijos, el resto no son hijos descendientes.
\item Los nodos del mismo nivel y que descienden del mismo padre son hermanos.
\item Y los padres de los padres de un nodo son los ancestros de éste.
\end{enumerate}

\noindent
Un ejemplo de árbol sería \label{arbol_linux}:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{/}
,(0,-15)*+=<10mm>[]\txt<2cm>{usr}
,(-35,-15)*+=<10mm>[]\txt<2cm>{home}
,(35,-15)*+=<10mm>[]\txt<2cm>{var}
,(-45,-25)*+=<10mm>[]\txt<2cm>{rosa}
,(-25,-25)*+=<10mm>[]\txt<2cm>{jags}
,(-55,-35)*+=<10mm>[]\txt<2cm>{alumnos}
,(-35,-35)*+=<10mm>[]\txt<2cm>{docs}
,(-65,-45)*+=<10mm>[]\txt<2cm>{f1}
,(-45,-45)*+=<10mm>[]\txt<2cm>{f2}
,(-25,-35)*+=<10mm>[]\txt<2cm>{papers}
,(-10,-25)*+=<10mm>[]\txt<2cm>{bin}
,(10,-25)*+=<10mm>[]\txt<2cm>{include}
,(-10,-35)*+=<10mm>[]\txt<2cm>{b1txt}
,(35,-25)*+=<10mm>[]\txt<2cm>{www}

\ar@{-} (0,-5);(0,-10)
\ar@{-} (-2,-5);(-30,-15)
\ar@{-} (2,-5);(30,-15)
\ar@{-} (-35,-16);(-42,-25)
\ar@{-} (-30,-16);(-23,-25)
\ar@{-} (-45,-26);(-55,-34)
\ar@{-} (-45,-27);(-35,-34)
\ar@{-} (-55,-36);(-65,-44)
\ar@{-} (-55,-37);(-45,-44)
\ar@{-} (-25,-27);(-25,-33)
\ar@{-} (-2,-16);(-10,-23)
\ar@{-} (-2,-17);(10,-23)
\ar@{-} (-10,-27);(-10,-33)
\ar@{-} (35,-17);(35,-23)
\end{xy}\]

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Conceptos}
\begin{description}
\item[árbol n-ario]: se caracteriza porque todos los nodos tienen 0 ó n hijos. Por ejemplo, un árbol 3-ario tiene 0 ó 3 hijos únicamente. Un árbol 2-ario tiene 0 ó 2 hijos, pero uno binario puede tener 0, 1 ó 2 hijos.

\item[camino en un árbol]: es una sucesión de nodos $n_{1},n_{2},\cdots,n_{k}$ donde el nodo i-ésimo ($n_{i}$) es padre del nodo $i+1$ ($n_{i+1}$). 
La longitud del camino es igual al número de nodos menos uno. En nuestro \hyperref[arbol_linux]{ejemplo \ref*{arbol_linux}}, un camino podría ser:
\begin{center}
/ $\qquad$ home $\qquad$ rosa $\qquad$ alumnos $\qquad$ f1
\end{center}
Donde rosa sería padre de alumnos y la longitud del camino sería 4.

\item[ancestro]: el nodo $n_{i}$ es ancestro del nodo $n_{j}$ si existe un camino desde $n_{i}$ tal que $n_{i}$ se coloca en el camino delante de $n_{j}$. Por ejemplo, en el camino:
\begin{center}
\begin{displaymath}
n_{s} \cdots n_{j} \cdots n_{i} \cdots n_{l}
\end{displaymath}
\end{center}
$n_{j}$ es ancestro de $n_{i}$ porque está antes en el camino.

\item[descendiente]: $n_{i}$ es descendiente de $n_{j}$ si existe un camino tal que $n_{i}$ se liste después que $n_{j}$. En el ejemplo anterior, $n_{i}$ es descendiente de $n_{j}$ pues se lista después.

\item[subárbol]: sean $n_{i}$ y todos los descendientes de $n_{i}$ en el árbol $T_{1}$. En el primer \hyperref[arbol_linux]{ejemplo \ref*{arbol_linux}}, podríamos tener un subárbol que empiece en rosa y termine en las hojas f1, f2, d1 y d2. El propio árbol es un subárbol que cuelga de él mismo.

\label{def_altura}
\item[altura de un nodo]: es el camino más largo entre el nodo $i$ y una hoja. Todas las hojas tienen altura cero. La altura de un árbol es la altura del nodo raíz. En nuestro primer \hyperref[arbol_linux]{ejemplo \ref*{arbol_linux}}, en usr tenemos $A=2$ pues el camino más largo es por bin. 

\item[profundidad de un nodo]: longitud del camino que existe entre el nodo y la raíz. Por ejemplo, los hijos de la raíz tienen profundidad uno.

\item[niveles de un árbol]: si un árbol tiene altura $h$, tenemos $h+1$ niveles. El rango de valores para los niveles va desde 0 hasta h. En el nivel $0$ está la raíz, en el nivel $1$ están los hijos de la raíz, en el $h$ están las hojas y en el nivel $i$ tenemos todos los nodos de profundidad $i$.

\item[grado de un nodo](grado de salida): número de hijos que tiene un nodo.

\item[grado de un árbol]: máximo de los grados de todos los nodos del árbol.

\item[árbol binario]: en un árbol binario, cada nodo puede tener 0, 1 ó 2 hijos. El árbol vacío\footnote{el árbol que no tiene ningún nodo}, también se considera binario.

\item[árbol 2-ario]: cada nodo tiene 0 ó dos hijos. Es equivalente al árbol binario homogéneo.

\item[árbol binario homogéneo]: cada nodo tiene 0 ó dos hijos. Es equivalente al árbol 2-ario.

\item[árbol binario completo]: es un árbol que tiene todos los niveles completos excepto el último nivel ( a partir de ahora lo llamaremos nivel inferior),  en cuyo caso, los huecos quedan a la derecha. Por ejemplo:
\begin{enumerate}[1.]
\item Este árbol sería completo porque sólo tiene un hueco a la derecha en el nivel inferior:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-5,-10)*+=<10mm>[]\txt<2cm>{b}
,(5,-10)*+=<10mm>[]\txt<2cm>{c}
,(-10,-20)*+=<10mm>[]\txt<2cm>{d}
,(0,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{f}

\ar@{-} (0,-2);(-4,-9)
\ar@{-} (0,-2);(4,-9)
\ar@{-} (-5,-12);(-9,-19)
\ar@{-} (-5,-12);(1,-19)
\ar@{-} (5,-12);(5,-18)
\end{xy}\]

\item Este árbol sería homogéneo y completo porque tiene dos huecos a la derecha en el nivel inferior:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-5,-10)*+=<10mm>[]\txt<2cm>{b}
,(5,-10)*+=<10mm>[]\txt<2cm>{c}
,(-10,-20)*+=<10mm>[]\txt<2cm>{d}
,(0,-20)*+=<10mm>[]\txt<2cm>{e}

\ar@{-} (0,-2);(-4,-9)
\ar@{-} (0,-2);(4,-9)
\ar@{-} (-5,-12);(-9,-19)
\ar@{-} (-5,-12);(1,-19)
\end{xy}\]

\item Este árbol es homogéneo pero no completo porque tiene los huecos a la izquierda en el nivel inferior:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-5,-10)*+=<10mm>[]\txt<2cm>{b}
,(5,-10)*+=<10mm>[]\txt<2cm>{c}
,(10,-20)*+=<10mm>[]\txt<2cm>{d}
,(0,-20)*+=<10mm>[]\txt<2cm>{e}

\ar@{-} (0,-2);(-4,-9)
\ar@{-} (0,-2);(4,-9)
\ar@{-} (5,-12);(9,-19)
\ar@{-} (5,-12);(1,-19)
\end{xy}\]
\end{enumerate}
El número máximo de nodos de un árbol  con $h$ niveles, teniendo en cuenta que un nivel tiene como máximo $2^{i}$ nodos es:
\begin{displaymath}
\sum_{i=0}^{h} 2^{i} = 2^0 + 2^1 + \cdots + 2^n
\end{displaymath}
\begin{displaymath}
S_n = 2^0 + 2^1 + \cdots + 2^n 
\end{displaymath}
\begin{displaymath}
2S_n = 2^1 + \cdots + 2^{n+1}
\end{displaymath}
\begin{displaymath}
2S_n - S_n = 2^{n+1} - 2^0 = 2^{n+1} - 1
\end{displaymath}
Teniendo en cuenta que el árbol debe tener todos sus niveles completos.
\end{description}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Recorridos}
\noindent
Pueden ser de dos tipos:
\begin{enumerate}[$\spadesuit$]
\item \textbf{\textcolor[rgb]{0.3,0.4,0.8}{Profundidad}}: hay tres tipos:
\begin{itemize}
\item Preorden
\item Inorden
\item Postorden
\end{itemize}
\item \textbf{\textcolor[rgb]{0.3,0.4,0.8}{Anchura}}: por niveles.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Preorden}
\noindent
En el preorden, empezamos listando la raíz y después los subárboles de sus hijos, empezando por el hijo de la izquierda, recursivamente.

\noindent
Vamos a trabajar sobre el siguiente ejemplo \label{ejemplo_recorridos}:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(0,-10)*+=<10mm>[]\txt<2cm>{c}
,(10,-10)*+=<10mm>[]\txt<2cm>{d}
,(-12,-15)*+=<10mm>[]\txt<2cm>{e}
,(-7,-15)*+=<10mm>[]\txt<2cm>{f}
,(-3,-15)*+=<10mm>[]\txt<2cm>{g}
,(3,-15)*+=<10mm>[]\txt<2cm>{h}
,(3,-20)*+=<10mm>[]\txt<2cm>{i}

\ar@{-} (0,-2);(-9,-9)
\ar@{-} (0,-2);(0,-8)
\ar@{-} (0,-2);(9,-9)
\ar@{-} (-10,-12);(-11,-14)
\ar@{-} (-10,-12);(-8,-14)
\ar@{-} (0,-11);(-2,-14)
\ar@{-} (0,-11);(2,-14)
\ar@{-} (3,-17);(3,-19)
\end{xy}\]

\noindent
El preorden de este \hyperref[ejemplo_recorridos]{ejemplo \ref*{ejemplo_recorridos}}, sería:
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{Pre(a)}
,(0,-5)*+=<10mm>[]\txt<2cm>{a}
,(7,-5)*+=<10mm>[]\txt<2cm>{Pre(b)}
,(7,-10)*+=<10mm>[]\txt<2cm>{b}
,(14,-10)*+=<10mm>[]\txt<2cm>{Pre(e)}
,(14,-15)*+=<10mm>[]\txt<2cm>{e}
,(25,-15)*+=<10mm>[]\txt<2cm>{Pre(f)}
,(25,-20)*+=<10mm>[]\txt<2cm>{f}
,(30,-5)*+=<10mm>[]\txt<2cm>{Pre(c)}
,(30,-10)*+=<10mm>[]\txt<2cm>{c}
,(37,-10)*+=<10mm>[]\txt<2cm>{Pre(g)}
,(37,-15)*+=<10mm>[]\txt<2cm>{g}
,(50,-10)*+=<10mm>[]\txt<2cm>{Pre(h)}
,(50,-15)*+=<10mm>[]\txt<2cm>{h}
,(57,-15)*+=<10mm>[]\txt<2cm>{Pre(i)}
,(57,-20)*+=<10mm>[]\txt<2cm>{i}
,(65,-5)*+=<10mm>[]\txt<2cm>{Pre(d)}
,(65,-10)*+=<10mm>[]\txt<2cm>{d}

\ar@{-} (0,-2);(0,-4)
\ar@{-} (7,-7);(7,-9)
\ar@{-} (14,-12);(14,-14)
\ar@{-} (7,-7);(25,-7)
\ar@{-} (25,-7);(25,-13)
\ar@{-} (25,-16);(25,-19)
\ar@{-} (0,-2);(30,-2)
\ar@{-} (30,-2);(30,-4)
\ar@{-} (30,-7);(30,-9)
\ar@{-} (37,-12);(37,-14)
\ar@{-} (30,-7);(50,-7)
\ar@{-} (50,-7);(50,-9)
\ar@{-} (50,-12);(50,-14)
\ar@{-} (57,-17);(57,-19)
\ar@{-} (0,-2);(65,-2)
\ar@{-} (65,-2);(65,-4)
\ar@{-} (65,-6);(65,-9)
\end{xy}\]

\noindent
Y los pasos a ejecutar para ir haciéndolo son:
\begin{enumerate}[1.]
\item Empezamos por el subárbol de la raíz, y hacemos Pre(a)
\item Listamos la raíz: a
\item Ahora vamos al subárbol de b, el hijo más a la izquierda de a y hacemos Pre(b)
\item Listamos la raíz de este subárbol, b, y nos vamos al subárbol del hijo más a la izquierda de b: e
\item Hacemos Pre(e) y al ser la raíz del subárbol lo listamos, e, pero al no tener hijos volvemos para atrás y listamos el siguiente hijo de b: Pre(f)
\item Listamos la raíz del subárbol formado por f y al no tener más hijos volvemos hacia b. Al no tener b más hijos volvemos a a y hacemos Pre(c), el siguiente hijo de a.
\item Listamos la raíz del subárbol formado por c y hacemos Pre(g), el hijo más a la izquierda de c
\item Hacemos el preorden del primer hijo a la izquierda de c, g, listamos la raíz del subárbol formado por g y y como no tiene hijos volvemos para atrás a c y listamos el siguiente hijo de c, h.
\item Tras hacer Pre(h) y listar h, hacemos Pre(i), el único hijo de h, listamos i y como no tiene hijos volvemos para atrás hasta a.
\item Hacemos el preorden del último hijo de a, d. Listamos la raíz del subárbol formado por d y como no tiene hijos volvemos a a. Como ya no tiene a más hijos, hemos terminado el preorden.
\end{enumerate}

\noindent
El listado en preorden sería:
\begin{displaymath}
a \qquad\ b \qquad\ e \qquad\ f \qquad\ c \qquad\ g \qquad\ h \qquad\ i \qquad\ d
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Inorden}
\noindent
En el inorden, listamos primero el primer hijo de la raíz, después la raíz y por último, el resto de hijos de la raíz. El inorden del \hyperref[ejemplo_recorridos]{ejemplo \ref*{ejemplo_recorridos}} anterior sería:
\[\begin{xy}
,(0,0)*+=<10mm>\txt<2cm>{In(a)}
,(0,-10)*+=<10mm>\txt<2cm>{In(b)}
,(0,-20)*+=<10mm>\txt<2cm>{In(e)}
,(0,-30)*+=<10mm>\txt<2cm>{e}
,(7,-20)*+=<10mm>\txt<2cm>{b}
,(20,-20)*+=<10mm>\txt<2cm>{In(f)}
,(10,-10)*+=<10mm>\txt<2cm>{a}
,(30,-10)*+=<10mm>\txt<2cm>{In(c)}
,(30,-20)*+=<10mm>\txt<2cm>{In(g)}
,(30,-30)*+=<10mm>\txt<2cm>{g}
,(40,-20)*+=<10mm>\txt<2cm>{c}
,(50,-20)*+=<10mm>\txt<2cm>{In(h)}
,(50,-30)*+=<10mm>\txt<2cm>{In(i)}
,(50,-40)*+=<10mm>\txt<2cm>{i}
,(60,-30)*+=<10mm>\txt<2cm>{h}
,(70,-10)*+=<10mm>\txt<2cm>{In(d)}
,(70,-20)*+=<10mm>\txt<2cm>{d}

\ar@{-} (0,-2);(0,-8)
\ar@{-} (0,-12);(0,-18)
\ar@{-} (0,-22);(0,-28)
\ar@{-} (0,-12);(6,-19)
\ar@{-} (0,-12);(20,-12)
\ar@{-} (20,-12);(20,-19)
\ar@{-} (0,-2);(10,-9)
\ar@{-} (0,-2);(30,-2)
\ar@{-} (30,-2);(30,-8)
\ar@{-} (30,-12);(30,-18)
\ar@{-} (30,-22);(30,-28)
\ar@{-} (30,-12);(40,-18)
\ar@{-} (30,-12);(50,-12)
\ar@{-} (50,-12);(50,-18)
\ar@{-} (50,-22);(50,-28)
\ar@{-} (50,-32);(50,-38)
\ar@{-} (50,-22);(60,-28)
\ar@{-} (0,-2);(70,-2)
\ar@{-} (70,-2);(70,-8)
\ar@{-} (70,-12);(70,-18)
\end{xy}\]

\noindent
Los pasos a seguir son:
\begin{enumerate}[1.]
\item Hacemos el inorden de a, In(a), y hacemos In(b), el primer hijo de a, hacemos In(e) de e, el primer hijo de b y, como e no tiene hijos, lo listamos.
\item Después, volvemos a b y lo listamos, b, y después, hacemos In(f), el otro hijo de b.
\item Como f no tiene hijos, lo listamos y volvemos para atrás, ya no tenemos más hijos en b por lo que volvemos a $a$ y lo listamos.
\item Una vez listado a, seguimos con In(c), el siguiente hijo de a.
\item Tras hacer In(c), empezamos con su primer hijo por la izquierda, y hacemos In(g), al no tener g ningún hijo, lo listamos y volvemos a c, listamos c y seguimos con el otro hijo de c, h.
\item Hacemos In(h), seguimos con el primer hijo de h, i y hacemos In(i). Al no tener i ningún hijo, listamos i y volvemos atrás, listamos h y al no tener h más hijos volvemos directamente a a, porque c tampoco tiene más hijos.
\item Seguimos con el último hijo de a, d. Hacemos In(d) y como d no tiene ningún hijo, listamos d y volvemos a $a$. Como a no tiene más hijos, hemos terminado el problema.
\end{enumerate}

\noindent
El listado en inorden sería:
\begin{displaymath}
e \qquad\ b \qquad\ f \qquad\ a \qquad\ g \qquad\ c \qquad\ i \qquad\ h \qquad\ d
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Postorden}
\noindent
En el postorden empezamos listando primero todos los hijos de la raíz, empezando por el hijo de la izquierda y, por último, listamos la raíz.

\noindent
El recorrido en postorden del \hyperref[ejemplo_recorridos]{Figura \ref*{ejemplo_recorridos}} sería:
\[\begin{xy}
,(0,0)*+=<10mm>\txt<2cm>{Post(a)}
,(0,-10)*+=<10mm>\txt<2cm>{Post(b)}
,(0,-20)*+=<10mm>\txt<2cm>{Post(e)}
,(0,-30)*+=<10mm>\txt<2cm>{e}
,(13,-20)*+=<10mm>\txt<2cm>{Post(f)}
,(13,-30)*+=<10mm>\txt<2cm>{f}
,(20,-20)*+=<10mm>\txt<2cm>{b}
,(30,-10)*+=<10mm>\txt<2cm>{Post(c)}
,(30,-20)*+=<10mm>\txt<2cm>{Post(g)}
,(30,-30)*+=<10mm>\txt<2cm>{g}
,(45,-20)*+=<10mm>\txt<2cm>{Post(h)}
,(45,-30)*+=<10mm>\txt<2cm>{Post(i)}
,(45,-40)*+=<10mm>\txt<2cm>{i}
,(55,-30)*+=<10mm>\txt<2cm>{h}
,(60,-20)*+=<10mm>\txt<2cm>{c}
,(70,-10)*+=<10mm>\txt<2cm>{Post(d)}
,(70,-20)*+=<10mm>\txt<2cm>{d}
,(80,-10)*+=<10mm>\txt<2cm>{a}

\ar@{-} (0,-2);(0,-8)
\ar@{-} (0,-12);(0,-18)
\ar@{-} (0,-22);(0,-28)
\ar@{-} (0,-12);(13,-12)
\ar@{-} (13,-12);(13,-18)
\ar@{-} (13,-22);(13,-28)
\ar@{-} (0,-12);(20,-12)
\ar@{-} (20,-12);(20,-18)
\ar@{-} (0,-2);(30,-2)
\ar@{-} (30,-2);(30,-8)
\ar@{-} (30,-12);(30,-18)
\ar@{-} (30,-22);(30,-28)
\ar@{-} (30,-12);(45,-12)
\ar@{-} (45,-12);(45,-18)
\ar@{-} (45,-22);(45,-28)
\ar@{-} (45,-32);(45,-38)
\ar@{-} (45,-22);(55,-22)
\ar@{-} (55,-22);(55,-28)
\ar@{-} (30,-12);(60,-12)
\ar@{-} (60,-12);(60,-18)
\ar@{-} (0,-2);(70,-2)
\ar@{-} (70,-2);(70,-8)
\ar@{-} (70,-12);(70,-18)
\ar@{-} (0,-2);(80,-2)
\ar@{-} (80,-2);(80,-8)
\end{xy}\]

\noindent
Los pasos a seguir serían:
\begin{enumerate}[1.]
\item Hacemos Post(a), después, empezamos con el primer hijo a la izquierda de a, b haciendo Post(b). Seguimos con el primer hijo a la izquieda de b que es e y hacemos Post(e), como e ya no tiene más hijos, lo listamos y volvemos atrás.
\item Seguimos con el otro hijo de b, f haciendo Post(f), como f no tiene hijos lo listamos y volvemos atrás, al no tener más hijos b lo listamos y volvemos a a.
\item Después seguimos con c, el siguiente hijo de a. Hacemos un Post(c) y empezamos con el primer hijo de c, g. Hacemos un Post(g) y como g no tiene hijos, lo listamos.
\item Seguimos con el otro hijo de c, h haciendo un Post(h) y como h sí tiene un hijo, i, hacemos un Post(i). Como i no tiene hijos lo listamos y volvemos a h, como h no tiene más hijos, lo listamos y volvemos a c y como c no tiene más hijos, lo listamos y volvemos a a.
\item Nos vamos al último hijo de a, d, hacemos Post(d) y como no tiene hijos lo listamos y volvemos a a. Como a no tiene más hijo lo listamos y terminamos el recorrido.
\end{enumerate}

\noindent
El listado en postorden sería:
\begin{displaymath}
e \qquad\ f \qquad\ b \qquad\ g \qquad\ i \qquad\ h \qquad\ c \qquad\ d \qquad\ a
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Anchura o por niveles}
\noindent
Listamos los nodos que hay en cada nivel, empezando por el que esté más a la izquierda. Por ejemplo, el recorrido por niveles del \hyperref[ejemplo_recorridos]{Figura \ref*{ejemplo_recorridos}} sería:
\begin{displaymath}
\underbrace{a}_{h=0} \qquad\ \underbrace{b \qquad\ c \qquad\ d}_{h=1} \qquad\ \underbrace{e \qquad\ f \qquad\ g \qquad\ h}_{h=2} \qquad\ \underbrace{i}_{h=3}
\end{displaymath}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Recorridos en árboles binarios}
\noindent
Los recorridos en un árbol binario serían:
\begin{enumerate}[$\spadesuit$]
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Preorden}}: raíz - Pre($T_{izq}$) - Pre($T_{dcha}$)
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Inorden}}: In($T_{izq}$) - raíz - In($T_{dcha}$)
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Postorden}}: Post($T_{izq}$) - Post($T_{dcha}$) - raíz
\end{enumerate}

\noindent
Por ejemplo, los recorridos del siguiente árbol serían:


\begin{minipage}{0.4\textwidth}
\begin{flushleft}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{d}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{f}
,(15,-20)*+=<10mm>[]\txt<2cm>{g}
,(0,-30)*+=<10mm>[]\txt<2cm>{h}
,(10,-30)*+=<10mm>[]\txt<2cm>{i}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (5,-22);(0,-28)
\ar@{-} (5,-22);(10,-28)
\end{xy}\]
\end{flushleft}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushright}
\begin{enumerate}[$\rightarrow$]
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Preorden}}: $a \quad\ b \quad\ d \quad\ e \quad\ c \quad\ f \quad\ h \quad\ i \quad\ g$
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Inorden}}: $d \quad\  b \quad\  e \quad\  a \quad\  h \quad\  f \quad\  i \quad\  c \quad\  g$
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Postorden}}: $d \quad\  e \quad\  b \quad\  h \quad\  i \quad\  f \quad\  g \quad\  c  \quad\ a$
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Por niveles}}: $a \quad\  b \quad\  c \quad\  d \quad\  e \quad\  f \quad\  g \quad\  h \quad\  i$
\end{enumerate}
\end{flushright}
\end{minipage}

\noindent
Por normal general, con sólo uno de los recorridos de un árbol, no puede recuperarse de manera univoca, es decir, dos árboles diferentes pueden tener el mismo recorrido. Por ejemplo, el árbol de la derecha, es la rotación a la izquierda\footnote{Desplazamos todos los elementos a un lado (izquierda o derecha), esto se usa para equilibrar el árbol cuando por una rama tiene muchos nodos y por la otra no.} del árbol de la izquierda y ambos tienen el mismo inorden:

\begin{minipage}{0.4\textwidth}
\begin{flushleft}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{r}
,(-10,-10)*+=<10mm>[]\txt<2cm>{x}
,(10,-10)*+=<10mm>[]\txt<2cm>{s}
,(-15,-20)*+=<10mm>[]\txt<2cm>{w}
,(-5,-20)*+=<10mm>[]\txt<2cm>{z}
,(5,-20)*+=<10mm>[]\txt<2cm>{u}
,(15,-20)*+=<10mm>[]\txt<2cm>{q}
,(0,-30)*+=<10mm>[]\txt<2cm>{t}
,(10,-30)*+=<10mm>[]\txt<2cm>{p}
,(-20,-30)*+=<10mm>[]\txt<2cm>{v}
,(-15,-30)*+=<10mm>[]\txt<2cm>{y}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (5,-22);(0,-28)
\ar@{-} (5,-22);(10,-28)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\end{xy}\]
\end{flushleft}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushright}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{s}
,(-10,-10)*+=<10mm>[]\txt<2cm>{r}
,(10,-10)*+=<10mm>[]\txt<2cm>{q}
,(-15,-20)*+=<10mm>[]\txt<2cm>{x}
,(-5,-20)*+=<10mm>[]\txt<2cm>{u}
,(-20,-30)*+=<10mm>[]\txt<2cm>{w}
,(-15,-30)*+=<10mm>[]\txt<2cm>{z}
,(-25,-40)*+=<10mm>[]\txt<2cm>{v}
,(-20,-40)*+=<10mm>[]\txt<2cm>{y}
,(-10,-30)*+=<10mm>[]\txt<2cm>{t}
,(0,-30)*+=<10mm>[]\txt<2cm>{p}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-20,-32);(-25,-38)
\ar@{-} (-20,-32);(-20,-38)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(0,-28)
\end{xy}\]
\end{flushright}
\end{minipage}

\noindent
El inorden de ambos árboles es:
\begin{displaymath}
v \qquad\ w \qquad\ y \qquad\ x \qquad\ z \qquad\ r \qquad\ t \qquad\ u \qquad\ p \qquad\ s \qquad\ q
\end{displaymath}

\noindent
Al menos debemos tener un inorden y un postorden ó preorden para ver el árbol del que proviene.

\noindent
La siguiente tabla sirve de repaso y resumen de los recorridos, los valores serán verdadero o falso si $n$ se lista antes o después que $m$: \\[0.5cm]
% \begin{table}[H]
% \scriptsize
\begin{tabular}{|l|| l| l| l|} 
\hline
& $Pre(n) < Pre(m)$ & $In(n) < In(m)$ & $Post(n) < Post(m)$ \\
\hline
$n\in ~h_{izq}(m)$ & F & V & V \\ \hline
$n\in ~h_{dcha}(m)$ & F & F & V \\ \hline
$n\in ~descendiente(m)$ & F & V si es descendiente por la izquierda & V \\
~                       &~  & y F si lo es por la derecha &  \\ \hline
$n\in ~ancestro(m)$ & V & igual que antes & F \\ \hline
\end{tabular} 
% \end{table}\\[0.5cm]

\noindent
Dados el preorden y el inorden, obtén el correspondiente árbol binario:
\begin{enumerate}[$\spadesuit$]
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{preorden}}: G E A I B M C L D F K J H
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{inorden}}: I A B E G L D C F M K H J
\end{enumerate}

\noindent
Tenemos que fijarnos en los siguientes detalles:
\begin{enumerate}[1.]
\item La G corresponde con la raíz del árbol pues es la primera que listamos en el preorden.
\item El subárbol que corresponde al hijo izquierdo de G está listado en el inorden antes que G y el hijo a la derecha, está listado después de G.
\item Estos razonamientos se aplican a los distintos subárboles del árbol.
\end{enumerate}

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{G}
,(-10,-10)*+=<10mm>[]\txt<2cm>{E}
,(10,-10)*+=<10mm>[]\txt<2cm>{U}
,(-15,-20)*+=<10mm>[]\txt<2cm>{A}
,(5,-20)*+=<10mm>[]\txt<2cm>{C}
,(15,-20)*+=<10mm>[]\txt<2cm>{K}
,(0,-30)*+=<10mm>[]\txt<2cm>{L}
,(10,-30)*+=<10mm>[]\txt<2cm>{F}
,(-20,-30)*+=<10mm>[]\txt<2cm>{I}
,(-15,-30)*+=<10mm>[]\txt<2cm>{B}
,(5,-40)*+=<10mm>[]\txt<2cm>{D}
,(20,-30)*+=<10mm>[]\txt<2cm>{J}
,(15,-40)*+=<10mm>[]\txt<2cm>{H}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (5,-22);(0,-28)
\ar@{-} (5,-22);(10,-28)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (0,-32);(5,-38)
\ar@{-} (15,-22);(20,-28)
\ar@{-} (20,-32);(15,-38)
\end{xy}\]

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Lectura y escritura de un árbol en disco}
\noindent
Para guardar un árbol en disco, ponemos nodos ficticios con $x$ para representar los nodos vacíos y una $n$ delante de las etiquetas. Por ejemplo, para guardar el siguiente árbol: \label{arbol_disco}

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{1}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{3}
,(-15,-20)*+=<10mm>[]\txt<2cm>{4}
,(-5,-20)*+=<10mm>[]\txt<2cm>{5}
,(5,-20)*+=<10mm>[]\txt<2cm>{6}
,(15,-20)*+=<10mm>[]\txt<2cm>{7}
,(0,-30)*+=<10mm>[]\txt<2cm>{x}
,(10,-30)*+=<10mm>[]\txt<2cm>{x}
,(-20,-30)*+=<10mm>[]\txt<2cm>{x}
,(-15,-30)*+=<10mm>[]\txt<2cm>{x}
,(20,-30)*+=<10mm>[]\txt<2cm>{x}
,(-10,-30)*+=<10mm>[]\txt<2cm>{x}
,(-3,-30)*+=<10mm>[]\txt<2cm>{8}
,(13,-30)*+=<10mm>[]\txt<2cm>{x}
,(2,-37)*+=<10mm>[]\txt<2cm>{x}
,(-5,-37)*+=<10mm>[]\txt<2cm>{x}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (5,-22);(0,-28)
\ar@{-} (5,-22);(10,-28)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (15,-22);(20,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(-3,-28)
\ar@{-} (15,-22);(13,-28)
\ar@{-} (-3,-32);(2,-35)
\ar@{-} (-3,-32);(-5,-35)
\end{xy}\]

\noindent
El preorden que deberíamos escribir en el disco sería: n1n2n4xxn5xn8xxn3n6xxn7xx

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Arboles binarios}
\begin{enumerate}[$\longrightarrow$]
\item Son árboles tal que cada nodo tiene 0, 1 o 2 hijos.
\item El árbol vacío es un árbol binario.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Representación}
\noindent
La representación de un nodo sería con un struct que tendría punteros a los nodos ``familiares'' del nodo y con su etiqueta. Por facilidad a la hora de implementar las funciones del árbol, incluímos también constructores.

\begin{minted}[linenos]{c++}
#include <queue> //para hacer el recorrido por niveles
using namespace std;

template <class T>
struct info_nodo {
      info_nodo *padre, *hijoizq, *hijodcha; // punteros sus nodos "familiares"
      T et; // etiqueta del nodo

      // Constructor por defecto del struct
      info_nodo() {
            padre = hijoizq = hijodcha = 0;
      }

      info_nodo(const T &e) {
            et = e;
            padre = hijoizq = hijodcha = 0;
      }
};
\end{minted}

\noindent
Las operaciones a implementar en un árbol binario serían:
\begin{enumerate}[---]
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Get}}: padre, hijoizq, hijodcha, etiqueta
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Insertar}}: hijoizq, hijodcha
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Podar}}: hijoizq, hijodcha
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Recorridos}}: preorden, inorden, postorden, anchura
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Leer/escribir}}
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Copiar}}
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Borrar}}
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{size}}
\item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Iguales}}
\end{enumerate}

\noindent
Por ahora, implementaremos estas operaciones como funciones sin pertencer a ninguna clase.

\begin{minted}[linenos, firstnumber=16]{c++}
template <class T>
info_nodo<T>* GetPadre (info_nodo<T>* n) {
      return n->padre;
}

template <class T>
info_nodo<T>* GetHijoIzquierda (info_nodo<T>* n) {
      return n->hijoizq;
}

template <class T>
info_nodo<T>* GetHijoDerecha (info_nodo<T>* n) {
      return n->hijodcha;
}

template <class T>
void Copiar (info_nodo<T>* s, info_nodo<T>* &d) {
      if (s == 0)
            d = 0;

      else {
            // llamamos al constructor de info nodo con parametros
            d = new info_nodo<T> (s->et);
            Copiar (s->hijoizq,d->hijoizq);
            Copiar (s->hijodcha,d->hijodcha);
            if (d->hijoizq != 0)
                  d->hijoizq->padre = d;

            if (d->hijodcha != 0)
                  d->hijodcha->padre = 0;
      }
}

template <class T>
void BorrarInfo (info_nodo<T>* n) {
      if (n != 0) {
            BorrarInfo(n->hijoizq);
            BorrarInfo(n->hijodcha);
            delete n;
      }
}

template <class T>
void InsertarHijoIzquierda (info_nodo<T>* n, info_nodo<T>* sub) {
      info_nodo<T>* aux = n->hijoizq;
      if (sub != 0) {
            n->hijoizq = sub;
            BorrarInfo(aux);
            n->hijoizq->padre = n;
      }

      else {
            n->hijoizq = 0;
            BorrarInfo(aux);
      }
}

template <class T>
void InsertarHijoDerecha (info_nodo<T>* n, info_nodo<T>* sub) {
      info_nodo<T>* aux = n->hijodcha;
      if (sub != 0) {
            n->hijodcha = sub;
            BorrarInfo(aux);
            n->hijodcha->padre = n;
      }

      else {
            n->hijodcha = 0;
            BorrarInfo(aux);
      }
}

//Hacemos una sobrecarga de esta funcion para pasarle una etiqueta en vez del nodo
template <class T>
void InsertarHijoIzquierda (info_nodo<T>* n, const T &v) {
      info_nodo<T>* aux = new info_nodo(v);
      InsertarHijoIzquierda(n,aux);
}

template <class T>
void InsertarHijoDerecha (info_nodo<T>* n, const T &v) {
      info_nodo<T>* aux = new info_nodo(v);
      InsertarHijoDerecha(n,aux);
}

template <class T>
void PodarHijoIzquierda (info_nodo<T>* n) {
      if (n->hijoizq != 0) {
            BorrarInfo(n->hijoizq);
            n->hijoizq = 0;
      }
}

template <class T>
void PodarHijoDerecha (info_nodo<T>* n) {
      if (n->hijodcha != 0) {
            BorrarInfo(n->hijodcha);
            n->hijodcha = 0;
      }
}

// Con esta funcion obtenemos el arbol que hemos podado
template <class T>
info_nodo<T>* Podar_HijoIzq_getSubtree (info_nodo<T>* n) {
      info_nodo<T>* aux = n->hijoizq;
      n->hijoizq = 0;
      if (aux != 0)
            aux->padre = 0;

      return aux;
}

template <class T>
info_nodo<T>* Podar_HijoDcha_getSubtree (info_nodo<T>* n) {
      info_nodo<T>* aux = n->hijodcha;
      n->hijodcha = 0;
      if (aux != 0)
            aux->padre = 0;

      return aux;
}

// funcion que define si dos arboles son iguales
template <class T>
bool iguales(info_nodo<T>* n1, info_nodo<T>* n2) {
      if (n1==0 && n2==0) //ambos arboles estan vacios
            return true;

      else if (n1==0 || n2==0)
            return false; //uno de los arboles es vacio

      else { //ninguno es vacio
            if (n1->et == n2->et)
                  return iguales(n1->hijoizq, n2->hijoizq) &&
                         iguales(n1->hijodcha, n2->hijocha);

            else
                  return false;
      }
}

template <class T>
int numero_nodos (info_nodo<T>* n) {
      if (n==0)
            return 0;

      else
            return numero_nodos(n->hijoizq) + numero_nodos(n->hijodcha) + 1;
            // devolvemos el numero de nodos de los dos subarboles hijos de
            // la raiz y le sumamos 1 para contar tambien la raiz en el numero
            // de nodos
}

template <class T>
void RecorridoPreorden (ostream & os, const info_nodo<T> *n) {
      /* En este caso, nuestro caso base seria tener un arbol vacio
      pero en ese caso base no se haria nada*/
      if (n!=0) {
            os << n->et << ' '; //listamos la raiz
            RecorridoPreorden (os, n->hijoizq); //hacemos preorden del hijo izquierdo
            RecorridoPreorden (os, n->hijodcha); //y luego del hijo derecho
      }
}

template <class T>
void RecorridoInorden (ostream & os, const info_nodo<T>* n) {
      if (n!=0) {
            RecorridoInorden (os, n->hijoizq); //Hacemos inorden del hijo izquierdo
            os << n->et << ' '; //listamos la raiz
            RecorridoInorden (os, n->hijodcha); //y hacemos inorden del hijo derecho
      }
}

template <class T>
void RecorridoPostorden (ostream & os, const info_nodo<T>* n) {
      if (n!=0) {
            RecorridoPostorden (os, n->hijoizq); //Hacemos postorden del hijo izquierdo
            RecorridoPostorden (os, n->hijodcha); //luego del hijo derecho
            os << n->et << ' '; //y por ultimo listamos la raiz
      }
}

template <class T>
void RecorridoPorNiveles (ostream & os, const info_nodo<T>* n) {
      /*Vamos a ir guardando en una cola las distintas filas:
            - guardamos un nodo
            - guardamos sus hijos
            - listamos dicho nodo y lo borramos de la cola
            - se queda los hijos en el frente de la cola
            - hacemos lo mismo con los subarboles hijos
      Hay que tener en cuenta que se insertan los elementos al
      final de la cola.
      Hacemos esto hasta que la cola se quede vacia*/
      if (n!=0) {
            queue<const info_nodo<T>*> cola;

            cola.push(n); //guardamos el primer nodo

            while (!cola.empty()) {
                  const info_nodo<T>* p = cola.front(); //ultimo nodo que hemos guardado
                  os << p->et << ' '; //lo listamos
                  if (p->hijoizq != 0) //si tiene hijo a la izquierda lo guardamos
                        cola.push(p->hijoizq);

                  if (p->hijodcha != 0) //igual con el hijo de la derecha
                        cola.push(p->hijodcha);

                  cola.pop(); //borramos el elemento que ya hemos listado
                  // esto tambien se podria haber hecho antes de los if
            }
      }
}
\end{minted}

\noindent
Para las funciones de leer y escribir, vamos a guardar un árbol en disco como ya hemos explicado en la \hyperref[arbol_disco]{sección \ref*{arbol_disco}}:

\begin{minted}[linenos, firstnumber=228]{c++}
template <class T>
void Escribe (ostream & os, const info_nodo<T>* n) {
      if (n==0)
            os << 'x';  //cuando el nodo es hijo de una hoja, se pone una x

      else {
            os << 'n' << n->et; //cuando no, se pone su etiqueta detras de una n
            Escribe(os, n->hijoizq);
            Escribe(os, n->hijodcha);
      }
}

template <class T>
void Lee (istream & is, info_nodo<T>* &n) {
      char c;
      c = is.get();

      if (is) {
            if (c=='x') n=0; //nodo vacio
            else {
                  T e;
                  // si T es un tipo definido por nosotros,
                  // debemos definir su operador de entrada
                  is >> e;
                  n = new info_nodo<T>(e);
                  Lee (is,n->hijoizq);
                  Lee (is,n->hijodcha);
                  // ahora enlazamos a los hijos con su padre
                  if (n->hijoizq != 0) n->hijoizq->padre = n;
                  if (n->hijodcha != 0) n->hijodcha->padre = n;
            }
      }
}
\end{minted}

\noindent
La siguiente función, refleja un árbol. Antes de implementarla vamos a poner un ejemplo para entender lo que sería reflejar un árbol. El árbol de la derecha es el reflejo del árbol de la izquierda:


\begin{minipage}{0.5\textwidth}
\begin{flushleft}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{5}
,(-10,-10)*+=<10mm>[]\txt<2cm>{7}
,(10,-10)*+=<10mm>[]\txt<2cm>{9}
,(-15,-20)*+=<10mm>[]\txt<2cm>{6}
,(-5,-20)*+=<10mm>[]\txt<2cm>{8}
,(5,-20)*+=<10mm>[]\txt<2cm>{10}
,(15,-20)*+=<10mm>[]\txt<2cm>{12}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-10,-12);(-5,-18)
\end{xy}\]
\end{flushleft}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{5}
,(-10,-10)*+=<10mm>[]\txt<2cm>{9}
,(10,-10)*+=<10mm>[]\txt<2cm>{7}
,(-15,-20)*+=<10mm>[]\txt<2cm>{12}
,(-5,-20)*+=<10mm>[]\txt<2cm>{10}
,(5,-20)*+=<10mm>[]\txt<2cm>{8}
,(15,-20)*+=<10mm>[]\txt<2cm>{6}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-10,-12);(-5,-18)
\end{xy}\]
\end{flushright}
\end{minipage}

\noindent
Como se puede ver en el ejemplo, vamos cambiando recursivamente el subárbol de la izquierda por el de la derecha. La implementación en C++ sería:

\begin{minted}[linenos, firstnumber=261]{c++}
template <class T>
void Reflejo (info_nodo<T>* n) {
      if (n!=0) {
            swap (n->hijoizq,n->hijodcha);
            Reflejo(n->hijoizq);
            Reflejo(n->hijodcha);
      }
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Clase ArbolBinario}
\noindent
Todo lo que hemos implementado hasta ahora corresponde a la parte private de la clase. El atributo privado de la clase es un puntero a info\_nodo que corresponde con la raíz del árbol. Dentro de la clase ArbolBinario tenemos la clase nodo, que es una especie de iterador detro del árbol, cuyo atributo privado es un puntero a info\_nodo.
En la implementación de la clase se usa varias veces un typename, si no recuerdas lo que es, se estudió en la \hyperref[typename]{seccion \ref*{typename}}. En particular usaremos: \\ 
 
 {\centering\fbox{$typename~~ArbolBinario<T>::nodo$}\par}~\\ 

Es necesario anteponer  {\it typename}, en primer lugar porque ArbolBinario es una clase template. Y 
además al hacer referencia a nodo, si no ponemos la palabra clave {\it typename} el compilador, el tipo nodo,  lo interpreta como un objeto miembro y no como un tipo.

Las implementaciones de los métodos de la clase ArbolBinario serían:

\begin{minted}[linenos]{c++}
// Mirar .h en el cvg

// Constructor para construir un arbol a partir de una etiqueta
template <class T>
ArbolBinario<T>::ArbolBinario (const T &e) {
      raiz = new info_nodo(e);
}

// Constructor para construir un arbol a partir de un nodo
template <class T>
ArbolBinario<T>::ArbolBinario (typename ArbolBinario<T>::nodo n) {
      raiz = n.p; // esto se puede hacer porque ArbolBinario es amiga de nodo
}

//Constructor para construir un arbol a partir de otro arbol (de copia)
template <class T>
ArbolBinario<T>::ArbolBinario (const ArbolBinario<T> &ab) {
      if (ab.raiz==0)
            raiz = 0;

      else
            Copiar(raiz,ab.raiz); 
            // esta llamada a copiar es al metodo privado de la clase,
            // no a la funcion copiar.
}

template <class T>
ArbolBinario<T> & ArbolBinario<T>::operator= (const ArbolBinario<T> &ab) {
      if (*this != &ab) {
            BorrarInfo(raiz);
            Copiar(raiz,ab.raiz);
      }

      return *this;
}

// Esta es la funcion a la que llama el destructor
template <class T>
void ArbolBinario<T>::clear() {
      BorrarInfo(raiz);
}

template <class T>
bool ArbolBinario<T>::empty()const {
      return raiz==0;
}

template <class T>
unsigned int ArbolBinario<T>::size() const {
      return numero_nodos(raiz);
}

template <class T>
bool ArbolBinario<T>::operator==(const ArbolBinario<T> &ab) {
      return iguales(raiz,ab.raiz);
}

template <class T>
bool ArbolBinario<T>::operator!=(const ArbolBinario<T> &ab) {
      return !(*this == ab);
      //otra opcion seria: return !iguales(raiz,ab.raiz);
}

template <class T>
void ArbolBinario<T>::RecorridoPreorden (ostream &os)const {
      RecorridoPreorden(os,raiz);
}

template <class T>
void ArbolBinario<T>::RecorridoInorden (ostream &os)const {
      RecorridoInorden(os,raiz);
}

template <class T>
void ArbolBinario<T>::RecorridoPostorden (ostream &os)const {
      RecorridoPostorden(os,raiz);
}

template <class T>
void ArbolBinario<T>::RecorridoPorNiveles (ostream &os)const {
      RecorridoPorNiveles(os,raiz);
}

// En los operadores de E/S podemos darle otro tipo distinto de T,
// pues no pertenecen a la clase que estamos implementando
template <class U>
istream & operator>> (istream &is, ArbolBinario<U> &ab) {
      ab.Lee (is,ab.raiz);
      return is;
}

template <class U>
ostream & operator<< (ostream &os, ArbolBinario<U> &ab) {
      ab.Escribe(os, ab.raiz);
      return os;
}

// Implementacion de la clase nodo:
template <class T>
typename ArbolBinario<T>::nodo ArbolBinario<T>::getRaiz()const {
      if (raiz != 0)
            return typename ArbolBinario<T>::nodo (raiz);
            // Devuelve un objeto de tipo nodo que apunta a la raiz del arbol

      else
            return typename ArbolBinario<T>::nodo(); //arbol vacio
}

template <class T>
typename ArbolBinario<T>::nodo ArbolBinario<T>::Insertar_Hi(
                        typename ArbolBinario<T>::nodo n, const T &e) {
      /*Esta funcion elimina el hijo izquierdo de n e inserta una nueva rama
      con el nodo de etiqueta e. Devuelve un nodo apuntando al nuevo hijo a
      la izquierda, el nodo de etiqueta e*/
      InsertarHijoIzquierda(n.p,e);
      return typename ArbolBinario<T>::nodo (n->hijoizq);
}

template <class T>
typename ArbolBinario<T>::nodo ArbolBinario<T>::Insertar_Hi (
                        typename ArbolBinario<T>::nodo n, ArbolBinario<T> &tree) {
      InsertarHijoIzquierda(n.p,tree.raiz);
      tree.raiz=0; // el arbol ya forma parte de *this, no tiene 
                   // raiz sino que es hijo de n
      return typename ArbolBinario<T>::nodo(n.p->hijoizq);
}

template <class T>
typename ArbolBinario<T>::nodo ArbolBinario<T>::Insertar_Hd(
                        typename ArbolBinario<T>::nodo n, const T &e) {
      /*Esta funcion elimina el hijo derecho de n e inserta una nueva rama
      con el nodo de etiqueta e. Devuelve un nodo apuntando al nuevo hijo a
      la derecha, el nodo de etiqueta e*/
      InsertarHijoDerecha(n.p,e);
      return typename ArbolBinario<T>::nodo (n->hijodcha);
}

template <class T>
typename ArbolBinario<T>::nodo ArbolBinario<T>::Insertar_Hd (
                        typename ArbolBinario<T>::nodo n, ArbolBinario<T> &tree) {
      InsertarHijoDerecha(n.p,tree.raiz);
      tree.raiz=0; // el arbol ya forma parte de *this, no tiene 
                   // raiz sino que es hijo de n
      return typename ArbolBinario<T>::nodo(n.p->hijodcha);
}

template <class T>
void ArbolBinario<T>::Podar_Hi (typename ArbolBinario<T>::nodo pos) {
      PodarHijoIzquierda(pos.p);
}

template <class T>
void ArbolBinario<T>::Podar_Hd (typename ArbolBinario<T>::nodo pos) {
      PodarHijoDerecha(pos.d);
}

// Esta funcion devuelve el hijo que hemos podado
ArbolBinario<T> ArbolBinario<T>::PodarHi_GetSubtree (
                              typename ArbolBinario<T>::nodo pos) {
      typename ArbolBinario<T>::info_nodo * aux = Podar_HijoIzq_getSubtree(pos.p);
      if (aux != 0)
            aux->padre = 0;

      typename ArbolBinario<T>::nodo naux(aux);
      ArbolBinario<T> anuevo(naux);
      return anuevo;
}
\end{minted}

\noindent
No podemos definir los operadores ++ y -- en nodo porque no sabemos cómo recorrer el árbol. Hacer ++ implica saber cómo estamos recorriendo el árbol. 
Si queremos definir un árbol binario con todas las posibilidades para recorrerlo, debemos sobrecargar cuatro iteradores distintos que implementen cada uno de los recorridos
que hay: iterator\_preorden, iterator\_postorden.

\noindent
Empezamos con el preorden\_iterator. Tiene sus constructores, su operador *, de igualdad... Y el de incremento, cuya implementación sería:
\begin{minted}[linenos, firstnumber=168]{c++}
typename ArbolBinario<T>::preorden_iterator & 
            ArbolBinario<T>::preorden_iterator::operator++() {

      if (p==0) //si el arbol es vacio no hay nodos que listar
            return *this;

      if (p->hijoizq != 0) //si tenemos hijo izquierdo
            p=p->hijoizq;  //el siguiente es su hijo izquierdo

      else {                       //En caso de que no tenga hijoi zquierda
            if (p->hijodcha != 0)  //el siguiente es el hijo derecho
                  p=p->hijodcha;

            else {                  //Cuando llegamos a una hoja:
                  while (p->padre != 0 && //mientra p no sea la raiz
                        p->padre->hijodcha == 0 || //y no tenga hijo a la derecha
                        p->padre->hijodcha == p) // o yo sea el hijo a la derecha
                        p=p->padre; //subimos al padre
                        

                  if (p->padre==0)//si hemos llegado a la raiz ya no hay siguiente
                        p=0; //terminamos de listar si no hay hijo derecho

                  else 
                        p=p->padre->hijodcha; //cuando salimos del bucle,
                                             //el siguiente es el hermano de p
            }
      }

      return *this;
}
\end{minted}

\noindent
Así, con tres iteradores distintos, hay tres funciones begin y tres funciones end. Las de preorden serían:

\begin{minted}[linenos,firstnumber=200]{c++}
template <class T>
typename ArbolBinario<T>::preorden_iterator ArbolBinario<T>::begin_preorden()const {
      typename ArbolBinario<T>::preorden_iterator nuevo (raiz);
      return nuevo;
}

template <class T>
typename ArbolBinario<T>::preorden_iterator ArbolBinario<T>::end_preorden()const {
      typename ArbolBinario<T>::preorden_iterator nuevo(0);
      return nuevo;
}
\end{minted}
Igualmente para el inorden el operator ++ sería:
\begin{minted}[linenos, firstnumber=168]{c++}
typename ArbolBinario<T>::inorden_iterator & 
            ArbolBinario<T>::inorden_iterator::operator++() {

      if (p==0) //si el arbol es vacio no hay nodos que listar
            return *this;

      if (p->hijodcha != 0) //si tenemos hijo derecha
            p=p->hijodcha  //el siguiente es su hijo derecha

      else {                       //En caso de que no tenga hijoi zquierda
                  while (p->padre != 0 && //mientra p no sea la raiz
                    
                        p->padre->hijodcha == p) // o yo sea el hijo a la derecha
                        p=p->padre; //subimos al padre
                        

                 
                  
            
      }

      return *this;
}
\end{minted}
De la misma forma que con el preorden\_iterador necesitamos dos funciones para iniciar una inorden\_iterator y saber donde termina.

\begin{minted}[linenos,firstnumber=200]{c++}
template <class T>
typename ArbolBinario<T>::inorder_iterator ArbolBinario<T>::begin_inorden()const {
      typename ArbolBinario<T>::inorden_iterator nuevo (raiz);
      return nuevo;
}

template <class T>
typename ArbolBinario<T>::inorden_iterator ArbolBinario<T>::end_inorden()const {
      typename ArbolBinario<T>::inorden_iterator nuevo(0);
      return nuevo;
}
\end{minted}


Y por último para el postorden\_iterator tendríamos:
\begin{minted}[linenos, firstnumber=168]{c++}
typename ArbolBinario<T>::postorden_iterator & 
            ArbolBinario<T>::postorden_iterator::operator++() {

      if (p==0) //si el arbol es vacio no hay nodos que listar
            return *this;
      if (p->padre==0)
       p=0;
      else{
       if (p->padre->hijoizq==p){   //si yo soy el hijo a la izquierda
        if (p->padre->hijodcha!=0){ //si tengo hermano a la derecha
        //buscamos el siguiente por la derecha
         p=p->padre->hijodcha; 
         do{
	    while (p->hizq!=0) p=p->hizq;//avanzamos por la izquierda hasta que sea hoja o con hijo a la derecha
	    if (p->hijodcha!=0) p=p->hijodch;
         }while (p->hijoizq!=0 || p->hijodcha!=0);
                  
            
       }
       else{ //no hay hijo a la derecha
       p= p->padre;
       }
      } 
      else{// yo no soy el hijo a la izquierda entonces seré el hijo a la derecha 
       p= p->padre;
      }
      

      return *this;
}
\end{minted}

\begin{minted}[linenos,firstnumber=200]{c++}
template <class T>
typename ArbolBinario<T>::postorden_iterator ArbolBinario<T>::begin_postorden()const {
      typename ArbolBinario<T>::postorden_iterator nuevo (raiz);
      return nuevo;
}

template <class T>
typename ArbolBinario<T>::postorden_iterator ArbolBinario<T>::end_postorden()const {
      typename ArbolBinario<T>::postorden_iterator nuevo(0);
      return nuevo;
}
\end{minted}



\subsection{\textcolor[rgb]{0.3,0.4,0.8}Arboles generales}
\noindent
Para representar un árbol general, cada nodo contendrá su etiqueta y punteros al padre, al hijo a la izquierda y al hermano a la derecha.:

\begin{minted}[linenos]{c++}
template <class T>
struct info_nodo {
      T et;
      info_nodo<T> * padre, * hijoizq, * hermanodcha;
      info_nodo() {
            padre = hijoizq = hermanodcha = 0;
      }
      infonodo(const T & e) {
            et = e;
            padre = hijoizq = hermanodcha = 0;
      }
}
\end{minted}

\noindent
El siguiente árbol:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{1}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(0,-10)*+=<10mm>[]\txt<2cm>{3}
,(10,-10)*+=<10mm>[]\txt<2cm>{4}

\ar@{-} (0,-2);(-10,-9) % 1 al 2
\ar@{-} (0,-2);(0,-8) % 1 al 3
\ar@{-} (0,-2);(9,-9) % 1 al 4
\end{xy}\]

\noindent
Se representaría de la siguiente forma:
\[\begin{xy}
,(0,0)*+=<10mm>[F]\txt<1cm>{1}
,(10,0)*+=<10mm>[F]\txt<1cm>{0}
,(20,0)*+=<10mm>[F]\txt<1cm>{ }
,(30,0)*+=<10mm>[F]\txt<1cm>{0}
,(-40,-20)*+=<10mm>[F]\txt<1cm>{2}
,(-30,-20)*+=<10mm>[F]\txt<1cm>{ }
,(-20,-20)*+=<10mm>[F]\txt<1cm>{0}
,(-10,-20)*+=<10mm>[F]\txt<1cm>{ }
,(10,-20)*+=<10mm>[F]\txt<1cm>{3}
,(20,-20)*+=<10mm>[F]\txt<1cm>{ }
,(30,-20)*+=<10mm>[F]\txt<1cm>{0}
,(40,-20)*+=<10mm>[F]\txt<1cm>{ }
,(60,-20)*+=<10mm>[F]\txt<1cm>{4}
,(70,-20)*+=<10mm>[F]\txt<1cm>{ }
,(80,-20)*+=<10mm>[F]\txt<1cm>{0}
,(90,-20)*+=<10mm>[F]\txt<1cm>{0}

\ar@{->} (20,-2);(-40,-19) % 1 al 2
\ar@{->} (-30,-19);(0,-2) % 2 al 1
\ar@{->} (-10,-20);(8,-20) % 2 al 3
\ar@{->} (20,-20);(0,-3) % 3 al 1
\ar@{->} (40,-20);(57,-20) % 3 al 4
\ar@{->} (70,-20);(0,-3) % 4 al 1
\end{xy}\]

\noindent
Las funciones asociadas a la parte privada de la clase Arbol General son:

\begin{minted}[linenos,firstnumber=13]{c++}
template <class T>
void Copiar(info_nodo<T>* s, info_nodo<T>* &d) {
      if (s==0)
            d = 0;

      else {
            d = new info_nodo<T>(s->et);
            Copiar(s->hijoizq,d->hijoizq);
            Copiar(s->hermanodcha,d->hermanodcha);
            // le asignamos a los nodos que hemos copiado su padre
            if (d->hijoizq != 0){
                  d->hijoizq->padre=d;
                  for (info_nodo<T> aux = d->hijoizq->hermanodcha;aux!=0;aux= aux->hermanodcha)
                   aux->padre= d;
            }        
      }
}

template<class T>
void Destruir (info_nodo<T>* t) {
      // Debemos empezar con el hermano a la derecha del ultimo nodo hoja
      // del arbol, si no lo hacemos en este orden, perdemos los enlaces.
      // Es decir, para destruir el arbol tenemos que hacerlo en recorrido
      // postorden
      if (t != 0) {
            Destruir(t->hijoizq);         // cada hijo resuelve su destruccion
            Destruir(t->hermanodcha);     // antes de hacer el delete
            delete t;
      }
      // cuando t es cero no entra al if, vuelve a la llamada recursiva
      // y hace el siguiente paso.
}

template <class T>
void InsertarHijoIzquierda (info_nodo<T>* n, info_nodo<T>* &t2) {
      // El hijo a la izquierda de n pasaría a ser el hermano a la derecha
      // de t2
      if (t2 != 0) {
            t2->hermanodcha = n->hijoizq;
            t2->padre=n;
            n->hijoizq=t2;
            t2=0; // ponemos t2 a cero pues ya lo hemos insertado en el
                  // arbol, si lo destruimos, destruimos tambien lo que
                  // hemos insertado en el arbol
      }
}

template <class T>
void InsertarHermanoDerecha (info_nodo<T>* n, info_nodo<T>* &t2) {
      if (t2 != 0) {
            t2->hermanodcha = n->hermanodcha;
            t2->padre = n;
            n->hermanodcha = t2;
            t2 = 0;
      }
}

template <class T>
info_nodo<T>* PodarHijoIzquierda (info_nodo<T>* n) {
      info_nodo<T>* res = 0;  // creamos un nodo auxiliar
      if (n->hijoizq != 0) {
            res = n->hijoizq;       // guardamos en dicho nodo el subarbol hijo izquierda
            n->hijoizq = res->hermanodcha;      // el hijo a la izquierda del padre
                                                // pasa a ser el hermano a la derecha
                                                // del que era hijo a la izquierda
            res->padre = res->hermanodcha=0;    // y el hijo a la izquierda queda como
                                                // la raiz del arbol a devolver
      }

      return res;
}

template <class T>
info_nodo<T>* PodarHermanoDerecha (info_nodo<T>* n) {
      info_nodo<T>* res = 0;
      if (n->hermanodcha != 0) {
            res = n->hermanodcha;   // hacemos lo mismo que en la funcion anterior
            n->hermanodcha = res->hermanodcha;  // pero ahora con el hermano a la
            res->padre = res->hermanodcha = 0;  // derecha
      }

      return res;
}

template <class T>
int altura (info_nodo<T>* t) {
      // las hojas tendran altura cero y la raiz, la altura maxima
      if (t == 0)
            return -1;

      else {
            int max = 1; // como minimo hay un nodo, la raiz
            info_nodo<T>* aux;
            // recorremos los hijos del nodo
            for (aux=t->hijoizq;aux!=0;aux=aux->hermanodcha) {
                  // comprobamos si la altura de los hijos es mayor a la maxima
                  // que tenemos ya calculada
                  int alturahijo = altura(aux); // hacemos una variable local para
                                                // no hacer el calculo dos veces
                  if (alturahijo > max)
                        max = alturahijo;
            }
            return max+1; // la altura de los hijos mas 1, el padre
      }
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Recorridos en árboles generales}
\noindent
Los distintos recorridos del siguiente árbol serían:

\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{1}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(0,-10)*+=<10mm>[]\txt<2cm>{3}
,(10,-10)*+=<10mm>[]\txt<2cm>{4}
,(-20,-20)*+=<10mm>[]\txt<2cm>{5}
,(-15,-20)*+=<10mm>[]\txt<2cm>{6}
,(-10,-20)*+=<10mm>[]\txt<2cm>{7}
,(0,-20)*+=<10mm>[]\txt<2cm>{8}
,(15,-20)*+=<10mm>[]\txt<2cm>{9}
,(20,-20)*+=<10mm>[]\txt<2cm>{10}
,(10,-30)*+=<10mm>[]\txt<2cm>{11}
,(15,-30)*+=<10mm>[]\txt<2cm>{12}
,(20,-30)*+=<10mm>[]\txt<2cm>{13}
,(25,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{-} (0,-2);(-10,-9) % 1 al 2
\ar@{-} (0,-2);(0,-8) % 1 al 3
\ar@{-} (0,-2);(9,-9) % 1 al 4
\ar@{-} (-10,-12);(-20,-19) % 2 al 5
\ar@{-} (-10,-12);(-15,-19) % 2 al 6
\ar@{-} (-10,-12);(-10,-18) % 2 al 7
\ar@{-} (0,-12);(0,-18) % 3 al 8
\ar@{-} (10,-12);(15,-19) % 4 al 9
\ar@{-} (10,-12);(20,-19) % 4 al 10
\ar@{-} (15,-22);(10,-28) % 9 al 11
\ar@{-} (15,-22);(15,-28) % 9 al 12
\ar@{-} (15,-22);(20,-29) % 9 al 13
\ar@{-} (15,-22);(25,-28) % 9 al 14
\end{xy}\]
\end{flushleft}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Preorden}}: 1 2 5 6 7 3 8 4 9 11 12 13 14 10 \\
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Inorden}}: 5 2 6 7 1 8 3 11 9 12 13 14 4 10 \\
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Postorden}}: 5 6 7 2 8 3 11 12 13 14 9 10 4 1 \\
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Niveles}}: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \\
\end{flushleft}
\end{minipage}

\noindent
Y su implementación en C++ sería la siguiente:

\begin{minted}[linenos,firstnumber=118]{c++}
template <class T>
void ListarPreorden (info_nodo<T>* t) {
      if (t != 0) {
            cout << t->et << ' ';   // primero listamos la raiz
            info_ndo<T>* aux;       // y luego sus hijos
            for (aux=t->hijoizq;aux!=0;aux=aux->hermanodcha)
                  ListarPreorden(aux);
      }
}

template <class T>
void ListarInorden (info_nodo<T>* n) {
      if (n != 0) {
            ListarInorden (n->hijoizq); // listamos el hijo a la izquierda
            cout << n->et << ' ';       // despues la raiz
            info_nodo<T>* aux=n->hijoizq;
            if (aux != 0) {
                  aux = aux->hermanodcha;       // y luego los hijos a la
                  while (aux!=0) {              // derecha
                        ListarInorden(aux);
                        aux = aux->hermanodcha;
                  }
            }
      }
}

template <class T>
void ListarPreorden (info_nodo<T>* n) {
      if (n != 0) {
            info_nodo<T>* aux;
            for (aux = n->hijoizq; aux != 0; aux = aux->hermanodcha)
                  ListarPostorden (aux);

            cout << n->et << ' ';
      }
}

// para la siguiente funcion debemos haber hecho en la cabecera un
// #include <queue>
template <class T>
void ListarNiveles (info_nodo<T>* n) {
      // imprimimos un nodo y despues guardamos en la cola a sus hijos
      if (n != 0) {
            queue<info_nodo<T>* > c;
            c.push(n);
            while (!c.empty()) {
                  info_nodo<T>* aux = c.front();
                  c.pop();
                  cout << aux->et << ' ';
                  for (aux=aux->hijoizq;aux!=0;aux=aux->hermanodcha)
                        c.push(aux);
            } // cuando la cola quede vacia se termina el listado por niveles
      }
}

// la siguiente funcion nos devuelve el numero de nodos del arbol
template <class T>
int size (info_nodo<T>* n) {
      if (n == 0)
            return 0;

      else {
            int nt = 1; // al menos hay un nodo
            info_nodo<T>* aux;
            for (aux=n->hijoizq;aux!=0;aux=aux->hermanodcha)
                  nt += size(aux);

            return nt;
      }
}

template <class T>
bool iguales (info_nodo<T>* t1, info_nodo<T>* t2) {
      if (t1==0 && t2==0)
            return true; // ambos son arboles vacios

      else {
            if (t1 == 0 || t2 == 0)
                  return false; // uno es vacio y el otro no

            else {
                  if (t1->et != t2->et)
                        return false;

                  else {
                        info_nodo<T>* aux1, *aux2;
                        bool igual = true;
                        for (aux1=t1->hijoizq;aux2=t2->hijoizq;igual && aux1!=0 && aux2!=0;
                              aux1=aux->hermanodcha;aux2=aux2->hermanodcha) {

                              igual = iguales(aux1,aux2);
                        }
                        // ahora bien, puede ser que un arbol este contenido en otro,
                        // es decir, su tamanio sea diferente, por lo que comprobamos
                        // si los dos han terminado
                        return igual && aux1==0 && aux2==0;
                  }
            }
      }
}
\end{minted}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Arboles parcialmente ordenados (APO)}
\noindent
Son árboles binarios con la condición de que la etiqueta de cada nodo es menor o igual que la etiqueta de sus hijos y además, es un árbol completo, es decir, tiene todos los niveles completos excepto el último donde los huecos están a la derecha.

\noindent
ejemplo: orden lexicográfico

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{e}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
,(-3,-30)*+=<10mm>[]\txt<2cm>{g}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Sus funciones típicas son:
\begin{enumerate}[---]
      \item Insertar
      \item Borrar el mínimo, es decir, la raíz
\end{enumerate}

\noindent
Su representación óptima es un vector. Aunque lo visualicemos como un árbol binario, para representarlo usaremos  un vector con una restrincciones llamado monton(heap) y en él se guarda el árbol por niveles. 
Supongamos un heap  M, entonces debe cumplirse que:
\begin{enumerate}[$\heartsuit$]
      \item M[0] es la raíz
      \item M[1] es el hijo a la izquierda
      \item M[2] es el hijo a la derecha
      \item En general, el nodo k estará en M[k]
      \item Sus hijos, si existen, en los nodos M[2k+1] y M[2k+2]
      \item Y su padre, teniendo en cuenta que $k=2n+1$ donde $n$ es el padre, $n=\frac{k-1}{2}$
\end{enumerate}

\noindent
La representación en un vector del árbol del ejemplo anterior sería:
\[\begin{xy}
,(0,0)*+=<5mm>[F]\txt<0.5cm>{a}
,(5,0)*+=<5mm>[F]\txt<0.5cm>{b}
,(10,0)*+=<5mm>[F]\txt<0.5cm>{c}
,(15,0)*+=<5mm>[F]\txt<0.5cm>{e}
,(20,0)*+=<5mm>[F]\txt<0.5cm>{e}
,(25,0)*+=<5mm>[F]\txt<0.5cm>{e}
,(30,0)*+=<5mm>[F]\txt<0.5cm>{f}
,(35,0)*+=<5mm>[F]\txt<0.5cm>{g}
,(40,0)*+=<5mm>[F]\txt<0.5cm>{h}
,(45,0)*+=<5mm>[F]\txt<0.5cm>{g}
,(50,0)*+=<5mm>[F]\txt<0.5cm>{h}
\end{xy}\]

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Insertar en un APO}
\noindent
Los pasos para insertar un elemento en un APO son:
\begin{enumerate}
      \item Insertamos el elemento en el hueco que haya en el último nivel, si no lo hay creamos un nivel nuevo.
      \item Intercambiamos el nodo con el padre hasta que se cumpla la condición de APO.
\end{enumerate}

\noindent
La eficiencia es de $O(log_2(n))$, ya que en cada cambio dejamos sin analizar la mitad del subárbol.

\noindent
Ejemplo: \\
Insertar el carácter `a' en el siguiente árbol:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{b}
,(-10,-10)*+=<10mm>[]\txt<2cm>{e}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
% ,(-3,-30)*+=<10mm>[]\txt<2cm>{a}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
% \ar@{-} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Lo insertaríamos al lado de la h:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{b}
,(-10,-10)*+=<10mm>[]\txt<2cm>{e}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
,(-3,-30)*+=<5mm>[F]\txt<0.5cm>{a}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{.} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Y ahora lo iríamos comparando e intercambiando con los nodos padre hasta que se cumpliera la condición de APO:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{b}
,(-10,-10)*+=<10mm>[]\txt<2cm>{e}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
,(-3,-30)*+=<5mm>[]\txt<0.5cm>{a}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@/^/@{<<-->>}(0,-2);(-10,-9)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@/_/@{<<-->>} (-10,-12);(-5,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(-3,-28)
\ar@/^/@{<<-->>} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Al final el árbol nos quedaría así:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
,(-3,-30)*+=<5mm>[]\txt<0.5cm>{e}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Una representación de este algoritmo en C++ podría ser:

\begin{minted}[linenos]{c++}
int *datos;       // vector en el que guardamos los nodos
int nelementos;   // tamanio del arbol

datos[nelementos] = x;  // insertamos un elemento en la ultima casilla del vector
nelementos++;           // incrementamos el numero de elementos del vector

// Y ahora empezamos a comparar con el nodo padre hasta que
// se cumpla la condicion de APO
int pos = nelementos-1; 
while (pos > 0 && datos[pos] < datos[(pos-1)/2]) {
      swap (datos[pos],datos[(pos-1)/2]);
      pos = (pos-1)/2;
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Borrar el mínimo (la raíz)}
\noindent
Los pasos para borrar la raíz de un APO son:
\begin{enumerate}
      \item El elemento que se pone en la raíz es el que está en el último nivel más a la derecha.
      \item El más pequeño de los dos hijos de la raíz se intercambia con ésta, así hasta que lleguemos a la condición de APO.
\end{enumerate}

\noindent
La eficiencia de este algoritmo es $O(log_2(n))$ por la misma razón que el algoritmo de insertar un elemento.

\noindent
Ejemplo: \\
Borrar la raíz del siguiente árbol:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{a}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}
,(-3,-30)*+=<10mm>[]\txt<2cm>{e}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\ar@{-} (-5,-22);(-3,-28)
\end{xy}\]

\noindent
Colocamos en la raíz el elemento más a la derecha en el último nivel, es decir, la `e':

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{e}
,(-10,-10)*+=<10mm>[]\txt<2cm>{b}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}

\ar@{-} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\end{xy}\]

\noindent
Y ahora intercambiamos la `e' por el menor hijo de la raíz, que en este caso sería la `b'. Con este árbol en concreto ya tenemos el ejercicio hecho, pero si al cambiar la `b' por la `e', `b' tuviera un hijo menor que `e', tendríamos que volver a repetir la operación:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{b}
,(-10,-10)*+=<10mm>[]\txt<2cm>{e}
,(10,-10)*+=<10mm>[]\txt<2cm>{c}
,(-15,-20)*+=<10mm>[]\txt<2cm>{g}
,(-5,-20)*+=<10mm>[]\txt<2cm>{e}
,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{f}
,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{h}

\ar@{-} (0,-2);(-10,-9)
\ar@/^/@{<-->} (0,-2);(-10,-9)
\ar@{-} (0,-2);(9,-8)
\ar@{-} (-10,-12);(-15,-18)
\ar@{-} (10,-12);(5,-18)
\ar@{-} (10,-12);(15,-18)
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18)
\ar@{-} (-5,-22);(-10,-28)
\end{xy}\]

\noindent
Una representación de este algoritmo en C++ sería:

\begin{minted}[linenos, firstnumber=14]{c++}
datos[0] = datos[nelementos-1];     // colocamos en la raiz el ultimo nodo del arbol
nelementos--;     // y lo eliminamos
int ultimo = nelementos-1;
int pos = 0;
bool acabar = false;

while (pos <= (ultimo-1)/2 && !acabar) {
      int pos_min;
      // este primer if-else sirve para saber cual de los dos hijos es menor
      // y asi saber cual intercambiar con el nodo superior
      if ((pos*2)+1 == ultimo) // si es el hijo a la izquierda y el unico hijo
            pos_min = ultimo;

      else {
            if (datos[2*pos+1] < datos[2*pos+2]) // si tenemos mas hijos
            // si el hijo a la izquierda es menor
                  pos_min = (2*pos)+1;

            else // el hijo a la derecha es menor
                  pos_min = (2*pos)+2;
      }

      // una vez calculado el hijo menor, si es menor que su padre los
      // intercambiamos
      if (datos[pos] > datos[pos_min]) {
            swap(datos[pos], datos[pos_min]);
            pos= pos_min; // actualizamos el valor de pos min para la
                          // siguiente iteracion
      }

      else // ya se cumple la condicion de APO
            acabar = true;
}
\end{minted}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Arboles binarios de búsqueda (ABB)}
\noindent
Árbol binario con las etiquetas ordenadas de forma que el elemento situado en un nodo es mayor que todos los elementos que se encuentran en el subárbol izquierdo y menor que los que se encuentran en el subárbol derecho. En general, si nos fijamos en un nodo, su hijo izquierdo es menor y el derecho mayor. Aplicándolo recursivamente llegamos a que el sunárbol izquierdo es menor y el subárbol derecho es mayor.

\noindent
Por ejemplo:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{8}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
%,(5,-20)*+=<10mm>[]\txt<2cm>{e}
,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{-} (0,-2);(-10,-9) % 8 al 4
\ar@{-} (0,-2);(9,-8) % 8 al 12
\ar@{-} (-10,-12);(-15,-18) % 4 al 2
%\ar@{-} (10,-12);(5,-18) 
\ar@{-} (10,-12);(15,-18) % 12 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 4 al 6
\ar@{-} (-5,-22);(-10,-28) % 6 al 5
\ar@{-} (15,-22);(10,-28) % 15 al 14
\end{xy}\]

\noindent
Como se puede ver, el $4$ es menor al $8$, y el $12$ es mayor. Dentro del subárbol con raíz $4$, el $2$ es menor al $4$ y el $6$ es mayor y así con todos.

\noindent
Ejemplo: si nos dan las siguientes etiquetas, ¿cómo podemos obtener el ABB?
\begin{displaymath}
\{10, 5, 14, 7, 12, 3, 19, 8, 6\}
\end{displaymath}

\begin{enumerate}[$\bigstar$]
      \item El primer elemento del conjunto de etiquetas, $10$, es la raíz. Su hijo izquierdo sería el $5$ ya que es menor que 10 y, el derecho sería $14$.
      \item Dentro del subárbol con raíz $5$, debemos buscar en el conjunto de números un número menor a $5$, que en este caso sería el $3$ y otro, mayor a $5$ y menor que $14$ que sería el $7$.
      \item Con el subárbol con raíz $14$ hacemos lo mismo.
      \item Así, para insertar el $6$ en el árbol debemos ir nodo por nodo viendo si tirar para la derecha o la izquierda. Los pasos serían:
      \begin{enumerate}
            \item $6 < 10$ $\longrightarrow$ tiramos a la izquierda
            \item $6 > 5$ $\longrightarrow$ tiramos al subárbol derecho
            \item $6 < 7$ $\longrightarrow$ como no tiene hijo izquierdo, ponemos a $6$ como hijo izquierdo.
      \end{enumerate}
\end{enumerate}

\noindent
El ABB resultado sería este: \label{ejemplo_abb}

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{10}
,(-10,-10)*+=<10mm>[]\txt<2cm>{5}
,(10,-10)*+=<10mm>[]\txt<2cm>{14}
,(-15,-20)*+=<10mm>[]\txt<2cm>{3}
,(-5,-20)*+=<10mm>[]\txt<2cm>{7}
,(5,-20)*+=<10mm>[]\txt<2cm>{12}
,(15,-20)*+=<10mm>[]\txt<2cm>{19}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{6}
,(-5,-30)*+=<10mm>[]\txt<2cm>{8}
%,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 19
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 3
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (-5,-22);(-5,-28)
\end{xy}\]

\noindent
La eficiencia de la búsqueda en un ABB sería de $log_2 (n)$, ya que nos dejamos la mitad del árbol sin recorrer, aunque en el peor de los casos (el árbol sólo tiene una rama, hijo izquierdo o derecho) la eficiencia sería $O(n)$.

\noindent
El recorrido inorden ordena las etiquetas de menor a mayor. Por ejemplo, el recorrido inorden el árbol calculado en el \hyperref[ejemplo_abb]{ejemplo anterior} sería:
\begin{displaymath}
3 \quad\ 5 \quad\ 6 \quad\ 7 \quad\ 8 \quad\ 10 \quad\ 12 \quad\ 14 \quad\ 19
\end{displaymath}

\noindent
El tipo set de la STL está implementado con un árbol binario de búsqueda.

\noindent
La representación de un ABB en C++ sería:

\begin{minted}[linenos]{c++}
template <class T>
struct info_nodo {
      T et;
      info_nodo<T> * padre, * hijoizq, * hijoder;
};

// funcion que busca en un ABB una etiqueta, si no esta devuelve 0
template <class T>
info_nodo<T> * Buscar (info_nodo<T> * n, T x) {
      if (n != 0) {
            if (n->et == x)
                  return n;

            else {
                  if (n->et > x)
                        return Buscar (n->hijoizq, x);

                  else
                        return Buscar (n->hijoder, x);
            }
      }

      else // la etiqueta no esta en el arbol
            return 0;
}

// misma funcion pero de forma iterativa
info_nodo<T> * Buscar (info_nodo<T> * n, T x) {
      if (n == 0)
            return 0;

      else {
            info_nodo<T> * p = n; // variable para recorrer el arbol
            while (p != 0) {
                  if (p->et == x)
                        return p;

                  else {
                        if (p->et > x)
                              p = p->hijoizq;

                        else
                              p = p->hijoder;
                  }
            }

            return 0; // salimos del while sin haberlo encontrado
      }
}
/* La version iterativa es mas rapida que la recursiva ya que la recursiva guarda 
contextos de las llamadas y por tanto es mucho mas costosa */
\end{minted}

\noindent
El algoritmo de inserción consiste en buscar donde insertar el elemento que queremos insertar e insertarlo ahí.

\noindent
Por ejemplo, para insertar $x = 7$ en el siguiente árbol:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{8}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
%,(5,-20)*+=<10mm>[]\txt<2cm>{e}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
%,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{-} (0,-2);(-10,-9) % 8 al 4
\ar@{-} (0,-2);(9,-8) % 8 al 12
\ar@{-} (-10,-12);(-15,-18) % 4 al 2
%\ar@{-} (10,-12);(5,-18) 
%\ar@{-} (10,-12);(15,-18) % 12 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 4 al 6
\ar@{-} (-5,-22);(-10,-28) % 6 al 5
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\end{xy}\]

\noindent
Seguiríamos el siguiente razonamiento lógico:

\begin{enumerate}[$\bigstar$]
      \item $7 < 8$ $\longrightarrow$ voy al subárbol izquierdo
      \item $7 > 4$ $\longrightarrow$ voy al subárbol derecho
      \item $7 > 6$ $\longrightarrow$ voy al subárbol derecho que está vacío, como está vacío, inserto el $7$ aquí.
\end{enumerate}

\noindent
Y quedaría así:

\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{8}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
%,(5,-20)*+=<10mm>[]\txt<2cm>{e}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
%,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{-} (0,-2);(-10,-9) % 8 al 4
\ar@{-} (0,-2);(9,-8) % 8 al 12
\ar@{-} (-10,-12);(-15,-18) % 4 al 2
%\ar@{-} (10,-12);(5,-18) 
%\ar@{-} (10,-12);(15,-18) % 12 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 4 al 6
\ar@{-} (-5,-22);(-10,-28) % 6 al 5
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (-5,-22);(-5,-28) % 5 al 7
\end{xy}\]

\noindent
La implementación en C++ sería:

\begin{minted}[linenos,firstnumber=52]{c++}
// Devuelve true o false si se ha podido insertar x o no
template <class T>
bool Insertar (info_nodo<T> * & n, T x) {
      bool res = false;
      if (n == 0) {
            n = new info_nodo<T> (x);
            return true;
      }

      else {
            if (n->et < x) {
                  res = Insertar (n->hijoder,x);
                  if (res)
                        n->hijoder->padre = n;

                  return res;
            }

            else {
                  if (n->et > x) {
                        res = Insertar(n->hijoizq,x);
                        if (res)
                              n->hijoizq->padre = n;

                        return res;
                  }
                  else // la etiqueta es x, no se puede insertar
                        return false;
            }
      }
}
\end{minted}

\noindent
Para el algoritmo de borrado, tenemos tres posibilidades:
\begin{description}
\item[Primera posibilidad]: el \verb*|info_nodo| de x es una hoja. En cuyo caso, simplemente eliminamos dicho nodo. El código correspondiente sería:
\begin{minted}{c++}
info_nodo<T>* aux = n;
// suponiendo que n apunta a x
if (aux->padre != 0) {
      if (aux->padre->hijoder == n)
            aux->padre->hijoder = 0;

      else
            aux->padre->hijoizq = 0;
}

delete aux;
\end{minted}

\item[Segunda posibilidad]: el nodo no es hoja. En este caso, se subdivide en otros tres casos:
\begin{enumerate}[a)]
      \item \textbf{\textcolor[rgb]{0.3,0.4,0.8}{Que sólo tenga hijo a la derecha}}, en cuyo caso se pondría en el lugar de n, su hijo a la derecha:
\begin{minted}{c++}
info_nodo<T> * padre = n->padre;
if (padre != 0) {
      if (padre->hijoder == n) {
            padre->hijoder = n->hijoder;
            padre->hijoder->padre = padre;
      }

      else {
            if (padre->hijoizq == n) {
                  padre->hijoizq = n->hijoder;
                  padre->hijoizq->padre = padre;
            }
      }
}

info_nodo<T> * aux = n;
n = n->hijoder;
delete aux;
\end{minted}

\item \textbf{\textcolor[rgb]{0.3,0.4,0.8}{Que sólo tenga hijo a la izquierda}}, en cuyo caso se pondría en el lugar de n, su hijo a la izquierda:
\begin{minted}{c++}
info_nodo<T> * padre = n->padre;
if (padre != 0) {
      if (padre->hijoizq == n) {
            padre->hijoizq = n->hijoizq;
            padre->hijoizq = padre->padre;
      }

      else {
            if (padre->hijoder == n) {
                  padre->hijoder = n->hijoizq;
                  padre->hijoder->padre = padre;
            }
      }
}

info_nodo<T> * aux = n;
n = n->hijoizq;
delete aux;
\end{minted}

\item \textbf{\textcolor[rgb]{0.3,0.4,0.8}{Que tenga dos hijos}}, en cuyo caso tenemos que sustituir el nodo por su ``siguiente'', es decir, el siguiente nodo con más valor. Para obtener dicho ``siguiente'' debemos seguir los siguientes pasos:
\begin{enumerate}[1.]
      \item Nos movemos hacia el hijo a la derecha de $n$.
      \item Después, nos movemos hacia el hijo a la izquierda del hijo a la derecha de $n$
      \item Vamos moviéndonos por todos los hijos a la izquierda hasta llegar a un nodo que no tenga más hijos a la izquierda. Puede ser una hoja (no tener hijos) o tener hijo a la derecha.
      \item Cuando llegamos a dicho nodo, cambiamos el valor de la etiqueta de $n$ por el del nodo y borramos el nodo siguiendo la posibilidad 1 (no tener hijos) o la posibilidad 2, caso 1 (tener hijo derecho).
\end{enumerate}

\noindent
Por ejemplo, queremos borrar el nodo con etiqueta $5$. El árbol de la izquierda representa el antes y el de la derecha el después:

\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{10}
,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{5}
,(10,-10)*+=<10mm>[]\txt<2cm>{14}
,(-15,-20)*+=<10mm>[]\txt<2cm>{3}
,(-5,-20)*+=<10mm>[]\txt<2cm>{7}
,(5,-20)*+=<10mm>[]\txt<2cm>{12}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{6}
,(-5,-30)*+=<10mm>[]\txt<2cm>{8}
%,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
%\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (-5,-22);(-5,-28) % 7 al 8
\end{xy}\]
\end{minipage}
\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{10}
,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{6}
,(10,-10)*+=<10mm>[]\txt<2cm>{14}
,(-15,-20)*+=<10mm>[]\txt<2cm>{3}
,(-5,-20)*+=<10mm>[]\txt<2cm>{7}
,(5,-20)*+=<10mm>[]\txt<2cm>{12}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
%,(-10,-30)*+=<10mm>[]\txt<2cm>{6}
,(-5,-30)*+=<10mm>[]\txt<2cm>{8}
%,(10,-30)*+=<10mm>[]\txt<2cm>{14}

\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
%\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
%\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (-5,-22);(-5,-28) % 7 al 8
\end{xy}\]
\end{minipage}

\noindent
Otro ejemplo, en el que ahora el nodo con el que vamos a hacer el cambio no es una hoja, sino que sólo tiene un hijo a la derecha. El resultado final sería sustituir $n$ por el nodo sin hijo izquierdo que hemos encontrado y al borrar éste nodo, dejamos como hijo izquierdo de su padre, a su hijo derecho:

\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{15}
,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{10}
,(10,-10)*+=<10mm>[]\txt<2cm>{17}
,(-15,-20)*+=<10mm>[]\txt<2cm>{7}
,(-5,-20)*+=<10mm>[]\txt<2cm>{14}
,(5,-20)*+=<10mm>[]\txt<2cm>{16}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
%,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{12}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{8}
%,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(-5,-40)*+=<10mm>[]\txt<2cm>{13}

\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
%\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
%\ar@{-} (-5,-22);(-5,-28) % 7 al 8
\ar@{-} (-10,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{15}
,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{12}
,(10,-10)*+=<10mm>[]\txt<2cm>{17}
,(-15,-20)*+=<10mm>[]\txt<2cm>{7}
,(-5,-20)*+=<10mm>[]\txt<2cm>{14}
,(5,-20)*+=<10mm>[]\txt<2cm>{16}
%,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
%,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{13}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{8}
%,(10,-30)*+=<10mm>[]\txt<2cm>{13}
%,(-5,-40)*+=<10mm>[]\txt<2cm>{13}

\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 13
%\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
%\ar@{-} (-5,-22);(-5,-28) % 7 al 8
%\ar@{-} (-10,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\end{enumerate} 
\end{description}

\noindent
Así, el algoritmo de borrar final, y las funciones auxiliares que necesita, quedarían:
\begin{minted}[linenos,firstnumber=83]{c++}
// funcion que enlaza un hijo con su padre
template <class T>
void PutHijo_Padre(info_nodo *n, info_nodo *nuevo){
      if (n->padre!=0){
            if (nuevo!=0)     // no tiene padre
                  nuevo->padre = n->padre; 

            if (n->padre->hder==n)  // el padre de n tendra como hijo a 
                  n->padre->hder = nuevo; // su hijo a la derecha

            else        // el padre de n tendra como hijo a su hijo a la izquierda
                  n->padre->hizq=nuevo;
                      
      }
}

// En esta funcion es donde encapsulamos cada uno de los casos que hemos visto por
// separado y donde se borra el nodo que queremos borrar.             
template <class T>
void EliminarRaiz(info_nodo *&n){
      if (n->hizq==0 && n->hder==0){      // Posibilidad 1: n no tiene hijos
                  PutHijo_Padre(n,0);     // establecemos su padre a 0
                  delete n; n=0;          // lo borramos
      }

      else if (n->hizq==0){               // Posibilidad 2, CASO 1: n tiene hijo derecho
            info_nodo *aux=n;             // Establecemos como hijo del padre de n, el
            PutHijo_Padre(n,n->hder);     // hijo a la derecha de n
            if (n->padre==0)              // si n es la raiz
                  n= n->hder;             // La raiz del arbol ahora es su hijo derecho
            delete aux;aux=0;             // Eliminamos n
                    
      }
      else if (n->hder==0){               // Posibilidad 2, CASO 2: n tiene hijo izquierdo
            info_nodo *aux=n;             // Procedemos igual que en la funcion anterior
            PutHijo_Padre(n,n->hizq);
            if (n->padre==0) 
                  n = n->hizq;
            delete aux; aux=0;
                    
      }
      else{                               // Posibilidad 2, CASO 3: n tiene dos hijos
                                          // Buscamos el siguiente: 
            info_nodo *aux=n->hder;       // Nos movemos al hijo a la derecha
            while (aux->hizq!=0)          // Avanzamos hasta que llegamos a un nodo
                  aux=aux->hizq;          // que no tiene hijo a la izquierda
                                          // OJO: no tiene por que ser una hoja
            n->et=aux->et;                // y cambiamos la etiqueta de n por la del nodo
            Borrar(n->hder,aux->et);      // y por ultimo, borramos este nodo.
      }
        
}

// Funcion que llama a EliminarRaiz para borrar alguna componente del arbol
template <class T>
void Borrar(info_nodo * &n,const T &e){
      if (n!=0){
            if (n->et==e)                 // Si encontramos la raiz del subarbol que
                  EliminarRaiz(n);        // queremos borrar, lo borramos
            else if (n->et<e)             // si el nodo que queremos borrar es mayor
                  Borrar(n->hder,e);      // o menor que la raiz del subarbol actual,
            else                          // nos movemos a la izquierda o a la derecha
                  Borrar(n->hizq,e);      // recursivamente hasta encontrarlo.
      }
}
\end{minted}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Arboles binarios de búsqueda AVL (Adelson-Velskii y Landis)}
\noindent
Son árboles de búsqueda equilibrados. Si un ABB está muy desequilibrado, los tiempos de búsqueda no son $log_2 (n)$, en el peor de los casos podría ser $O(n)$.
Lo ideal sería que ambas partes tuvieran más o menos el mismo número de nodos para que en cada iteración, descartar la mitad de nodos del árbol y por tanto, 
de verdad tener un tiempo de búsqueda $log_2 (n)$.

\noindent
Se dice que un ABB es AVL si la diferencia de altura de los subárboles izquierdo ($T_i$) y derecho ($T_d$) que cuelgan de un nodo es como mucho $1$. Es decir, si $T_i$ tiene altura $h$, $T_d$ puede tener como máximo altura $h+1$ y viceversa.

\noindent
Si no recuerdas lo que era la altura, repasa la \hyperref[def_altura]{definición} que se dió en su día.

\noindent
Ejemplos:

\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{8}
%,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{x}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
,(5,-20)*+=<10mm>[]\txt<2cm>{10}
,(15,-20)*+=<10mm>[]\txt<2cm>{15}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{g}
%,(-15,-30)*+=<10mm>[]\txt<2cm>{h}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(-5,-30)*+=<10mm>[]\txt<2cm>{x}
%,(10,-30)*+=<10mm>[]\txt<2cm>{13}
%,(-5,-40)*+=<10mm>[]\txt<2cm>{13}

%\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{.} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{.} (-5,-22);(-5,-28) % 7 al 8
%\ar@{-} (-10,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{enumerate}[$\bigstar$]
      \item Los nodos que no existen ($x$) tienen altura $h=-1$
      \item Los hoja tienen altura $h=0$
      \item 6 tiene altura 1, ya que sería la altura máxima de sus hijos más 1.
      \item Tenemos un desequilibrio en el 4, ya que sus hijos tienen $h_1 = -1$ y $h_2 = 1$, la altura de ambos difiere en más de 1, por lo que no es AVL.
\end{enumerate}
\end{minipage}

\begin{minipage}{0.6\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{10}
%,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
%,(5,-20)*+=<10mm>[]\txt<2cm>{10}
,(15,-20)*+=<10mm>[]\txt<2cm>{15}
,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
%,(10,-30)*+=<10mm>[]\txt<2cm>{13}
%,(-5,-40)*+=<10mm>[]\txt<2cm>{13}

%\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-2);(-10,-9) % 10 al 5
\ar@{-} (0,-2);(9,-8) % 10 al 14
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
%\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
%\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (-5,-22);(-5,-28) % 7 al 8
%\ar@{-} (-10,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{enumerate}[$\bigstar$]
      \item Este árbol si está equilibrado, aunque no tengamos el mismo número de nodos en $T_i$ y $T_d$ ya que se cumple la definición de AVL.
\end{enumerate}
\end{minipage}

\noindent
La representación en C++ sería:
\begin{minted}[linenos]{c++}
template <class T>
struct info_nodo_AVL {
      T et;
      info_nodo_AVL<T> * hijoizq, * hijoder, * padre;
      int altura;
};

// El proceso de busqueda es identico al ABB normal.
\end{minted}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Inserción}
\noindent
En el proceso de inserción podemos desequilibrar el árbol, por tanto, debemos volver a hacer que esté equilibrado. Por tanto los pasos a seguir para insertar un elemento en un ABB AVL serían:
\begin{enumerate}
      \item Buscar dónde insertar el nuevo elemento
      \item Insertarlo
      \item Equilibrar el árbol
\end{enumerate}

\noindent
Vamos a dividirlo en varios casos:

\begin{center}
\[\begin{xy}
,(0,0)*+=[o]=<0.5cm>[F]\txt<0.5cm>{r}
%,(-15,-5)*+=<10mm>[]\txt<2cm>{n}
,(-10,-10)*+=[o]=<0.5cm>[F]\txt<2cm>{$r_i$}
,(10,-10)*+=[o]=<0.5cm>[F]\txt<2cm>{$r_d$}
,(-15,-20)*+=[o]=<0.5cm>[F]\txt<2cm>{a}
,(-5,-20)*+=[o]=<0.5cm>[F]\txt<2cm>{b}
,(5,-20)*+=[o]=<0.5cm>[F]\txt<2cm>{c}
,(15,-20)*+=[o]=<0.5cm>[F]\txt<2cm>{d}
,(-16,-27)*+=<0.5cm>[]\txt<1cm>{A}
,(-6,-27)*+=<0.5cm>[]\txt<1cm>{B}
,(15,-27)*+=<0.5cm>[]\txt<1cm>{D}
,(4,-27)*+=<0.5cm>[]\txt<1cm>{C}
%,(-20,-30)*+=<5mm>[]\txt<2cm>{A}
%,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
% ,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
%,(10,-30)*+=<10mm>[]\txt<2cm>{13}
%,(-5,-40)*+=<10mm>[]\txt<2cm>{13}

%\ar@{->} (-15,-7);(-12,-10)
\ar@{-} (0,-3);(-10,-7) % 10 al 5
\ar@{-} (0,-3);(9,-8) % 10 al 14
\ar@{-} (-10,-13);(-15,-18) % 5 al 3
\ar@{-} (10,-13);(5,-18) % 14 al 12
\ar@{-} (10,-13);(15,-18) % 14 al 15
\ar@{-} (-15,-23);(-20,-30)
\ar@{-} (-15,-23);(-13,-30)
\ar@{-} (-20,-30);(-13,-30)
\ar@{-} (-10,-13);(-5,-18) % 5 al 7
\ar@{-} (-5,-23);(-10,-30) % 7 al 6
\ar@{-} (15,-23);(10,-30) % 15 al 14
\ar@{-} (15,-23);(20,-30)
\ar@{-} (10,-30);(20,-30)
\ar@{-} (-5,-23);(-3,-30) % 7 al 8
\ar@{-} (-10,-30);(-3,-30)
\ar@{-} (5,-23);(0,-30)
\ar@{-} (5,-23);(8,-30)
\ar@{-} (0,-30);(8,-30)
%\ar@{-} (-10,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{center}

\begin{center}
{\tiny CASO A CASO B $\quad\ $ CASO C CASO D}
\end{center}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Rotaciones simples}
\begin{description}
    \item[CASO A]: El desequilibrio se produce al insertar un nuevo elemento  en la parte más a la izquierda del árbol. Para equilibrarlo de nuevo, se hace una \textit{\textcolor[rgb]{0.3,0.4,0.8}{rotación simple a la derecha}}. Por ejemplo:

    \[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{7}
	,(15,-5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
	,(10,-10)*+=<10mm>[]\txt<2cm>{14}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
	,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
	,(5,-20)*+=<10mm>[]\txt<2cm>{12}
	,(15,-20)*+=<10mm>[]\txt<2cm>{15}
	,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
	,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
	,(0,-30)*+=<10mm>[]\txt<2cm>{11}
	,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	\ar@{->} (15,-7);(12,-10)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	\ar@{-} (-15,-22);(-20,-28)
	\ar@{-} (-15,-22);(-15,-28)
	\ar@{-} (-10,-12);(-5,-18) % 5 al 7
	\ar@{-} (-5,-22);(-10,-28) % 7 al 6
	\ar@{-} (5,-22);(0,-28)
	\ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	\ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	En este caso, el desequilibrio está en 14, pues la altura de 12 es $h=2$ y la de 15, $h=1$. Al hacer la rotación simple a la derecha, el árbol queda ya equilibrado:

    \[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{7}
	% ,(15,-5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
	,(10,-10)*+=<10mm>[]\txt<2cm>{12}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
	,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
	,(5,-20)*+=<10mm>[]\txt<2cm>{11}
	,(15,-20)*+=<10mm>[]\txt<2cm>{14}
	,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
	,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
	,(0,-30)*+=<10mm>[]\txt<2cm>{10}
	,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	,(20,-30)*+=<10mm>[]\txt<2cm>{15}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (15,-7);(12,-10)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	\ar@{-} (-15,-22);(-20,-28)
	\ar@{-} (-15,-22);(-15,-28)
	\ar@{-} (-10,-12);(-5,-18) % 5 al 7
	\ar@{-} (-5,-22);(-10,-28) % 7 al 6
	\ar@{-} (5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	\ar@{-} (15,-22);(10,-28) % 15 al 14
	\ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	El algoritmo sería:
\begin{minted}[linenos,firstnumber=9]{c++}
template <class T>
void SimpleDerecha (info_nodo_AVL<T> * & n) { // n = 14 en el ejemplo
	info_nodo_AVL<T> * aux = n->hijoizq; // 12 en el ejemplo
	info_nodo_AVL<T> * padre = n->padre; // 7
	n->hijoizq = aux->hijoder; // a 14 le ponemos como hijo izquierdo 13
	if (n->hijoizq != 0)
		n->hijoizq->padre = n;	// el padre de 13 pasa a ser 14

	n->padre = aux;	//  el padre de 14 pasa a ser 12
	aux->padre = padre;		// el padre de 12 es 7
	aux->hder = n;		// 12 tiene como hijo derecho a 14
	n = aux;
	ActualizarAltura(n->hder);
}

// Esta funcion Actualiza el campo n->altura
template <class T>
void ActualizarAltura (info_nodo_AVL<T> * & n) {
	if (n != 0) {
		n->altura = std::max(Altura(n->hijoizq), Altura(n->hijoder))+1;
		// La funcion Altura devuelve n->altura si es 
		// distinta de 0 y -1 si es 0
		ActualizarAltura(n->padre);
	}
}
\end{minted}

	\item[CASO D]: El nodo que produce el desequilibrio se inserta en el subárbol D, para arreglarlo, se hace una \textit{\textcolor[rgb]{0.3,0.4,0.8}{rotación simple a la izquierda}}. Por ejemplo:
    \[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{10}
	,(7,10)*+=<10mm>[]\txt<2cm>{$h=2$}
	%,(-10,-10)*+=<10mm>[]\txt<2cm>{$x$}
	,(10,-10)*+=<10mm>[]\txt<2cm>{11}
	,(15,-20)*+=<10mm>[]\txt<2cm>{12}

	\ar@{<-} (5,8);(0,2);
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	%\ar@{.} (0,-2);(-10,-8)
	\ar@{-} (10,-12);(15,-18) % 14 al 12
	\end{xy}\]

	\noindent
	En este caso, el desequilibrio se encuentra en 10. El árbol, una vez equilibrado haciendo rotación simple a la izquierda quedaría así:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{11}
	% ,(7,10)*+=<10mm>[]\txt<2cm>{$h=2$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{10}
	,(10,-10)*+=<10mm>[]\txt<2cm>{12}
	% ,(15,-20)*+=<10mm>[]\txt<2cm>{12}

	% \ar@{<-} (5,8);(0,2);
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (0,-2);(-10,-8)
	% \ar@{-} (10,-12);(15,-18) % 14 al 12
	\end{xy}\]

	\noindent
	Un ejemplo más complejo sería:
	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{2}
	,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{1}
	,(10,-10)*+=<10mm>[]\txt<2cm>{4}
	% ,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
	% ,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
	,(5,-20)*+=<10mm>[]\txt<2cm>{3}
	,(15,-20)*+=<10mm>[]\txt<2cm>{5}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{10}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	\ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	\ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	En este caso el desequilibrio estaría en el 2, ya que su hijo derecho tiene altura $h=2$ y el izquierdo, $h=0$. Se resolvería haciendo una rotación simple a la izquierda:
	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{4}
	% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
	,(10,-10)*+=<10mm>[]\txt<2cm>{5}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
	,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
	% ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
	,(15,-20)*+=<10mm>[]\txt<2cm>{6}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{10}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	% \ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	\ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	El 3 se pone como hijo a la derecha de 2 para mantener la condición de ABB. La implementación en C++ sería:

\begin{minted}[linenos,firstnumber=34]{c++}
template <class T>
void SimpleIzquierda (info_nodo_AVL<T> * & n) { // n = 2
	info_nodo_AVL<T> * aux = n->hijoder;	// 4 en el ejemplo
	info_nodo_AVL<T> * padre = n->padre;	// nulo
	n->hder = aux->hijoizq; // a 2 se le pone a 3 como hijo derecho
	if (n->hder!=0)
		n->hder->padre = n;		// el padre de 3 pasa a ser 2

	n->padre = aux;		// el padre de 2 es 4
	aux->padre = padre;	// el padre de 4 es nulo, porque es la raiz
	aux->hijoizq = n;	// el hijo izquierdo de 4 es 2
	n = aux;
	ActualizarAltura(n->hijoizq);
}
\end{minted}
\end{description}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Rotaciones dobles}
\begin{description}
	\item[CASO B]: el desequilibrio se produce al insertar un nodo en el subárbol b. Para equilibrar el árbol debemos seguir dos pasos:
	\begin{enumerate}
	 	\item Hacer una rotación simple a la izquierda sobre el hijo izquierdo del nodo donde se produzca el desequilibrio
	 	\item Hacer una rotación simple a la derecha sobre el nodo donde surge el desequilibrio.
	\end{enumerate}

	\noindent
	Por ejemplo:
	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{100}
	,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{50}
	,(10,-10)*+=<10mm>[]\txt<2cm>{200}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{35}
	,(-5,-20)*+=<10mm>[]\txt<2cm>{54}
	% ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
	% ,(15,-20)*+=<10mm>[]\txt<2cm>{6}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	\ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	% \ar@{-} (10,-12);(5,-18) % 14 al 12
	% \ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	\ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	\ar@{-} (-5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	El desequilibrio se da en el nodo con etiqueta 100, en este caso, para equilibrarlo debemos dar dos pasos. En primer lugar debemos hacer una rotación simple a la izquierda en el nodo de etiqueta 50:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{100}
	% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{54}
	,(10,-10)*+=<10mm>[]\txt<2cm>{200}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{50}
	,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
	% ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
	% ,(15,-20)*+=<10mm>[]\txt<2cm>{6}
	,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	% \ar@{-} (10,-12);(5,-18) % 14 al 12
	% \ar@{-} (10,-12);(15,-18) % 14 al 15
	\ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	\ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (-5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	Pero, el árbol aún no está equilibrado, falta el último paso que sería hacer una rotación simple a la derecha sobre 100:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{54}
	% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{50}
	,(10,-10)*+=<10mm>[]\txt<2cm>{100}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{35}
	% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
	,(5,-20)*+=<10mm>[]\txt<2cm>{56}
	,(15,-20)*+=<10mm>[]\txt<2cm>{200}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (-5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	La rotación doble consistiría, por tanto, en llamar a las funciones de rotación simples pasando como argumento los nodos correspondientes:

\begin{minted}[linenos,firstnumber=48]{c++}
template <class T>
void Doble_IzquierdaDerecha (info_nodo_AVL<T> * & n) {
	SimpleIzquierda (n->hijoizq);
	SimpleDerecha(n);
}
\end{minted}

	\item[CASO C:] es equivalente pero hay que hacerlo al contrario, es decir, los pasos a seguir serían:
	\begin{enumerate}
		\item Hacer una rotación simple a la derecha sobre el hijo derecho del nodo que tenga desequilibrio
		\item Y hacer una rotación simple a la izquierda sobre el dicho nodo.
	\end{enumerate}

	\noindent
	Por ejemplo:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{6}
	,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{5}
	,(10,-10)*+=<10mm>[]\txt<2cm>{14}
	% ,(-15,-20)*+=<10mm>[]\txt<2cm>{35}
	% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
	,(5,-20)*+=<10mm>[]\txt<2cm>{7}
	,(15,-20)*+=<10mm>[]\txt<2cm>{15}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{6}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	\ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (-5,-22);(0,-28)
	\ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	El desequilibrio está en el nodo de etiqueta 6, para equilibrar el árbol debemos hacerlo en dos pasos. En primer lugar, haremos una rotación simple a la derecha sobre 14:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{6}
	% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{5}
	,(10,-10)*+=<10mm>[]\txt<2cm>{7}
	% ,(-15,-20)*+=<10mm>[]\txt<2cm>{35}
	% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
	% ,(5,-20)*+=<10mm>[]\txt<2cm>{7}
	,(15,-20)*+=<10mm>[]\txt<2cm>{14}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	,(20,-30)*+=<10mm>[]\txt<2cm>{15}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
	% \ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (-5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	\ar@{-} (15,-22);(10,-28) % 15 al 14
	\ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	Y por último, hacemos una rotación simple a la izquierda sobre el nodo desequilibrado, 6:

	\[\begin{xy}
	,(0,0)*+=<10mm>[]\txt<2cm>{7}
	% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
	,(-10,-10)*+=<10mm>[]\txt<2cm>{6}
	,(10,-10)*+=<10mm>[]\txt<2cm>{14}
	,(-15,-20)*+=<10mm>[]\txt<2cm>{5}
	% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
	,(5,-20)*+=<10mm>[]\txt<2cm>{13}
	,(15,-20)*+=<10mm>[]\txt<2cm>{15}
	% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
	% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
	%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
	% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
	% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

	% \ar@{->} (5,3);(0,1)
	\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
	\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
	\ar@{-} (-10,-12);(-15,-18) % 5 al 3
	\ar@{-} (10,-12);(5,-18) % 14 al 12
	\ar@{-} (10,-12);(15,-18) % 14 al 15
	% \ar@{-} (-15,-22);(-20,-28)
	% \ar@{-} (-15,-22);(-15,-28)
	% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
	% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
	% \ar@{-} (-5,-22);(0,-28)
	% \ar@{-} (5,-22);(10,-28)
	% \ar@{-} (15,-22);(10,-28) % 15 al 14
	% \ar@{-} (15,-22);(20,-28)
	% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
	% \ar@{-} (0,-32);(-5,-38) % 12 al 13
	\end{xy}\]

	\noindent
	El código implementado en C++ sería:
\begin{minted}[linenos,firstnumber=48]{c++}
template <class T>
void Doble_DerechaIzquierda (info_nodo_AVL<T> * & n) {
	SimpleDerecha(n->hijoder);
	SimpleIzquierda (n);
}
\end{minted}
\end{description}

\noindent
Ejemplo: Dada una lista de números crear un árbol binario de búsqueda AVL:
\begin{displaymath}
\{1,2,3,4,5,6,7,15,14,13,12,11,10,9\}
\end{displaymath}

\noindent
Los pasos para resolver este ejercicio son, elemento a elemento:
\begin{enumerate}
	\item Insertar el elemento que corresponda.
	\item Comprobar que el árbol está equilibrado.
	\begin{enumerate}
		\item Si lo está, seguimos insertando elementos donde corresponda
		\item Si no lo está, lo equilibramos antes de seguir insertando.
	\end{enumerate}
\end{enumerate}

\noindent
Entonces, empezaríamos insertando el 1 como raíz del árbol y al ser el único nodo no quedaría desequilibrado. Después, insertaríamos el 2 como hijo a la derecha y seguiría estando equilibrado, así que por último, insertamos el 3 como hijo a la derecha de 2 y como resultado, tenemos un desequilibrio \textbf{\textcolor[rgb]{0.3,0.4,0.8}{caso D}}, por lo que lo equilibramos haciendo una rotación simple a la izquierda sobre 1:

\begin{minipage}{0.4\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{1}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
% ,(-10,-10)*+=<10mm>[]\txt<2cm>{6}
,(10,-10)*+=<10mm>[]\txt<2cm>{2}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSI(1)}
% ,(-15,-20)*+=<10mm>[]\txt<2cm>{5}
% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
% ,(5,-20)*+=<10mm>[]\txt<2cm>{13}
,(15,-20)*+=<10mm>[]\txt<2cm>{3}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
% \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{->} (25,-10);(40,-10)
% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
% \ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
% \ar@{-} (15,-22);(20,-28)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.4\textwidth}
\[\begin{xy}
,(0,0)*+=<10mm>[]\txt<2cm>{2}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{1}
,(10,-10)*+=<10mm>[]\txt<2cm>{3}
% ,(-15,-20)*+=<10mm>[]\txt<2cm>{5}
% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
% ,(5,-20)*+=<10mm>[]\txt<2cm>{13}
% ,(15,-20)*+=<10mm>[]\txt<2cm>{3}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
% \ar@{-} (10,-12);(5,-18) % 14 al 12
% \ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
% \ar@{-} (15,-22);(20,-28)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\noindent
Y así seguiríamos paso por paso con cada número. Ten en cuenta que las rotaciones dobles deben hacerse en dos pasos:

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSI(3)}
,(0,0)*+=<10mm>[]\txt<2cm>{2}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{1}
,(10,-10)*+=<10mm>[]\txt<2cm>{3}
% ,(-15,-20)*+=<10mm>[]\txt<2cm>{5}
% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
% ,(5,-20)*+=<10mm>[]\txt<2cm>{13}
,(15,-20)*+=<10mm>[]\txt<2cm>{4}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{5}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(40,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
% \ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSI(2)}
,(0,0)*+=<10mm>[]\txt<2cm>{2}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{1}
,(10,-10)*+=<10mm>[]\txt<2cm>{4}
% ,(-15,-20)*+=<10mm>[]\txt<2cm>{5}
% ,(-5,-20)*+=<10mm>[]\txt<2cm>{56}
,(5,-20)*+=<10mm>[]\txt<2cm>{3}
,(15,-20)*+=<10mm>[]\txt<2cm>{5}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{6}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(40,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
% \ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
% \ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSI(5)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{5}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
% ,(5,-20)*+=<10mm>[]\txt<2cm>{3}
,(15,-20)*+=<10mm>[]\txt<2cm>{6}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{7}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(40,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
% \ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(33,-8)*+=<10mm>[]\txt<2cm>{1º}
,(32,-12)*+=<20mm>[]\txt<2cm>{RSD(15)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{6}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
,(5,-20)*+=<10mm>[]\txt<2cm>{5}
,(15,-20)*+=<10mm>[]\txt<2cm>{7}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{15}
,(15,-40)*+=<10mm>[]\txt<2cm>{14}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
\ar@{-} (20,-32);(15,-38)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(7)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{6}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
,(5,-20)*+=<10mm>[]\txt<2cm>{5}
,(15,-20)*+=<10mm>[]\txt<2cm>{7}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(-15,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{14}
% ,(15,-40)*+=<10mm>[]\txt<2cm>{14}
,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (20,-32);(15,-38)
\ar@{-} (20,-32);(25,-38)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(33,-8)*+=<10mm>[]\txt<2cm>{1º}
,(32,-12)*+=<20mm>[]\txt<2cm>{RSD(14)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{6}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
,(5,-20)*+=<10mm>[]\txt<2cm>{5}
,(15,-20)*+=<10mm>[]\txt<2cm>{14}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
,(10,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{15}
,(15,-40)*+=<10mm>[]\txt<2cm>{13}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
\ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
\ar@{-} (10,-32);(15,-38)
% \ar@{-} (20,-32);(25,-38)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(6)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{6}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
,(5,-20)*+=<10mm>[]\txt<2cm>{5}
,(15,-20)*+=<10mm>[]\txt<2cm>{7}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{14}
,(15,-40)*+=<10mm>[]\txt<2cm>{13}
,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
% \ar@{-} (-5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
\ar@{-} (20,-32);(15,-38)
\ar@{-} (20,-32);(25,-38)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
% ,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSI(4)}
,(0,0)*+=<10mm>[]\txt<2cm>{4}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{2}
,(10,-10)*+=<10mm>[]\txt<2cm>{7}
,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
,(-5,-20)*+=<10mm>[]\txt<2cm>{3}
,(5,-20)*+=<10mm>[]\txt<2cm>{6}
,(15,-20)*+=<10mm>[]\txt<2cm>{14}
% ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
,(0,-30)*+=<10mm>[]\txt<2cm>{5}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{15}
,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(5,-40)*+=<10mm>[]\txt<2cm>{12}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
% \ar@{-} (-15,-22);(-20,-28)
% \ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
% \ar@{-} (-5,-22);(-10,-28) % 7 al 6
\ar@{-} (5,-22);(0,-28)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
\ar@{-} (15,-22);(20,-28)
\ar@{-} (15,-22);(10,-28)
\ar@{-} (10,-32);(5,-38)
% \ar@{-} (15,-42);(10,-48)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
% ,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSD(13)}
,(0,0)*+=<10mm>[]\txt<2cm>{7}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{10}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
,(5,-20)*+=<10mm>[]\txt<2cm>{13}
,(15,-20)*+=<10mm>[]\txt<2cm>{15}
,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(0,-30)*+=<10mm>[]\txt<2cm>{12}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(5,-40)*+=<10mm>[]\txt<2cm>{12}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(-5,-40)*+=<10mm>[]\txt<2cm>{11}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
\ar@{-} (5,-22);(0,-28)
\ar@{-} (0,-32);(-5,-38)
% \ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
% \ar@{-} (15,-22);(20,-28)
% \ar@{-} (15,-22);(10,-28)
% \ar@{-} (10,-32);(5,-38)
% \ar@{-} (15,-42);(10,-48)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
% ,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSD(14)}
,(0,0)*+=<10mm>[]\txt<2cm>{7}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{14}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
,(5,-20)*+=<10mm>[]\txt<2cm>{12}
,(15,-20)*+=<10mm>[]\txt<2cm>{15}
,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(0,-30)*+=<10mm>[]\txt<2cm>{11}
,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(5,-40)*+=<10mm>[]\txt<2cm>{12}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
\ar@{-} (5,-22);(0,-28)
\ar@{-} (0,-32);(-5,-38)
\ar@{-} (5,-22);(10,-28)
% \ar@{-} (15,-22);(10,-28) % 15 al 14
% \ar@{-} (15,-22);(20,-28)
% \ar@{-} (15,-22);(10,-28)
% \ar@{-} (10,-32);(5,-38)
% \ar@{-} (15,-42);(10,-48)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\begin{xy}
% ,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
,(32,-8)*+=<20mm>[]\txt<2cm>{RSD(11)}
,(0,0)*+=<10mm>[]\txt<2cm>{7}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
,(5,-20)*+=<10mm>[]\txt<2cm>{11}
,(15,-20)*+=<10mm>[]\txt<2cm>{14}
,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(0,-30)*+=<10mm>[]\txt<2cm>{10}
,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{15}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(5,-40)*+=<10mm>[]\txt<2cm>{12}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(-5,-40)*+=<10mm>[]\txt<2cm>{9}

% \ar@{->} (5,3);(0,1)
\ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
\ar@{-} (5,-22);(0,-28)
\ar@{-} (0,-32);(-5,-38)
\ar@{-} (15,-22);(10,-28)
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (15,-22);(10,-28)
% \ar@{-} (10,-32);(5,-38)
% \ar@{-} (15,-42);(10,-48)
% \ar@{-} (-5,-22);(-5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\begin{xy}
% ,(33,-8)*+=<10mm>[]\txt<2cm>{2º}
% ,(32,-8)*+=<20mm>[]\txt<2cm>{RSD(11)}
,(0,0)*+=<10mm>[]\txt<2cm>{7}
% ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
,(-10,-10)*+=<10mm>[]\txt<2cm>{4}
,(10,-10)*+=<10mm>[]\txt<2cm>{12}
,(-15,-20)*+=<10mm>[]\txt<2cm>{2}
,(-5,-20)*+=<10mm>[]\txt<2cm>{6}
,(5,-20)*+=<10mm>[]\txt<2cm>{10}
,(15,-20)*+=<10mm>[]\txt<2cm>{14}
,(-20,-30)*+=<10mm>[]\txt<2cm>{1}
,(-15,-30)*+=<10mm>[]\txt<2cm>{3}
,(-10,-30)*+=<10mm>[]\txt<2cm>{5}
,(0,-30)*+=<10mm>[]\txt<2cm>{9}
,(10,-30)*+=<10mm>[]\txt<2cm>{13}
,(20,-30)*+=<10mm>[]\txt<2cm>{15}
,(5,-30)*+=<10mm>[]\txt<2cm>{11}
% ,(5,-40)*+=<10mm>[]\txt<2cm>{12}
% ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
%,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
% ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
% ,(-5,-40)*+=<10mm>[]\txt<2cm>{9}

% \ar@{->} (5,3);(0,1)
% \ar@{->} (25,-10);(43,-10)
\ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
\ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
\ar@{-} (-10,-12);(-15,-18) % 5 al 3
\ar@{-} (10,-12);(5,-18) % 14 al 12
\ar@{-} (10,-12);(15,-18) % 14 al 15
\ar@{-} (-15,-22);(-20,-28)
\ar@{-} (-15,-22);(-15,-28)
\ar@{-} (-10,-12);(-5,-18) % 5 al 7
\ar@{-} (-5,-22);(-10,-28) % 7 al 6
\ar@{-} (5,-22);(0,-28)
% \ar@{-} (0,-32);(-5,-38)
\ar@{-} (15,-22);(10,-28)
\ar@{-} (15,-22);(20,-28)
% \ar@{-} (15,-22);(10,-28)
% \ar@{-} (10,-32);(5,-38)
% \ar@{-} (15,-42);(10,-48)
\ar@{-} (5,-22);(5,-28) % 7 al 8
% \ar@{-} (0,-32);(-5,-38) % 12 al 13
\end{xy}\]
\end{minipage}

\noindent
Por tanto, el algoritmo de inserción en C++ sería:

\begin{minted}[linenos,firstnumber=53,tabsize=2]{c++}
template <class T>
bool InsertarAVL (info_nodo_AVL<T> * & raiz, T x) {
      if (raiz == 0) {
            raiz = new info_nodo_AVL(x); // constructor: crea un nodo vacio con et=x
            raiz->altura = 0;
            return true; // el nodo ha podido insertarse con exito
      }

      else {
            if (x < raiz->et) {
                  if (raiz->hijoder != 0)
                        raiz->hijoder->padre = raiz;

                  if (InsertarAVL(raiz->hijoizq, x)) { // el arbol ha crecido,
                        // vemos la diferencia de altura entre ambos hijos
                        switch (Altura(raiz->hijoizq) - Altura(raiz->hijoder)) {
                        // los valores del switch deben ser 0, 1 o 2, si son mayores
                        // en algun momento no hemos insertado un elemento bien y
                        // nuestro arbol no esta equilibrado.
                        case 0:
                              return false; // el arbol no ha crecido

                        case 1: // ha crecido por la izquierda, sumamos 1 a la altura
                              raiz->altura++;   // de la raiz
                              return true;

                        case 2:
                              /* CASO A*/
                              if (Altura(raiz->hijoizq->hijoizq) > 
                                    Altura(raiz->hijoizq->hijoder))
                                    SimpleDerecha(raiz);

                              /*CASO B*/
                              else
                                    Doble_IzquierdaDerecha(raiz);

                              return false; // la altura no crece porque hemos 
                                          // equilibrado el arbol
                        }
                  }
            }

            else { // x es mayor que la etiqueta
                  if (raiz->hijoizq != 0)
                        raiz->hijoizq->padre = raiz;

                  if (InsertarAVL(raiz->hijoder, x)) {
                        switch (Altura(raiz->hijoder) - Altura(raiz->hijoizq)) {
                        case 0:
                              return false; // el arbol no ha crecido

                        case 1: // ha crecido por la izquierda, sumamos 1 a la altura
                              raiz->altura++;   // de la raiz
                              return true;

                        case 2:
                              /* CASO D */
                              if (Altura(raiz->hijoder->hijoder) >
                                    Altura(raiz->hijoder->hijoizq))
                                    SimpleIzquierda(raiz);

                              /* CASO C */
                              else
                                    Doble_DerechoIzquierda(raiz);

                              return false;
                        }
                  }
            }
      }
}
\end{minted}

\section{\textcolor[rgb]{0.3,0.4,0.8}Tablas hash}
\subsection{\textcolor[rgb]{0.3,0.4,0.8}Objetivo}
\noindent
Datos un conjunto de datos identificados por una clave ($k$) se quiere obtener una función $h(k)$ (\textit{\textcolor[rgb]{0.3,0.4,0.8}{función hash}}) 
que nos dé la posición dentro de una tabla (\textit{\textcolor[rgb]{0.3,0.4,0.8}{tabla hash}}) en la que almacenamos un par con la clave y la dirección 
en un fichero donde se encuentra la información asociada a esa clave.

\noindent
Ejemplo:

\begin{minipage}{0.6\textwidth}
\begin{center}
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Tabla hash}}
\begin{tabular}{| c | c | c |}
\hline
Dirección & $k$ & Posición dentro del fichero \\
\hline
$0$ & $239$ & $i$ \\
$1$ & $500$ & $n$ \\
& . & \\
& . & \\
& . & \\
$n$ & $733$ & l \\
\hline
\end{tabular}
\end{center}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{center}
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{Resto de la información}}
\begin{tabular}{| c | c | c |}
\hline
Dirección & $k$ & Contenido \\
\hline
$k$ & $733$ & bla bla bla bla bla \\
& . & \\
& . & \\
& . & \\
\hline
\end{tabular}
\end{center}
\end{minipage}

\noindent
Para obtener la info asociada a la clave $k = 733$ sólo tendríamos que aplicar la función hash para obtener la dirección del fichero
en la que se guarda su info, es decir $h(733) = n$. Vamos a la tabla a la posición n y ahi consultamos la dirección en el fichero donde tenemos
el resto de la información. Así para la clave $k = 733$ tenemos que ir a la posición en el fichero 1.

\noindent
La función  hash cuesta calcularla  $O(1)$, lo que nos reconduce a un proceso de búsqueda $O(1)$.
El problema de las tablas hash es que a veces diferentes claves tiene el mismo valor hash y por lo tanto se produce colisiones. Y en segundo lugar
no tener tablas muy descompensadas con respecto al numero de datos que queremos almacenar.

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Colisiones}
\label{colisiones}
\noindent
Se dan cuando para dos claves diferentes la función hash devuelve el mismo valor, es decir, para las claves $k_1$ y $k_2$ siendo $k_1 \ne k_2$ ocurre colisión si $h(k_1) = h(k_2)$ Debemos buscar funciones hash que produzcan el menor número de colisiones.
Además las funciones hash deben devolver valores en el rango de índices de mi tabla.

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Características de las tablas hash}

\begin{enumerate}[---]
      \item La función hash debe ser rápida de calcular
      \item La función hash debe producir el menor número de colisiones
      \item El tamaño de la tabla hash debe ser adecuado
\end{enumerate}

\noindent
\label{ejemplo_hash1}
Ejemplo: tenemos el siguiente fichero de datos:

% \begin{minipage}{0.6\textwidth}
\begin{center}
\begin{tabular}{| c | c | c |}
\hline
Dirección & $k$ & \\
\hline
$0$ & $12$ & Abad Ruiz \\
$1$ & $21$ & Bernabe Pérez \\
$2$ & $68$ & Carrasco Ruiz \\
$3$ & $38$ & Domingo Coca \\
$4$ & $52$ & Fdez Sánchez \\
$5$ & $70$ & Juan Ruiz \\
$6$ & $44$ & Martín Pérez \\
$7$ & $18$ & Pérez Galiano \\
\hline
\end{tabular}
\end{center}
% \end{minipage}
% \begin{minipage}{0.5\textwidth}
% \begin{center}
% \begin{tabular}{| c | c | c |}
% \hline
% & $k$ & Dirección \\
% \hline
% $0$ & $44$ & $6$ \\
% $1$ & $12$ & $0$ \\
% $2$ & $68$ & $2$ \\
% $3$ & & \\
% $4$ & $70$ & $5$ \\
% $5$ & $38$ & $3$ \\
% $6$ & & \\
% $7$ & $18$ & $7$ \\
% $8$ & $52$ & $4$ \\
% $9$ & & \\
% $10$ & $21$ & $1$ \\
% \hline
% \end{tabular}
% \end{center}
% \end{minipage}

\noindent
Tenemos $8$ registros, por tanto vamos a hacer nuestra tabla hash con $11$ posiciones, ya que es recomendable que el tamaño de la tabla hash sea un número primo para evitar colisiones. Por tanto tenemos lo siguiente:
\begin{enumerate}[$\bullet$]
      \item $M = 11$ $posiciones$
      \item $h(k) = k \% M$
\end{enumerate}

\noindent
Con estas premisas, nos ponemos a calcular las distintas posiciones y a rellenar la tabla hash:
\begin{enumerate}[$\bullet$]
      \item $h(12) = 12 \% 11 = 1$
      \item $h(21) = 21 \% 11 = 10$
      \item $h(68) = 68 \% 11 = 2$
      \item $h(38) = 38 \% 11 = 5$
      \item $h(52) = 52 \% 11 = 8$
      \item $h(70) = 70 \% 11 = 4$
      \item $h(44) = 44 \% 11 = 0$
      \item $h(18) = 18 \% 11 = 7$
\end{enumerate}

\noindent
Una vez calculadas las posiciones dentro de la tabla hash, el resultado sería este:

\begin{center}
\begin{tabular}{| c | c | c |}
\hline
& $k$ & Dirección \\
\hline
$0$ & $44$ & $6$ \\
$1$ & $12$ & $0$ \\
$2$ & $68$ & $2$ \\
$3$ & & \\
$4$ & $70$ & $5$ \\
$5$ & $38$ & $3$ \\
$6$ & & \\
$7$ & $18$ & $7$ \\
$8$ & $52$ & $4$ \\
$9$ & & \\
$10$ & $21$ & $1$ \\
\hline
\end{tabular}
\end{center}

\noindent
Para buscar, por ejemplo, $k=52$ aplicamos $h(52) = 52 \% 11 = 8$. Nos da la dirección $4$ y accedemos al disco. La búsqueda se realiza en $O(1)$.
Si el resultado es una celda vacía, no tendríamos nada en dicha celda y en el registro tampoco.
Cuando ocurra colisión deberemos resolverla. Los mecanismos para resolver colisiones se engloblan en las técnicas de  \textit{\textcolor[rgb]{0.3,0.4,0.8}{hashing abierto}} ó \textit{\textcolor[rgb]{0.3,0.4,0.8}{hashing cerrado}}.

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Hashing abierto}
\noindent
Para arreglar los problemas de colisión, asociamos a cada entrada $h(k)$ una lista donde se ponen todas las claves con igual valor hash $h(k)$.
Se debe procurar que las listas no sean muy grandes, cuando lo son debemos redimensionar la tabla. Y esto nos llevará colocar de nuevo todas
la claves ya almacenadas en la nueva tabla. 
Para agilizar los procesos de busqueda entre las claves con igual función hash las listas deben estar ordenadas por valor de clave.

\noindent
Ejemplo: siguiendo el \hyperref[ejemplo_hash1]{ejemplo anterior}, pero con $M = 5$ y $h(k) = k \% 5$ (podemos reducir el tamaño de la tabla pues tenemos listas para las colisiones), la tabla hash sería de la siguiente forma:

\begin{center}
\begin{tabular}{c | c l}
$h(k)$ & \\
\hline
$0$ & $\longrightarrow$ & $70 \| 5 \| X$ \\
$1$ & $\longrightarrow$ & $2 \| 1 \| X$\\
$2$ & $\longrightarrow$ & $12 \| 0 \| \longrightarrow 52 \| 4 \| X$\\
$3$ & $\longrightarrow$ & $68 \| 2 \| \longrightarrow 38 \| 3 \longrightarrow 18 \| 7 \| \longrightarrow 33 \| 8 \| X$ \\
$4$ & $\longrightarrow$ & $44 \| 6 \| X$ \\
\end{tabular}
\end{center}
En este ejemplo las listas no están ordenadas, pero sería interesante tener las claves ordenadas en cada lista.
\noindent
Podemos tener cualquier estructura para guardar datos en vez de una lista, por ejemplo, un AVL.

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Implementación con un vector de la STL}
\begin{minted}[linenos]{c++}
#include <vector>
#include <list>

class Celda {
private:
      int k;      // valor de la clave
      int d;      // direccion en el fichero de datos
public:
      Celda (): k(-1), d(-1) {}
      Celda (int c, int p): k(c), d(p) {}
      int & clave () {return k;}
      int & posicion () {return d;}
};

class TH {
private:
      vector<list<Celda> > tabla;
      int fhash (int clave) {
            return clave % tabla.size();
      }

      pair<bool,list<Celda>::iterator> Esta (int clave) {
            list<Celda>::iterator it;
            int pos = fhash (clave);
            for (it = tabla[pos].begin(); it != tabla[pos].end() 
                  && (*it).clave() != clave; ++it);

            // al salir del for tenemos dos posibilidades: haber encontrado la
            // clave o no.
            bool find = false;
            if (it != tabla[pos].end()) find = true;
            return pair<bool, list<Celda>::iterator> (find, it);
      }
public:
      TH (int tam) {
            assert (tam > 0);
            tabla.resize (tam);
      }

      bool Existe (int clave) {
            pair<bool,list<Celda>::iterator> a;
            a = Esta (clave);
            return a.first;
      }

      bool Insertar (int clave, int d) {
            pair<bool,list<Celda>::iterator> a;
            a = Esta (clave);
            if (!a.first) {
                  int pos = fhash (clave);
                  tabla[pos].push_back (Celda(clave,d));
                  return true;
            }
            else
                  return false;
      }

      bool CambiarDir (int clave, int nuevadir) {
            pair<bool,list<Celda>::iterator> a;
            a = Esta(clave);
            if (a.first) {
                  // podemos hacer esto porque posicion() devuelve una referencia
                  (*(a.second)).posicion() = nuevadir;
                  return true;
            }
            else
                  return false;
      }

      int ObtenDir (int clave) {
            pair<bool,list<Celda>::iterator> a = Esta (clave);
            if (a.first)
                  return (*(a.second)).posicion ();
            else
                  return -1;
      }

      bool Borrar (int clave) {
            pair<bool,list<Celda>::iterator> a = Esta (clave);
            if (a.first) {
                  int pos = fhash (clave);
                  tabla[pos].erase (a.second);
                  return true;
            }
            else
                  return false;
      }

      friend ostream & operator<< (ostream & os, const TH & T) {
            vector<list<Celda> >::iterator it1; int pos = 0;
            for (it1 = T.tabla.begin(); it1 != T.tabla.end(); ++it1; ++pos) {
                  os << "Datos en posicion " << pos << ':';
                  list<Celda>::iterator it2;
                  for (it2 = (*it1).begin(); it2 != (*it1).end(); ++it2)
                        os << (*it2).clave() << ' ' << (*it2).posicion() << ' ';
                  os << endl;
            }
            return os;
      }
};
\end{minted}

\noindent
\textbf{\textcolor[rgb]{0.3,0.4,0.8}{\underline{Ejercicio del examen del curso 2013-2014}}}:

\noindent
Suponed que tenemos el T.D.A. Tabla Hash abierta (unordered\_set) (Class TH), en la que la resolución de colisiones se hace utilizando para cada cubo una lista.

\begin{minted}[linenos]{c++}
#include <vector>
#include <list>
using namespace std;

class TH {
private:
      struct info {
            int key; //clave
            int di;  //direccion
      };
      vector<list<info> > data;
      int fhash (int k) const;
      bool recolocar () const;
public:
...
      /* k es la clave, d la direccion asociada para esa clave*/
      void insertar (int k, int d);
...
      class iterator {
      private:
            list<info>::iterator it_cub;
            vector<list<info> >::iterator it;
            ...
      };
      iterator begin ();
      iterator end();
...
};
\end{minted}

\begin{enumerate}[a)]
      \item Implementar la función \textbf{\textcolor[rgb]{0.3,0.4,0.8}{insertar}} suponiendo que tenemos implementada la función hash (\textbf{\textcolor[rgb]{0.3,0.4,0.8}{fhash}}). Después de añadir la nueva clave $k$ y su dirección asociada $d$, la función \textbf{\textcolor[rgb]{0.3,0.4,0.8}{insertar}} debe comprobar si es necesario redimensionar la tabla hash. Para ello se supone que tenemos implementada la función \textbf{\textcolor[rgb]{0.3,0.4,0.8}{recolocar}}. Esta función devuelve verdadero en el caso de que sea necesario pasar todos los datos a una nueva tabla hash y false en caso contrario. El tamaño de la nueva tabla tiene que ser el primo más cercano a $2 \cdot M$ por exceso, siendo $M$ el tamaño original.

\begin{minted}[linenos,tabsize=2]{c++}
void insertar (int k, int d) {
      int pos = fhash (k);
      info aux = {k, d};
      data[pos].push_back (aux);
      if (recolocar()) {
            int nuevo_tam = nextprimo (data.size()*2);
            vector<list<info> > nuevodata (nuevo_tam);
            for (int i=0; i<data.size(); i++) {
                  list<info>::iterator it;
                  for (it = data[i].begin(); it != data[i].end(); ++it) {
                        // hacemos la funcion fhash a mano pues debemos hacerla con
                        // el nuevo tamanio calculado
                        int npos = (*it).key % nuevo_tam;
                        nuevodata[npos].push_back(*it);
                  }
            }
            data = nuevodata;
      }
}
\end{minted}

      \item  Implementar la \textbf{\textcolor[rgb]{0.3,0.4,0.8}{clase iterator}} (un iterador sobre todos los elementos de la tabla hash) de la tabla hash, así como las funciones \textbf{\textcolor[rgb]{0.3,0.4,0.8}{begin}} y \textbf{\textcolor[rgb]{0.3,0.4,0.8}{end}} de la clase TH.

\begin{minted}[linenos]{c++}
class iterator {
private:
      list<info>::iterator it_cub;
      vector<list<info> >::iterator it;
      vector<list<info> >::iterator final_tabla;

public:
      info & operator++ () {
            // avanzamos it_cub
            ++it_cub;
            // si it_cub es el fin de la lista de la posicion actual de la tabla
            // avanzamos el iterador que recorre la tabla y ponemos it_cub
            // al inicio de la lista de esa posicion
            while (it_cub == it->end() && it != final_tabla) {
                  ++it;
                  it_cub = it->begin();
            }
            return *this;
      }

      info & operator-- () {
            --it_cub;
            while (it_cub == it->begin()) {
                  --it;
                  it_cub = it->end();
                  --it_cub;
            }
            return *this;
      }

      info & operator* () {
            return *it_cub;
      }

      bool operator == (const TH::iterator & i)const {
            return it == i.it && it_cub == i.it_cub && final_tabla == i.final_tabla;
      }

      bool operator != (const TH::iterator & i)const {
            return it != i.it && it_cub != i.it_cub && final_tabla != i.final_tabla;
      }

      friend class TH;
};

iterator begin () {
      iterator i;
      i.it = datos.begin();
      i.it_cub = it->begin();
      i.final_tabla = datos.end();
      if (i.it_cub == i.it->end())
            ++i;  // si no hay elementos debemos avanzar a la siguiente
                  // lista valida
      return i;
}

iterator end () {
      iterator i;
      i.it = datos.end();
      i.it_cub = it->end();
      i.final_tabla = datos.end();
      if (i.it_cub == i.it->begin())
            --i;
      return i;
}
\end{minted}
\end{enumerate}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Hashing cerrado}
\noindent
Sólo se usa una tabla donde cada elemento se dispone en una única entrada. Lo que se almacena en dicha entrada es:
\begin{enumerate}[$\heartsuit$]
      \item La clave
      \item La posición de dicha información dentro del fichero
      \item El estado de la casilla, que puede ser libre u ocupado.
\end{enumerate}

\noindent
El proceso de relleno es igual al de las tablas abiertas, la diferencia está en cómo tratamos las \hyperref[colisiones]{colisiones}: en el hashing cerrado se usa el \textit{\textcolor[rgb]{0.3,0.4,0.8}{rehashing}}. Las distintas estrategias de rehashing son:
\begin{enumerate}[$\bigstar$]
      \item Lineal
      \item Doble
      \item Sondeo aleatorio
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Lineal}
\noindent
Aplican $h(k)$ y, si existe colisión, aplican $h_i (k) = (h(k) + (i-1)) \% M$ siendo $i = 2, 3, 4...$ hasta encontrar una casilla libre.

\noindent
Ejemplo: usando los datos del \hyperref[ejemplo_hash1]{ejemplo anterior}, $h(k) = k \% M$, $M = 11$ y $h(k) = (h(k) + (i-1)) \% M$:

\begin{enumerate}[$\longrightarrow$]
      \item $h(12) = 12 \% 11 = 1$
      \item $h(21) = 21 \% 11 = 10$
      \item $h(68) = 68 \% 11 = 2$
      \item $h(32) = 32 \% 11 = 10 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_1 (32) = 10$ Este se corresponde con el ya calculado
            \item $h_2 (32) = (10+1) \% 11 = 0$ Como el $0$ está libre, insertamos la key $32$ ahí.
      \end{enumerate}
      \item $h(56) = 56 \% 11 = 1 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (56) = (1+1) \% 11 = 2$
            \item $h_3 (56) = (1+2) \% 11 = 3$
      \end{enumerate}
      \item $h(77) = 77 \% 11 = 0 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (77) = (0+1) \% 11 = 1$
            \item $h_3 (77) = (0+2) \% 11 = 2$
            \item $h_4 (77) = (0+3) \% 11 = 3$
            \item $h_5 (77) = (0+4) \% 11 = 4$
      \end{enumerate}
      \item $h(91) = 91 \% 11 = 3 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (91) = (3+1) \% 11 = 4$
            \item $h_3 (91) = (3+2) \% 11 = 5$
      \end{enumerate}
      \item $h(18) = 18 \% 11 = 7$
\end{enumerate}

\noindent
El rendimiento sería $17$, el número de intentos para almacenar todas las claves.

\noindent
La tabla final quedaría así:


\begin{tabular}{c | c | c | c}
$h(k)$ & $k$ & $d_i$ & estado \\
\hline
$0$ & $32$ & $3$ & ocupada \\
$1$ & $12$ & $0$ & ocupada \\
$2$ & $68$ & $2$ & ocupada \\
$3$ & $56$ & $4$ & ocupada \\
$4$ & $77$ & $5$ & ocupada \\
$5$ & $91$ & $6$ & ocupada \\
$6$ & & & libre \\
$7$ & $18$ & $7$ & ocupada \\
$8$ & & & libre \\
$9$ & & & libre \\
$10$ & $21$ & $1$ & ocupada \\
\end{tabular}

\noindent
A la hora de consultar debemos tener en cuenta si una casilla está libre por no haberle insertado ningún valor aún o porque su valor ha sido borrado. Si vemos una casilla que ha sido borrada en una consulta, la tomaremos como ocupada pues si no, nuestra búsqueda concluirá en ese punto.

\noindent
El rehashing lineal produce agrupamientos primarios\footnote{Se dan cuando para encontrar una casilla libre vamos avanzando al siguiente y al final quedan todos los elementos uno detrás de otro}, lo suyo, sin embargo, es ir dando saltos para encontrar más huecos libres. Para poder hacer esto está el rehashing doble.

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Estados de las casillas}
\begin{enumerate}[$\clubsuit$]
      \item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Ocupada}}
      \item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Vacía}}
      \item \textit{\textcolor[rgb]{0.3,0.4,0.8}{Borrada}}
\end{enumerate}

\noindent
El estado \textit{\textcolor[rgb]{0.3,0.4,0.8}{ocupada}} y \textit{\textcolor[rgb]{0.3,0.4,0.8}{borrada}} significan lo mismo para el proceso de consulta.

\noindent
El estado \textit{\textcolor[rgb]{0.3,0.4,0.8}{vacía}} y \textit{\textcolor[rgb]{0.3,0.4,0.8}{borrada}} significan lo mismo para el proceso de intersección.

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Algoritmo para buscar una clave}
% \noindent
% \begin{enumerate}
%       \item Calcular $h(c)$
%       \item Si \verb*|Estado(h(c))!=borrada| \verb*|&&| \verb*|clave(h(c))==c|
%       \begin{enumerate}[---]
%             \item \verb*|posicion=registro(h(c))|, teniendo en cuenta que la función \verb*|registro| devuelve la posición en disco de la información asociada a \verb*|c|.
%       \end{enumerate}
%       \item Si no, hacemos rehashing desde $i=2$ y lo repetimos hasta que el estado de $h_{i-1} (c)$ sea distinto de borrado y la clave coincida, o el estado de esa casilla sea vacía:
%       \verb*|Estado(h)|
% \end{enumerate}

%\renewcommand{\thepseudonum}{\roman{pseudonum}}
\begin{pseudocode}{SearchKey}{T,k}
\label{SearchKey}
\COMMENT{Buscar la clave $k$ en la tabla $T$}\\
$h(c)$ \GETS Calcular( $h(c)$) \\
\IF Estado($h(c)$) != borrada \AND clave($h(c)$) == c \THEN
\BEGIN
      posicion \GETS registro($h(c)$) \\
      \COMMENT{la función registro devuelve la posición en disco de la información asociada a a c}\\
\END
\\
\COMMENT{llamaremos $n$ a $h_{i-1}(c)$}\\
\ELSEIF Estado($n(c)$)!=borrado \AND ($n(c)$)==c \OR Estado($n(c)$)==vacia \THEN
\BEGIN
\COMMENT{las dos condiciones unidas por el and se dan cuando se encuentra la clave} \\
\COMMENT{la que viene después del or, se da cuando la clave no está en la tabla} \\
      \IF Estado($n(c)$)!=vacia \THEN
      \BEGIN
            \IF clave ($n(c)$)==c \THEN
            \BEGIN
                  posicion \GETS registro($n(c)$) \\
            \END
            \ELSE
            \BEGIN
                  posicion \GETS -1 \\
            \END
      \END
\END
\\
\RETURN{posicion}
\end{pseudocode}

\subsubsection{\textcolor[rgb]{0.3,0.4,0.8}Rehashing doble}
\noindent
La ventaja respecto al lineal es que los agrupamientos no son primarios, es decir, a partir de una posición no tendremos los demás sino que haremos un salto entre cada uno.

\noindent
La función hash sería la de siempre:
\begin{displaymath}
h(k) = k \% M
\end{displaymath}

\noindent
Pero ahora, la función de rehashing sería la siguiente:

\begin{displaymath}
h_i(k) = (h_{i-1}(k) + h_0(k)) \% M, \qquad\ \textrm{siendo $i = 1,2...$}
\end{displaymath}

\noindent
$h_0(k)$ se calcularía de la siguiente forma:
\begin{displaymath}
h_0(k) = 1 + (k \% (M-2)), \qquad\ \textrm{$M$ y $M-2$ se toman como primos relativos}
\end{displaymath}

\noindent
Ejemplo: Queremos crear una tabla hash cerrada con $M=13$. El fichero de datos contiene $12$ registros:

\label{ejemplo2}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
$Clave$ & 119 & 85 & 43 & 141 & 72 & 91 & 109 &147 & 38 & 137 & 148 & 101 \\
\hline
$Registro$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
\hline
$h(k)$ & 2 & 7 & 4 & 11 & 7 & 0 & 5 & 4 & 12 & 7 & 5 & 10 \\
\hline
\end{tabular}

\noindent
Hemos calculado en una tabla, el $h_0(k)$ y el $h_1(k)$ de cada uno:

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
$k$ & 119 & 85 & 43 & 141 & 72 & 91 & 109 &147 & 38 & 137 & 148 & 101 \\
\hline
$h_1 (k)$ & 2 & 7 & 4 & 11 & 7 & 0 & 5 & 4 & 12 & 7 & 5 & 10 \\
\hline
$h_0 (k)$ & 10 & 9 & 11 & 10 & 7 & 4 & 11 & 5 & 6 & 6 & 6 & 3 \\
\hline
\end{tabular}

\newpage
\noindent
Al rellenar la tabla nos queda así:

\begin{minipage}{0.5\textwidth}
\begin{tabular}{c | c | c | c}
$h(k)$ & $k$ & registro \\
\hline
$0$ & $91$ & $5$ \\
$1$ & $72$ & $4$ \\
$2$ & $119$ & $0$ \\
$3$ &  $101$ & $11$ \\
$4$ & $43$ & $2$ \\
$5$ & $109$ & $6$ \\
$6$ & $137$ & $9$ \\
$7$ & $85$ & $1$ \\
$8$ & & \\
$9$ & $147$ & $7$ \\
$10$ & $148$ & $10$ \\
$11$ & $141$ & $3$ \\
$12$ & $38$ & $8$ \\
\end{tabular}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{enumerate}
      \item $h(119) = 119 \% 13 = 2$
      \item $h(85) = 85 \% 13 = 7$
      \item $h(43) = 43 \% 13 = 4$
      \item $h(141) = 141 \% 13 = 11$
      \item $h(72) = 72 \% 13 = 7 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_0 (72) = 1 + (72 \% 11) = 7$
            \item $h_1 (72) = h(72) = 7$
            \item $h_2 (72) = (7+7) \% 13 = 1$
      \end{enumerate}
      \item $h(38) = 38 \% 13 = 12$
      \item $h(91) = 91 \% 13 = 0$
      \item $h(109) = 109 \% 13 = 5$
      \item $h(147) = 147 \% 13 = 4 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_0 (147) = 1 + (147 \% 11) = 5$
            \item $h_2 (147) = (4+5) \% 13 = 9$
      \end{enumerate}
      \item $h(137) = 137 \% 13 = 7 \longleftarrow$ Colisión
      \begin{enumerate}
            \item $h_0 (137) = 1 + (137 \% 11) = 6$
            \item $h_2 (137) = (7+6) \% 13 = 0$
            \item $h_3 (137) = (0+6) \% 13 = 6$
      \end{enumerate}
      \item $h(148) = 148 \% 13 = 5 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_0 (148) = 1 + (148 \% 11) = 6$
            \item $h_2 (148) = (5+6) \% 13 = 11$
            \item $h_3 (148) = (11+6) \% 13 = 4$
            \item $h_4 (148) = (4+6) \% 13 = 10$
      \end{enumerate}
      \item $h(101) = 101 \% 13 = 10 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_0 (101) = 1 + (101 \% 11) = 3$
            \item $h_2 (101) = (10+3) \% 13 = 0$
            \item $h_3 (101) = (3+0) \% 13 = 3$
      \end{enumerate}
\end{enumerate}
\end{minipage}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Sondeo aleatorio}
\noindent
La función hash a utilizar es la misma de siempre:
\begin{displaymath}
h(k) = k \% M
\end{displaymath}

\noindent
Cuando existe colisión, se aplica la siguiente fórmula:
\begin{displaymath}
h_i (k) = (h_{i-1} (k) + c) \% M
\end{displaymath}

\noindent
Donde:
\begin{enumerate}[---]
      \item $M$ es el tamaño de la tabla. Suele ser el siguiente primo mayor al número de claves a insertar en la tabla.
      \item $c$ es una constante mayor que uno ($c > 1$). Debe ser primo relativo de M (no tener factores en común).
      \item $h_1 (k) = h (k)$
\end{enumerate}

\noindent
Ejemplo: usando los datos del \hyperref[ejemplo2]{ejemplo anterior} vamos a insertar los elementos con sondeo aleatorio:

\noindent
Tenemos $h(k) = k \% 13$ y $c = 5$, por tanto $h_i (k) = (h_{i-1} (k) + 5) \% 13$.

\begin{minipage}{0.5\textwidth}
\begin{tabular}{c | c | c | c}
$h(k)$ & $k$ & registro \\
\hline
$0$ & $91$ & $5$ \\
$1$ & $38$ & $8$ \\
$2$ & $119$ & $0$ \\
$3$ & $101$ & $11$ \\
$4$ & $43$ & $2$ \\
$5$ & $109$ & $6$ \\
$6$ & $137$ & $9$ \\
$7$ & $85$ & $1$ \\
$8$ & & \\
$9$ & $147$ & $7$ \\
$10$ & $148$ & $10$ \\
$11$ & $141$ & $3$ \\
$12$ & $72$ & $4$ \\
\end{tabular}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{enumerate}
      \item $h(119) = 119 \% 13 = 2$
      \item $h(85) = 85 \% 13 = 7$
      \item $h(43) = 43 \% 13 = 4$
      \item $h(141) = 141 \% 13 = 11$
      \item $h(72) = 72 \% 13 = 7 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (72) = (7+5) \% 13 = 12$
      \end{enumerate}
      \item $h(91) = 91 \% 13 = 0$
      \item $h(109) = 109 \% 13 = 5$
      \item $h(147) = 147 \% 13 = 4 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (147) = (4+5) \% 13 = 9$
      \end{enumerate}
      \item $h(38) = 38 \% 13 = 12 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_2 (38) = (12+5) \% 13 = 4$
            \item $h_3 (38) = (4+5) \% 13 = 9$
            \item $h_4 (38) = (9+5) \%13 = 1$
      \end{enumerate}
      \item $h(137) = 137 \% 13 = 7 \longleftarrow$ Colisión
      \begin{enumerate}
            \item $h_2 (137) = (7+5) \% 13 = 12$
            \item $h_3 (137) = (12+5) \% 13 = 4$
            \item $h_4 (137) = (4+5) \% 13 = 9$
            \item $h_5 (137) = (9+5) \% 13 = 1$
            \item $h_6 (137) = (1+5) \% 13 = 6$
      \end{enumerate}
      \item $h(148) = 148 \% 13 = 5 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item $h_0 (148) = 1 + (148 \% 11) = 10$
      \end{enumerate}
      \item $h(101) = 101 \% 13 = 10 \longleftarrow$ Colisión
      \begin{enumerate}[$\diamond$]
            \item Ahora, iríamos dando saltos de 5 en 5 hasta encontrar un hueco libre. Para ello tendríamos que calcular hasta $h_{10} = 3$
      \end{enumerate}
\end{enumerate}
\end{minipage}

\noindent
En el sondeo aleatorio, para encontrar una casilla libre vamos dando saltos de tamaño $c$.

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Definir una función hash de una cadena de caracteres.}
\noindent
Si queremos \textbf{definir una función hash a partir de un vector de caracteres}, lo que se hace es coger el código ASCII de cada carácter:
\begin{displaymath}
h(k) = (k[0] + k[1] + \cdots + k[n-1]) \% M
\end{displaymath}

\subsection{\textcolor[rgb]{0.3,0.4,0.8}Otras funciones hash}
\noindent
Lo ideal sería encontrar una función hash inyectiva (sin colisiones), pero no es fácil encontrar una tabla con tal característica.

\noindent
Por ejemplo, si tenemos una tabla hash con $40$ posiciones y $30$ claves para insertar:
\begin{enumerate}[$\heartsuit$]
      \item ¿Cuántas funciones hash podemos definir? Cada casilla podemos rellenarla de $30$ formas posibles, por tanto podríamos definir unas $40^{30}$ funciones.
      \item De todas esas, son inyectivas $\binom{40}{30} = \frac{40!}{30! 10!}$
\end{enumerate}

\noindent
La función hash más usada es $h (k) = k \% M$, que se llama \textbf{\textcolor[rgb]{0.3,0.4,0.8}{División-resto (módulo)}}. Donde $M$ se escoge, sabiendo a priori el número de claves a insertar, como el siguiente primo a dicho número de claves.

\noindent
Otras funciones son:
\begin{description}
      \item[Truncamiento]: consiste en quedarse con unos dígitos determinados de la clave. Por ejemplo:
      \begin{displaymath}
      h(123456789) = 123
      \end{displaymath}
      En este ejemplo nos quedaríamos con los tres primeros dígitos. 
      El inconveniente que tiene es que las tablas deben tener un tamaño potencia de 10 y por tanto, éste se dispara rápidamente. Una alternativa para resolver esto es hacer un \textbf{\textcolor[rgb]{0.3,0.4,0.8}{truncamiento a nivel de bit}}, donde el tamaño sería una potencia de dos y el número se truncaría en binario.
      \item[Plegado]: consiste en dividir la parte en, al menos, dos partes y sumar dichas partes. Por ejemplo:
      \begin{displaymath}
      h(123456) = 123 + 456 = 579
      \end{displaymath}
      Si el resultado fuese un número muy grande se podría aplicar truncamiento. El tamaño debe ser potencia de 10 y como alternativa, se podría hacer en binario.
      \item[Multiplicación]: igual que el plegado, pero en vez de sumar se multiplica.
      \item[Cuadrado del centro]: consiste en quedarse con la parte central del número y calcular su cuadrado. Por ejemplo:
      \begin{displaymath}
      h(123456789) = 456^2 = 207936
      \end{displaymath}
      Se podría aplicar truncamiento tras calcularlo.
      \item[Centro del cuadrado]: Igual que antes, pero primero se aplica primero el cuadrado y luego se coge el número del centro:
      \begin{displaymath}
      h(1234) = 1234^2 = 1522756 = 2275
      \end{displaymath}
\end{description}

\chapter{\textcolor[rgb]{0.5,0.8,1}{Exámenes de otros años}}
\section{\textcolor[rgb]{0.5,0.8,1}Febrero 2012}
\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 1}
\noindent
Rellenar la siguiente tabla con la eficiencia de las operaciones de las filas en las estructuras de datos de las columnas. El tipo de dato subyacente es siempre \textbf{int}:
\begin{table}[H]
\scriptsize
\begin{tabular}{|c||c|c|c|c|c|c|}\hline
& vector ord & stack & priority\_queue & list & avl & tabla hash \\
\hline
Buscar elemento & O($log_2 (n)$) & O($n$) & O($n$) & O($n$) & O($log_2 (n)$) & O($1$) \\\hline
Encontrar máximo & $O(1)$ & O($n$) & O($1$)/O($n$) & O($n$) & O($log_2 (n)$) & O($n$)/O($M$) \\ \hline
Num. elem. en $[a,b]$ $a < b$ & O($log_2 (n)$) & O($n$) & O($n$) & O($n$) & O($n$) & O($n$)/O($M$) \\ \hline
Insertar elemento & O($n$) & O($1$) & O($log_2 (n)$) & O($1$) & O($log_2 (n)$) & O($1$) \\ \hline
Imprimir & O($n$) & O($n$) & O($n$) & O($n$) & O($n$) & O($n$)/O($M$) \\ \hline
\end{tabular}
\end{table}
\noindent
\begin{itemize}
\item Si en la priority queue la prioridad la marca el valor del entero, en el frente tendríamos el valor máximo. 
      Por tanto, dependiendo de la prioridad encontrar el máximo puede ser O($n$) o O(1). 
\item Encontrar el máximo en una tabla hash, sería O($n$) siempre y cuando el valor de $n$ sea cercano al de $M$, pero si $M$ es muy grande,
      encontrar el máximo nos costaría O($M$) pues tenemos que recorrer todas las filas de la tabla.
\item Insertar en una priority queue depende de cómo esté implementada la priority queue: encontrar dónde tenemos que insertarla sería $log_2 (n)$ y, 
      si por debajo tenemos una lista enlazada insertarlo nos costaría O(1).
    
\end{itemize}      

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 2}
\noindent
Se quiere construir el tipo de dato \verb*|vectorDisperso| de string. Este vector se puede definir como una secuencia de parejas
donde el primer elemento de la pareja es un índice y el segundo es el string asociado. Además contiene un valor por defecto
que indica el valor de tipo string  que  adopta cuando el índice no aparece en el vector. 
 Para representar dicho vector es más eficiente almacenar sólo los elementos distintos al valor 
por defecto, por lo que se propone la siguiente representación:

\begin{minted}{c++}
class vectorDisperso {
...
private:
      map<int,string> M; // map donde se alojan los elementos no nulos
      string v_def;     // valor por defecto
};
\end{minted}

\noindent
Así en el map M solamente almacenamos los valores diferentes al valor por defecto.
Dado un  \verb*|vectorDisperso| \verb*|V|, el elemento de la posición i-ésima del vector, $V[i]$, sería:

\begin{displaymath}
y = \left\{ \begin{array}{ll}
M[i] & \textrm{si $M.find(i)!=M.end()$}\\
v\_def & \textrm{en caso contrario}
\end{array} \right.
\end{displaymath}

\begin{enumerate}[a)]
      \item Dar una especificación (sintaxis y semántica) de los 5 métodos que consideres más relevantes de este nuevo TDA. Analizar la representación propuesta y determinar la FA y el IR.
      \item Implementar el método que cambie el valor por defecto del vector (hay que tener cuidado con los elementos del vector disperso anterior cuyo valor anterior fuese $nv$)
      \begin{center}
      \mint{c++}|void vectorDisperso::cambiar_valor_defecto(const string & nv)|
      \end{center}
\end{enumerate}

\begin{enumerate}[A.]
      \item
      \begin{enumerate}[1.]
      \item Método para consultar un valor del vector:
      \begin{enumerate}[---]
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características sintácticas}}: \mint{c++}|string vectorDisperso::getElemento (int i)|
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características semánticas}}: Devuelve el elemento que ocupa la posición i-ésima del vector.
      \end{enumerate}
      \item Método para insertar un valor en el vector:
      \begin{enumerate}[---]
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características sintácticas}}: \mint{c++}|void vectorDisperso::insertarElemento (string elemento)|
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características semánticas}}: Inserta el elemento \verb*|elemento| en el vector.
      \end{enumerate}
      \item Método para borrar un valor del vector:
      \begin{enumerate}[---]
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características sintácticas}}: \mint{c++}|void vectorDisperso::borrarElemento (int i)|
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características semánticas}} Borra el elemento i-ésimo del vector.
      \end{enumerate}
      \item Método para comprobar si un valor está en el vector o no:
      \begin{enumerate}
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características sintácticas}}: \mint{c++}|bool vectorDisperso::Esta (string s)|
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características semánticas}}: Comprueba que el elemento \verb*|s| está en el vector: devuelve true en caso de que esté y false en caso contrario.
      \end{enumerate}
      \item Función para saber el tamaño del vector
      \begin{enumerate}
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características sintácticas}}: \mint{c++}|int vectorDisperso::size ()|
            \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Características semánticas}}: Devuelve el número de elementos del vector.
      \end{enumerate}
      \item A la representación propuesta le falta un atributo privado para saber el número de elementos actual que hay en el vector. Este valor se incrementaría cada vez que insertamos un elemento y se decrementaría cada vez que borramos un elemento. Además, sería el valor devuelto por la función \verb*|size()|.
      \item La función de abstracción de este TDA sería:
      \begin{displaymath}
      f_A = r.M[0], r.M[1], \cdots, r.M[n - 1] \qquad\ M[i] \neq v\_def \qquad\ i=0,1,\cdots, M.size()
      \end{displaymath}
      \item El invariante de representación de este TDA sería:
      \begin{enumerate}[---]
            \item Los valores que coincidan con \verb*|v_def| no deben insertarse en \verb*|M|
            \item El tamaño total del vector debe ser igual al tamaño de \verb*|M| más el número de veces que hemos intentado insertar un elemento que se correspondía con \verb*|v_def|
      \end{enumerate}
      \end{enumerate}

      \item

\begin{minted}[linenos]{c++}
void vectorDisperso::cambiar_valor_defecto(const string & nv) {
      // cambiamos el valor por defecto
      v_def = nv;
      map<int,string>::iterator it=M.begin(),aux;
      while (it!=M.end()){
        if (it->second==nv){
            aux = it;
            ++it;
	    M.erase(aux);
	}
	else ++it;
      }
}
\end{minted}
\end{enumerate}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 3}
\begin{enumerate}[a)]
\item 
Usando el TDA \verb*|list<T>|, construir una función:

\begin{minted}{c++}
template <class T>
void dividir_lista (list<T> & entrada, T k)
\end{minted}

\noindent
que agrupe en la primera parte de la lista los elementos menores que $k$ y en la segunda los mayores o iguales. Han de usarse iteradores, no se permite usar ninguna estructura auxiliar, no puede modificarse el tamaño de la lista y la función ha de ser O($n$). Por ejemplo: Si es una \verb*|list<int>| \verb*|entrada={1,3,4,14,11,9,7,16,25,19,7,8,9}| y $k=8$, entonces la lista quedaría, por ejemplo, como: \textbf{entrada} = $\{\underbrace{1,3,4,7,7},\underbrace{9,11,16,25,19,14,8,9}\}.$

\item
Sea $A$ un árbol binario con $n$ nodos. Se define el ancestro común más cercano (AMC) entre 2 nodos $v$ y $w$ como el ancestro de mayor profundidad que tiene tanto a $v$ como a $w$ como descendientes (se entiende como caso extremo que un nodo es descendiente de sí mismo). Diseñar una función que tenga como entrada un árbol binario de enteros y dos nodos $v$ y $w$ como salida y el AMC de $v$ y $w$.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\begin{minted}[linenos]{c++}
void dividir_lista (list<int> & entrada, int k) {
    // debemos recorrer la lista con dos iteradores: uno al inicio de la lista y
    // otro al final, cuando veamos al inicio de la lista un valor mayor a k,
    // recorremos el final de la lista hasta encontrar un valor menor a k e 
    // intercambiamos sus valores.
    typename list<int>::iterator inicio, final;
    inicio = entrada.begin();
    final = entrada.end();
    --final;
    int aux;
    bool salir = false;

    while (final != inicio && !salir) {
        if (*inicio >= k) {
            while (*final >= k && !salir) {
                if (final == inicio)
                    salir = true;
                --final;
            }
            if (!salir) {
                aux = *inicio;
                *inicio = *final;
                *final = aux;
            }
        }
        ++inicio;
    }
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\noindent
Para calcular el AMC de dos nodos he implementado dos funciones extra: una para saber el nivel de un nodo y otra para buscar un ancestro común. El resultado final es:

\begin{minted}[linenos]{c++}
#include "arbolbinario.h"
#include <iostream>
using namespace std;

template <class T>
int getNivel (const ArbolBinario<T> &a, const typename ArbolBinario<T>::nodo &n) {
    int nivel = 0;
    typename ArbolBinario<T>::nodo aux(n);

    while (aux != a.getRaiz()) {
        aux = aux.padre();
        nivel++;
    }

    return nivel;
}

template <class T>
typename ArbolBinario<T>::nodo buscaPadreComun (
                        const typename ArbolBinario<T>::nodo &v, 
                        const typename ArbolBinario<T>::nodo &w,
                        const ArbolBinario<T> &a) {
    if (v.padre() == w.padre())
        return v.padre();

    else
        return buscaPadreComun (v.padre(), w.padre(), a);    
}

template <class T>
typename ArbolBinario<T>::nodo getAMC (const ArbolBinario<T> &a, 
                                const typename ArbolBinario<T>::nodo &v, 
                                const typename ArbolBinario<T>::nodo &w) {
    // Calculamos el nivel de los dos nodos
    int nivel_v = getNivel (a, v);
    int nivel_w = getNivel (a, w);

    // Comparamos ambos niveles y nos encontramos con varios casos:
    //      - Que ambos tengan el mismo nivel, entonces vamos subiendo
    //        a los niveles superiores hasta encontrar un padre comun
    //      - Que uno tenga mas nivel que el otro, entonces ponemos los 
    //        dos al mismo nivel y vamos buscando un padre comun

    if (nivel_v == nivel_w)
        return buscaPadreComun(v, w, a);

    else if (nivel_v > nivel_w) {
        return getAMC (a, v.padre(), w); 
    }

    else /* if (nivel_v < nivel_w) */ {
        return getAMC (a, v, w.padre());
    }
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 4}
\begin{enumerate}[a)]
      \item Construir un AVL (especificando los pasos seguidos) a partir de las claves $\{100,29,71,82,48,39,101,22\}$. Indicar cuando sea necesario el tipo de rotación que se usa para equilibrar.
      \item Insertar las claves $\{10,39,6,32,49,18,41,37\}$ en una Tabla Hash cerrada de tamaño 11, usando como función hash $h(k) = (2k + 5) \% 11$ y para resolver las colisiones rehashing doble usando como función hash secundaria $h_0 (k) = 7 - (k \% 7)$. ¿Cuál es el rendimiento de la tabla?
      \item Usando la clase \verb*|set| de la STL, construir una función que divida un conjunto de enteros $c$ en dos subconjuntos $cpar$ y $cimpar$ que contienen respectivamente los elementos pares e impares de $c$ y que devuelva \textbf{true} si el número de elementos de $cpar$ es mayor que el de $cimpar$ y \textbf{false} en caso contrario.
\begin{minted}{c++}
/**
      @brief Determina si un conjunto de enteros tiene mas elementos pares que impares
      @brief estableciendo su particion en dos subconjuntos
      @param c: conjunto de entrada
      @param cpar: subconjunto conteniendo los elementos pares
      @param cimpar: subconjunto conteniendo los elementos impares
      @return true si #cpar > #cimpar, false en caso contrario
*/
bool masparesqueimpares (const set<int> & c, set<int> & cpar, set<int> & cimpar);
\end{minted}
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\label{avl_feb2013}

\begin{enumerate}
      \item Insertamos el 100 como raíz del árbol, el 29 como hijo a la izquierda de 100 y el 71 como hijo a la derecha de 29. Llegamos a un desequilibrio de tipo B que se soluciona con una rotación doble: primero a la izquierda sobre 29 y luego a la derecha sobre 100:


      \begin{minipage}{0.4\textwidth}
      \[\begin{xy}
      ,(33,-8)*+=<10mm>[]\txt<2cm>{1.1}
      ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{100}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{29}
      % ,(10,-10)*+=<10mm>[]\txt<2cm>{6}
      % ,(-15,-20)*+=<10mm>[]\txt<2cm>{1}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{71}
      % ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{14}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      % \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      % \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      % \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18) % 14 al 15
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) % 7 al 6
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}
      \begin{minipage}{0.45\textwidth}
      \[\begin{xy}
      ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      ,(32,-12)*+=<20mm>[]\txt<2cm>{RSD(100)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{100}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{71}
      % ,(10,-10)*+=<10mm>[]\txt<2cm>{6}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      % ,(-5,-20)*+=<10mm>[]\txt<2cm>{71}
      % ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{14}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      % \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      % \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18) % 14 al 15
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      % \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) % 7 al 6
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}
      \begin{minipage}{0.3\textwidth}
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSD(100)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{71}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{29}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{100}
      % ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      % ,(-5,-20)*+=<10mm>[]\txt<2cm>{71}
      % ,(5,-20)*+=<10mm>[]\txt<2cm>{5}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{14}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{56}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      % \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      % \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18) % 14 al 15
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      % \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) % 7 al 6
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}

      \item Insertamos el 82 como hijo a la izquierda de 100, el 48 como hijo a la derecha de 29 y el 39 como hijo a la izquierda de 48. Llegaríamos a un desequilibrio de tipo C sobre 29: primero una rotación simple a la derecha sobre 48 y luego una rotación simple a la izquierda sobre 29:

      \begin{minipage}{0.5\textwidth}
      \[\begin{xy}
      ,(33,-8)*+=<10mm>[]\txt<2cm>{1.1}
      ,(32,-12)*+=<20mm>[]\txt<2cm>{RSD(48)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{71}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{29}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{100}
      % ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{48}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{35}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      ,(-10,-30)*+=<10mm>[]\txt<2cm>{39}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{38}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      % \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}
      \begin{minipage}{0.5\textwidth}
      \[\begin{xy}
      ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{71}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{29}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{100}
      % ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{39}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{39}
      ,(0,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      % \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}
      \begin{minipage}{0.5\textwidth}
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{71}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{39}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{100}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{48}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{39}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) 
      \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}

      \item Insertamos el 101 como hijo a la derecha de 100 y el 22 como hijo a la izquierda de 29.

      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{71}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{39}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{100}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{29}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{48}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      ,(15,-20)*+=<10mm>[]\txt<2cm>{101}
      ,(-20,-30)*+=<10mm>[]\txt<2cm>{22}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{39}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) 
      \ar@{-} (10,-12);(5,-18)
      \ar@{-} (10,-12);(15,-18)
      \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\noindent
Las funciones a usar serían:
\begin{enumerate}[$\longrightarrow$]
      \item $h(k) = (2k + 5) \% 11$
      \item $h_0 (k) = 7 - (k \% 7)$
      \item $h_i (k) = ((h_{i-1}(k) + h_0 (k)))\%11$
\end{enumerate}

\begin{minipage}{0.5\textwidth}
\begin{tabular}{c|c|c}
$h(k)$ & $k$ & registro \\
\hline
0 & & \\
1 & & \\
2 & 37 & 7 \\
3 & 10 & 0 \\
4 & 49  & 4 \\
5 & & \\
6 & 39 & 1 \\
7 & 6 & 2 \\
8 & 18 & 5 \\
9 & 32 & 3 \\
10 & 41 & 6 \\
\end{tabular}
\end{minipage}
\begin{minipage}{0.7\textwidth}
\begin{enumerate}[$\heartsuit$]
      \item $h(10) = (20 + 5) \% 11 = 3$
      \item $h(39) = (78 + 5) \% 11 = 6$
      \item $h(6) = (12 + 5) \% 11 = 6 \longleftarrow$ Colisión
      \begin{enumerate}[$\bigstar$]
            \item $h_0 (6) = 7 - (6 \% 7) = 1$
            \item $h_2 (6) = (6+1)\%11 = 7$
      \end{enumerate}
      \item $h(32) = (64 + 5) \% 11 = 3 \longleftarrow$ Colisión
      \begin{enumerate}[$\bigstar$]
            \item $h_0 (32) = 7 - (32 \% 7) = 3$
            \item $h_2 (32) = (3+3)\%11 = 6 \% 11 = 6$
            \item $h_3 (32) = (6+3) \%11 = 9$
      \end{enumerate}
      \item $h(49) = (98 + 5) \% 11 = 4 $ 
      \item $h(18) = (36 + 5) \% 11 = 8 $
      \item $h(41) = (82+5) \% 11 = 10$
      \item $h(37) = (74+5) \% 11 = 2$
\end{enumerate}
\end{minipage}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado c}

\begin{minted}[linenos]{c++}
#include <set>
#include <iostream>
#include <ostream>
using namespace std;

bool masparesqueimpares (const set<int> & c, set<int> & cpar, set<int> & cimpar) {
    set<int>::const_iterator i;

    for (i = c.begin(); i != c.end(); ++i) {
        if (((*i)%2)==0)
            cpar.insert(*i);

        else
            cimpar.insert(*i);
    }
    return cpar.size() > cimpar.size();
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 5}
\noindent
Dado un árbol binario de enteros, se dice que está sesgado a la izquierda si para cada nodo, se satisface que la etiqueta de su hijo izquierda es menor que la de su hijo derecha (en caso de tener un sólo hijo, éste ha de situarse necesariamente a la izquierda).

\noindent
Se pide:
\begin{enumerate}[a)]
      \item Implementar un método que compruebe si un árbol binario $A$ está sesgado hacia la izquierda.
      \item Implementar un método que transforme un árbol binario en un árbol sesgado hacia la izquierda. La transformación debe preservar que si un nodo $v$ es descendiente de otro $w$ en A, también lo debe ser en el árbol transformado, por lo que no es válido hacer un intercambio de las etiquetas de los nodos.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}

\begin{minted}[linenos]{c++}
#include "arbolbinario.h"
#include <iostream>
using namespace std;

bool EstaSesgado (ArbolBinario<int> & a) {
    bool sesgado = true;
    ArbolBinario<int>::preorden_iterador i;

    for (i = a.beginpreorden(); i != a.endpreorden() && sesgado; ++i)
        
        if (i.hi.nulo() && !i.hd().nulo()) sesgado=false;
        else
          if (!i.hd().nulo() &&!i.hi().nulo() (*i.hi()) >= (*i.hd()))
            sesgado = false;

    return sesgado;   
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}

\begin{minted}[linenos]{c++}
void TransformaEnSesgado (const ArbolBinario<int>::nodo & n, ArbolBinario<int> & a) {
    // cuando no se cumpla la condicion de arbol sesgado debemos 
    // podar ambas ramas e intercambiarlas.
    ArbolBinario<int> a1;
    ArbolBinario<int> a2;

    if (!n.hd().nulo() && !n.hi().nulo() && (*n.hi()) >= (*n.hd())) {
        a1 = a.PodarHi_GetSubtree (n);
        a2 = a.PodarHd_GetSubtree (n);
        a.Insertar_Hi (n, a2);
        a.Insertar_Hd (n, a1);
    }

    if (!n.hi().nulo())
        return TransformaEnSesgado (n.hi(), a);

    if (!n.hd().nulo())
        return TransformaEnSesgado (n.hd(), a);
}
\end{minted}

\section{\textcolor[rgb]{0.5,0.8,1}Septiembre 2012}
\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 1}
\noindent
Usando la notación O, determinar la eficiencia de los siguientes segmentos de código:
\begin{minted}{c++}
int i=1; int x=0;                int i = 2; int x = 0;
do {                             do {
      int j= 1;                           int j = 1;
      while (j <= n) {                    while (j <= i) {
            j= j*2;                             j *= 2;
            x++;                                x++;
      }                                   }
      i++;                                i++;
} while (i<=n);                  } while (i <= n);
\end{minted}

\noindent
Resuelto como ejemplo en el \hyperref[eficiencia_sept2012]{tema 1}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 2}
\noindent
Se desea diseñar un TDA \textbf{colec\_ord} que representa a una coleccion ordenada de enteros y donde las únicas operaciones permitidas son \textbf{insertar}, \textbf{borrar minimo}, \textbf{buscar} y \textbf{cuantos fuera de rango}. Las operaciones insertar, borrar mínimo y buscar, respectivamente añaden, borran el elemento mínimo y buscan un entero en la colección, y la operación cuantos fuera de rango tiene como parámetros un rango de valores enteros [a,b] (a$<$b) y devuelve un valor entero indicando \underline{cuantos} de los enteros de la colección son menores que a o mayores que b. Analiza la eficiencia de las operaciones si la representación del TDA fuese:
\begin{enumerate}[a)]
      \item Un vector dinámico
      \item Una lista
      \item Una cola con prioridad
      \item Un ABB
      \item un AVL
\end{enumerate}

\noindent
¿Qué implementaciín escogerías para el TDA?

\noindent
Teniendo en cuenta que la colección estaría ordenada de menor a mayor:


\begin{tabular}{c|c|c|c|c}
& \textbf{insertar} & \textbf{borrar\_minimo} & \textbf{buscar} & \textbf{cuantos\_fuera\_de\_rango} \\
\hline
vector dinámico & O($n$) & O($n$) & O($log_2 (n)$ & O($log_2 (n)$ \\
lista & O(n) & O(1) & O($n$) & O($n$) \\
priority\_queue & O($log_2(n)$)) & O(1) & O($n$) & O($n$) \\
ABB & O($n$) & O($n$) & O($n$) & O($n$) \\
AVL & O($log_2 (n)$) &O($log_2 (n)$)&O($log_2 (n)$) & O($n$) \\
\end{tabular}

\noindent


Escogería un AVL porque es lo más eficiente.

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 3}
\noindent
Un departamento comercial dispone de $N$ productos. Se pretende implementar un sistema capaz de gestionar a $M$ usuarios. Para cada usuario se ha de almacenar los productos que éste ha adquirido. Se supone que tanto el usuario, como el producto vienen identificados por dos etiquetas de tipo \verb*|string| así como que un usuario suele comprar un número de productos distintos mucho menos que $N$. Se pide:

\begin{enumerate}[a)]
      \item Proponer dos representaciones distintas para un tipo de dato \verb*|sistema| capaz de gestionar dicha información de forma eficiente. Para cada representación indicar su función de abstracción e invariante de representación. Analizar las ventajas e inconvenientes de las representaciones propuestas.
      \item Seleccionar una de ellas e implementar los siguientes métodos:
      \mint{c++}|void sistema::comprar (const string &user, const string & prod)| que en orden O($log(M)$) almacena que el usuario \verb*|user| ha adquirido el producto \verb*|prod|.
      \mint{c++}|string sistema::superventas()| que devuelve el nombre del producto que ha sido adquirido más frecuentemente por los usuarios del sistema.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\begin{description}
\item[Representación 1]: con esta representación tenemos guardada de la forma más eficiente posible todo lo que exige el enunciado, con el inconveniente de que podemos añadir productos sin ton ni són al mapa de productos. Solución: guardar los productos disponibles en un enumerado.
\begin{minted}{c++}
class sistema {
private:
      // guardamos los usuarios y sus compras
      map<string,list<string> > usuarios;
      // guardamos cada producto y el numero de items disponibles
      map<string, int> productos;
};
\end{minted}
\begin{enumerate}[$\clubsuit$]
\item \textbf{\textcolor[rgb]{0.5,0.8,1}{Función de abstracción}}:
\begin{displaymath}
f_A = r.usuarios\{r.usuario0\{nombre, \{prod0, prod1...\}...\}\},
\end{displaymath}
\begin{displaymath}
      r.productos\{r.prod1\{nombre,cantidad\}...\};
\end{displaymath}
\item \textbf{\textcolor[rgb]{0.5,0.8,1}{Invariante de la representación}}:
\begin{enumerate}[$\longrightarrow$]
\item No puede haber usuarios repetidos ni productos repetidos
\item El tamaño de la lista de productos comprados por un usuario debe ser menor al número de productos totales.
\end{enumerate}
\end{enumerate}

\item[Representación 2]: Añadimos el enumerado mencionado anteriormente para corregir ese problema.
\begin{minted}{c++}
class sistema {
private:
      enum prods {producto1, producto2, producto3, producto4};
      map<string, list<prods> > usuarios;
      map<prods, unsigned> productos;
}
\end{minted}

\noindent
El invariante de representación y la función de abstracción son los mismos que en el caso anterior.
\end{description}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\begin{minted}[linenos]{c++}
void sistema::comprar (const string &user, const string &prod) {
      usuarios[user].second.push_back(prod);
      productos[prod].second--;
}

string sistema::superventas() {
      map<prods, unsigned> aux = productos;
      map<prods, unsigned>::iterator i;

      // inicializamos un map con todos los productos a cero
      for (i = aux.begin(); i != aux.end(); ++i)
            (*i).second = 0;

      map<string, list<prods> >::iterator it;
      list<prods>::iterator ite;

      // recorremos el map de usuarios y vamos calculando el numero de veces que 
      // se ha comprado cada cosa
      for (it = usuarios.begin(); it != usuarios.end(); ++it)
            for (ite = (*it).second.begin(); ite != (*it).second.end(); ++ite)
                  aux[(*ite)]++;

      // Devolvemos el nombre del producto que se haya comprado más veces.
      i = aux.begin();
      string mascomprado = (*i).first;
      int n = (*i).second;
      ++i;
      map<prods, unsigned>::iterator iter = i;

      for (iter = i; iter != aux.end(); ++iter)
            if ((*iter).second > n)
                  mascomprado = (*iter).first;

      return mascomprado;
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 4}
\noindent
Se dispone de una secuencia de enteros almacenados en una cola y se desea comprobar si dicha secuencia en \textit{orden inverso} coincide con alguna subsecuencia de elementos de una pila $P$. Por ejemplo, si la cola es \verb*|C=<3,8,5>| ó \verb*|C=<2,3,8>| y la Pila \verb*|P=<5,8,3,2,4>| sería cierto, pero si la cola fuese por ejemplo \verb*|C1=<3,8>| ó \verb*|C2=<4,8,5>| y tuviesemos la misma pila $P$ sería falso. Usando solamente los TDA Pila y Cola, diseñar una función \mint{c++}|bool condicion (stack<int> &P, queue<int> &Q)| que compruebe si la condición se cumple. Únicamente se puede usar una pila adicional.

\begin{minted}[linenos]{c++}
#include <iostream>
#include <stack>
#include <queue>
using namespace std;

bool condicion (stack<int> &P, queue<int> &Q) {
    stack<int> aux;

    while (!Q.empty()) {
        aux.push(Q.front());
        Q.pop();
    }

    bool cond = false, continuar = true;
    unsigned tam_aux = aux.size();

    while (!aux.empty() && continuar && !P.empty()) {
        if (aux.top() == P.top()) {
            cond = true;
            aux.pop();
        }

        else {
            cond = false;
            if (tam_aux > aux.size())
                continuar = false;
        }

        P.pop();
    }

    return cond;
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 5}
\noindent
Usando el TDA \verb*|list<int>|, construir una función \mint{c++}|void agrupar_elemento (list<int> & entrada, int k)| que agrupe de forma consecutiva en la lista de entrada todas las apariciones del elemento $k$ en la lista, a partir de la primera ocurrencia. Por ejemplo, si \verb*|entrada={1,3,4,1,4}| y $k=1$, entonces \verb*|entrada={1,1,3,4,4}|, o si, \verb*|entrada={3,1,4,1,4,1,1}| y $k=1$, entonces \verb*|entrada={3,1,1,1,1,4,4}|.

\begin{minted}[linenos]{c++}
#include <list>
using namespace std;

void agrupar_elemento (list<int> & entrada, int k) {
    list<int>::iterator element, it;
    element = entrada.end();
    int contador = 0;

    // recorremos la lista para encontrar la primera ocurrencia
    // una vez encontrada dejamos el iterador fijo y con un
    // entero, contamos el número de veces que aparece k en 
    // dicha lista y borramos todas las apariciones de k que
    // nos encontremos menos la que es apuntada por element.

    for (it = entrada.begin(); it != entrada.end(); ++it) {
        if ((*it) == k && element == entrada.end())
            element = it;

        else if ((*it) == k) {
            contador++;
            it = entrada.erase(it);
            --it;
        }
    }

    entrada.insert(element,contador,k);
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 6}
\noindent
Hecho en \hyperref[avl_feb2013]{Febrero 2012}

\section{\textcolor[rgb]{0.5,0.8,1}Febrero 2013}
\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 1}
\noindent
Usando la notación O, determinar la eficiencia de la siguiente función ($n$ es una potencia de 2):

\begin{minted}{c++}
int eficexamen (bool existe) {
      int sum2=0; int k,j,n;
      if (existe)
            for (k=1; k<=n; k*=2)
                  for (j=1; j<=k; j++)
                        sum2++;

      else
            for (k=1; k<=n; k*=2)
                  for (j=1; j<=n; j++)
                        sum2++;

      return sum2;
}
\end{minted}

\noindent
Tenemos dos trozos de código independientes, por tanto, debemos calcular su eficiencia por separado y ver cuál es mayor.

\noindent
Dentro del primer if tenemos dos bucles for anidados. El bucle más interno se correspondería con la siguiente sumatoria:

\begin{displaymath}
\sum_{j=1}^k 1 = k
\end{displaymath}

\noindent
El bucle externo, se ejecuta $log_2 (n)$ veces, y va multiplicando la $k$ por dos en cada iteración, por tanto tenemos una progresión aritmética. Por tanto, la eficiencia del bucle sería:

\begin{displaymath}
\sum_{k=1}^{log_2 (n)} k = 1 + 2 + \cdots + log_2 (n) = (log_2 (n) + 1) \cdot \frac{log_2 (n)}{2}
\end{displaymath}

\noindent
Por tanto, podemos concluir que la eficiencia del primer bloque de código sería O($log_2 (n) \cdot log_2(n)$)

\noindent
Dentro del else, tenemos dos bucles for anidados. En el bucle más interno tenemos la siguiente sumatoria:

\begin{displaymath}
\sum_{j=1}^n 1 = n
\end{displaymath}

\noindent
Y dentro del segundo, tenemos la siguiente sumatoria:

\begin{displaymath}
\sum_{k=1}^{log_2 (n)} n = \cdot \sum_{k=1}^{log_2 (n)} = n \cdot log_2 (n)
\end{displaymath}

\noindent
Por tanto, la eficiencia del segundo trozo de código sería O($n log_2(n)$). Y aplicando la regla de la suma, la eficiencia de la función sería O($n log_2 (n)$)

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 2}
\noindent
Rellenar la siguiente tabla con la eficiencia de las operaciones de las filas en las estructuras de datos de las columnas

\begin{tabular}{p{1.5cm}|c|c|c|c|c|c}
& Vector ordenado & Lista ordenada & Pila & ABB & AVL & Tabla Hash \\
\hline
Buscar & O($log_2(n)$) & O($n$) & O($n$) & O($n$) & O($log_2 (n)$) & O(n) \\
Insertar & O($n$) & O(n) & O(1) & O($n$) & O($log_2(n($) & O($1$) \\
Borrar & O($n$) & O(1) & O(n) & O($n$) & O($log_2(n)$) & O(1) \\
Imprimir ordenadamente & O($n$) & O($nlog_2(n)$) & O($n$) & O($n$) & O($n$) &O($n$) \\
\end{tabular}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 3}
\noindent
Una empresa mantiene datos sobre personas (DNI, apellidos, nombre, domicilio y teléfono, todos de tipo string) y necesita poder hacer búsquedas sobre ellos tanto por DNI como por apellidos. Define una representación eficiente (discutiendo las alternativas) para manejar los datos de la empresa e implementa las operaciones de inserción y de borrado de una persona en dicha estructura. Las cabeceras serían:

\mint{c++}|void datos::insertar (const persona &p)|

\mint{c++}|void datos::borrar(const persona &p)|

\noindent
Una alternativa, sería tener en un \verb*|map<string,string>| el DNI como key y los apellidos como value y otro map con los apellidos como key y el resto de datos de una persona como value. Así, si queremos hacer una búsqueda por apellidos, nos iríamos directamente al segundo map pero, si queremos buscar por DNI sólo tendríamos que encontrar el apellido y luego usar ese valor para buscar el resto de datos. El inconveniente de esto sería el gasto de memoria que supone tener dos maps en memoria.

\noindent
Una representación más óptima, sería tener un map que relacionase los apellidos con el DNI y, una tabla hash en la que la key fuese el DNI, así reducimos el gasto en memoria pero seguimos teniendo una búsqueda eficiente.

\begin{minted}[linenos]{c++}
// datos.h
// Se da por hecho que la clase TH esta ya definida
#include "TH.h"
#include <map>
#include <utility>
#include <iostream>
using namespace std;

struct persona {
      string DNI;
      string apellidos;
      string nombre;
      string domicilio;
      string telefono;
};

class datos {
private:
      map<string,string> id;
      TH usuarios;
public:
      void insertar (const persona &p);
      void borrar (const persona &p);
};
\end{minted}

\begin{minted}[linenos]{c++}
// datos.cpp
void datos::insertar (const persona &p) {
      // insertamos a la persona en el map
      id.insert(pair<string,string>(p.apellidos, p.DNI));

      // y ahora, insertamos a la persona en la tabla hash
      // con el DNI como clave
      if (usuarios.Insertar(p.DNI, p))
            cout << "Usuario insertado con exito" << endl;
}

void datos::borrar (const persona &p) {
      // borramos a dicha persona del map
      id.erase(p.apellidos);

      // borramos a dicha persona de la tabla hash
      usuarios.Borrar(p.DNI);
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 4}
\noindent
Dadas dos listas de intervalos cerrados [ini,fin], $L1$ y $L2$, donde para cada lista los intervalos se encuentran ordenados por orden de tiempo de inicio satisfaciendo que si un intervalo $it1$ está antes que otro $it2$ en la lista entonces $it1.fin < it2.ini$.

\noindent
Diseña un método que permita seleccionar un (sub)intervalo de $L1$ y lo pase a $L2$. En este proceso podría ser necesario que el dividir un intervalo de $L1$ así como fusionar intervalos en $L2$ cuando ocurran solapamientos.

\mint{c++}|typedef pair<int,int> intervalo;|
\mint{c++}|bool Extraer (list<intervalo> & l1, intervalo x, list<intervalo> & L2);|
Devuelve true si ha sido posible realizar la extracción ($x$ debe pertenecer a un único intervalo de $L1$)

\noindent
Por ejemplo, si \verb*|L1=[1,7],[10,14],[18,20],[25,26];| \verb*|L2=[0.1],[14,16],[20,23]| y \verb*|x=[12,14]|. Entonces las listas quedarán como \verb*|L1=[1,7],[10,11],[18,20],[25,26];| y \verb*|L2=[0.1],[12,16],[20,23]|. De igual forma, si \verb*|L1=[1,7],[10,22],[25,26];| \verb*|L2=[0,1],[14,16],[20,23]| y \verb*|x=[12,20]| entonces las listas quedarían como \verb*|L1=[1,7],[10,11],[21,22],[25,26];| \verb*|L2=[0,1],[14,16],[12,23]|


\begin{minted}[linenos]{c++}
bool Extraer (list<intervalo> & l1, intervalo x, list<intervalo> & l2) {
    list<intervalo>::iterator it1;
    bool continuar1 = true;

    for (it1=l1.begin(); it1!=l1.end() && continuar1;++it1) {
        if (x.first < (*it1).second) {
            int aux = (*it1).second;
            (*it1).second = x.first - 1;
            if (aux > x.second) {
                intervalo nuevo ((x.second+1),aux);
                ++it1;
                l1.insert(it1,nuevo);
            }
            continuar1 = false;
        }
    }

    list<intervalo>::iterator it2;
    bool continuar2 = true;

    for (it2=l2.begin();it2!=l2.end() && continuar2;++it2) {
        if (x.second <= (*it2).first) {
            (*it2).first = x.first;
            it1 = it2;
            --it1;
            if ((*it2).first < (*it1).first) 
                it1 = l2.erase(it1);

            continuar2 = false;
        }
    }

    return !(continuar1 && continuar2);
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 5}
\noindent
Un árbol de sucesos es un árbol binario donde cada nodo tiene asociada una etiqueta con un valor real en el intervalo [0,1]. Cada nodo que no es hoja cumple la propiedad de que la suma de los valores de las etiquetas de sus hijos es 1. Un suceso es una hoja y la probabilidad de que éste ocurra viene determinada por el producto de los valores de las etiquetas de los nodos que se encuentran en el camino que parte de la raíz y acaba en dicha hoja. Se dice que un suceso es probable si la probabilidad de que ocurra es mayor que 0.5. Usando el TDA Árbol binario:

\begin{enumerate}[a)]
      \item Diseñar una función que compruebe si un árbol binario $A$ es un árbol de sucesos. Su prototipo será \mint{c++}|bool check_rep (const bintree<float> &A)|
      \item Diseñar una función que indique si existe algún suceso probable en el árbol de probabilidades $A$. Su prototipo será: \mint{c++}|bool probable (const bintree<float> &A)|
\end{enumerate}

\noindent
Por ejemplo: en el árbol de probabilidades de la derecha no existe un suceso probable porque los tres sucesos tienen probabilidad inferior a 0.5:
\begin{enumerate}[---]
      \item A: $1.0 \cdot 0.6 \cdot 0.3 = 0.18$
      \item B: $1.0 \cdot 0.6 \cdot 0.7 = 0.42$
      \item C: $1.0 \cdot 0.4 = 0.4$
\end{enumerate}

\noindent
En cambio, en el árbol de la izquierda hay un suceso probable: E, porque $1.0 \cdot 0.7 \cdot 0.8 = 0.56$

      \begin{minipage}{0.5\textwidth}
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{1}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{0.7}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{0.3 C}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{D 0.2}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{0.8 E}
      % ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{D 0.2}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{0.8 E}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      % \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}
      \begin{minipage}{0.5\textwidth}
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{1}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{0.6}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{0.4}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{A 0.3}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{0.7 B}
      % ,(5,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(15,-20)*+=<10mm>[]\txt<2cm>{82}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{48}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{D 0.2}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{0.8 E}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      % \ar@{-} (10,-12);(5,-18)
      % \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-15,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
      \end{minipage}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}

\begin{minted}[linenos]{c++}
bool check_rep_nodo (const bintree<float>::nodo &n) {
    if (!n.hi().nulo() && !n.hd().nulo()) {
        if (((*n.hi()) + (*n.hd())) == 1.0) {
            return check_rep_nodo(n.hi());
            return check_rep_nodo(n.hd());
        }
        else
            return false;
    }

    else // el nodo es una hoja
        return true;
}

bool check_rep (const bintree<float> &A) {
    return check_rep_nodo(A.getRaiz());
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}

\begin{minted}[linenos]{c++}
float probable_nodo (const bintree<float>::nodo &n) {
    if (n.hi().nulo() && n.hd().nulo())
        return *n;

    else {
        float v_i = probable_nodo(n.hi());
        if ((*n * v_i) > 0.5)
            return *n * v_i;

        float v_d = probable_nodo(n.hd());
        if ((*n * v_d) > 0.5)
            return *n * v_d;

        return 0; 
    }
}

bool probable (const bintree<float> &A) {
    return probable_nodo (A.getRaiz()) >= 0.5;
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 6}
\noindent
Supongamos que en una Tabla Hash abierta hacemos uso en cada cubeta de árboles AVL en lugar de listas.
\begin{enumerate}[a)]
      \item ¿Cuál es la eficiencia (en el caso peor) de la función buscar?
      \item Mostrar la tabla resultante de insertar los elementos $\{16,72,826,1016,12,42,623,22,32\}$
      \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
      \hline
      $x$ & 16 & 72 & 826 & 1016 & 12 & 42 & 623 & 22 & 32 \\
      \hline
      $h(x)$ & 6 & 2 & 6 & 6 & 2 & 2 & 3 & 2 & 2 \\
      \hline
      \end{tabular}
      \item Construir un APO a partir del anterior conjunto de claves y a continuación elimina el elemento más pequeño.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\noindent
Podríamos decir que por cada cubeta tenemos un AVL con muy pocos nodos y que por tanto, por cada cubeta tendríamos una búqueda en O(1), pero lo más exacto es decir que la búsqueda en un AVL es $log_2 (n)$ siendo $n$ el número de elementos que hay en dicha cubeta.

\noindent
Por tanto, como cuando buscamos en una tabla hash sólo accedemos a los elementos de una cubeta, la búsqueda se haría en O($log_2 (n)$).

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\noindent
\begin{tabular}{c|l}
$h(x)$ & Nodos del AVL \\
\hline
0 & \\
1 & \\
2 & 72, 12, 42, 22, 32 \\
3 & 623 \\
4 & \\
5 & \\
6 & 16, 826, 1016 \\
\end{tabular}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado c}
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{12}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{16}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{42}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{22}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{72}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{826}
      ,(15,-20)*+=<10mm>[]\txt<2cm>{623}
      ,(-20,-30)*+=<10mm>[]\txt<2cm>{1016}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      ,(-10,-30)*+=<10mm>[]\txt<2cm>{32}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{0.8 E}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      \ar@{-} (10,-12);(15,-18)
      \ar@{-} (-15,-22);(-20,-28)
      \ar@{-} (-15,-22);(-10,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]

\noindent
Para eliminar la raíz, el 12, lo sustituíriamos por el 32 y después, intercambiaríamos el 32 por el menor hijo de la raíz, el 16. No se cumple la condición de APO, así que lo volvemos a intercambiar con su menor hijo, el 22, obteniendo el siguiente árbol:

      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{16}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{22}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{32}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{32}
      ,(-5,-20)*+=<10mm>[]\txt<2cm>{42}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{72}
      ,(15,-20)*+=<10mm>[]\txt<2cm>{623}
      ,(-20,-30)*+=<10mm>[]\txt<2cm>{1016}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{1016}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{0.8 E}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      \ar@{-} (10,-12);(15,-18)
      \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-10,-28)
      \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (-5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]

\section{\textcolor[rgb]{0.5,0.8,1}Febrero 2014}
\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 1}
\noindent
Dado el TDA Montón de Cartas, con $N$ cartas de la baraja española, y con las siguientes operaciones:

\begin{enumerate}[$\bullet$]
      \item \textbf{\textcolor[rgb]{0.5,0.8,1}{Barajar}}: dispone las $N$ cartas en orden aleatorio
      \item \textbf{\textcolor[rgb]{0.5,0.8,1}{CogerCarta}}: devuelve la carta tope del montón
      \item \textbf{\textcolor[rgb]{0.5,0.8,1}{EliminarCarta}}: elimina la carta en el tope del montón
      \item \textbf{\textcolor[rgb]{0.5,0.8,1}{InsertarCarta}}: inserta una carta al final del montón.
\end{enumerate}

\begin{enumerate}[a)]
      \item Deducir la eficiencia de las cuatro funciones suponiendo que representamos el TDA Montón de cartas como:
      \begin{enumerate}[1)]
            \item Vector
            \item Lista
            \item Pila
            \item Cola
      \end{enumerate}
      \item Implementar la función Barajar suponiendo que el TDA Montón de cartas se representa como:
      \begin{enumerate}[1)]
            \item Vector
            \item Lista
            \item Pila
            \item Cola
      \end{enumerate}
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\begin{tabular}{c|c|c|c|c}
& Vector & Lista & Pila & Cola \\
\hline
Barajar & O($n$) & O($n$) & O($n$) & O($n$) \\
CogerCarta & O(1) & O(1) & O(1) & O(1)/O(n) \\
EliminarCarta & O($n$) & O(1) & O(1) & O(1)/O($n$) \\
InsertarCarta & O($n$)/O(1) & O(1) & O(n) & O($n$)/O(1)\\
\end{tabular}

\noindent
El barajar en una pila y en una cola, podemos implementarlo tal y como implementaríamos el de vector y así conseguir eficiencia O($n$).

\noindent
En la cola, si el tope está en el frente, tanto cogercarta como eliminarcarta serían O(1) e insertarcarta sería O($n$). Si el frente está en el último elemento de la cola, sería al revés.

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\begin{description}
      \item[Vector]:
      \begin{minted}{c++}
      void Barajar (vector<Carta> & v) {
            for (int i = 0; i < v.size(); i++) {
                  Carta aux = v.at(i);
                  v.at(i) = v.at((i*2)%(v.size()-1));
                  v.at((i*2)%(v.size()-1)) = aux;     
            }
      }
      \end{minted}

      \item[Lista]:
      \begin{minted}{c++}
      void Barajar (list<Carta> & l) {
            // Metemos los elementos en un vector y los barajamos
            // asi conseguimos eficiencia O(n)
            vector<Carta> aux;
            list<Carta>::iterator it;
            for (it = l.begin(); it != l.end(); ++it)
                  aux.push_back(*it);

            Barajar(aux);
            l.clear();

            for (int i=0; i<aux.size(); i++)
                  l.push_back(aux.at(i));
      }
      \end{minted}

      \item[Pila]:
      \begin{minted}{c++}
      void Barajar (stack<Carta> & s) {
            // Metemos los elementos en un vector y los barajamos
            // asi conseguimos eficiencia O(n)
            vector<Carta> aux;
            while (!s.empty()) {
                  aux.push_back(s.top());
                  s.pop();
            }

            Barajar(aux);

            for (int i=0; i<aux.size(); i++)
                  s.push(aux.at(i));
      }
      \end{minted}

      \item[Cola]:
      \begin{minted}{c++}
      void Barajar (queue<Carta> & q) {
            // Metemos los elementos en un vector y los barajamos
            // asi conseguimos eficiencia O(n)
            vector<Carta> aux;
            while (!q.empty()) {
                  aux.push_back(q.front());
                  q.pop();
            }

            Barajar(aux);

            for (int i=0; i<aux.size(); i++)
                  q.push(aux.at(i));
      }
      \end{minted}
\end{description}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 2}
\noindent
Dados dos multiset con elementos enteros, implementar la función:

\mint{c++}|multiset<int> multi_interseccion (const multiset<int> & m1, const multiset<int> & m2)|

\noindent
que calcula la intersección de dos multiset: \textit{elementos comunes en los dos multiset repetidos tantas veces como aparezcan en el multiset con menor número de apariciones del elemento}.

\noindent
Por ejemplo, siendo $m1 = \{2,2,3,3\}$ y $m2 = \{1,2,3,3,3,4\}$ entonces $m1 \cap m2 = \{2,3,3\}$ ó si $m1 = \{2,2,2,3,3\}$ y $m2 = \{1,2,2,2,2,3,3,3,4\}$ entonces $m1 \cap m2 = \{2,2,2,3,3\}$

\begin{minted}[linenos]{c++}
multiset<int> multi_interseccion (const multiset<int> & m1, const multiset<int> & m2) {
    multiset<int>::const_iterator it1, it2;
    multiset<int> inter;
    it1 = m1.begin();
    it2 = m2.begin();

    while (it1 != m1.end() && it2 != m2.end()) {
        if (*it1 < *it2)
            ++it1;

        else if (*it2 < *it1)
            ++it2;

        else { // if (*it1 == *it2)
            inter.insert(*it1);
            ++it1;
            ++it2;
        }
    }

    return inter; 
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 3}
\noindent
Suponed que tenemos el TDA Tabla Hash abierta (unordered\_set) (class TH), en la que la resolución de colisiones se hace utilizando para cada cubo una lista.

\begin{minted}[linenos]{c++}
#include <vector>
#include <list>
using namespace std;

class TH {
private:
      struct info {
            int key; //clave
            int di;  // direccion
      };
      vector<list<info> > data;
      int fhash (int k)const;
      bool recolocar () const;
public:
...
      void insertar(int k, int d);
...
      class iterator {
      private:
            list<info>::iterator it_cub;
            vector<list<info> >::iterator it;
            ...
      };
      iterator begin ();
      iterator end();
};
\end{minted}

\begin{enumerate}[a)]
\item Implementar la función \textbf{insertar} suponiendo que tenemos implementada la función hash (\textbf{fhash}). Después de añadir la nueva clave $k$ y su dirección asociada $d$, la función \textbf{insertar} debe comprobar si es necesario redimensionar la tabla hash. Para ello se supone que tenemos implementada la función \textbf{recolocar}. Esta función devuelve verdadero en el caso que sea necesario pasar todos los datos a una nueva tabla de mayor tamaño, y false en caso contrario. El tamaño de la nueva tabla tiene que ser el primo más cercano a $2M$ por exceso, siendo $M$ el tamaño original.
\item Implementar la \textbf{clase iterator} (un iterador sobre todos los elementos de la tabla hash) de la tabla hash, así como las funciones \textbf{begin} y \textbf{end} de la clase TH.
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\begin{minted}[linenos]{c++}
void insertar (int k, int d) {
      int fh = fhash (k);
      info nuevo = {k, d};
      data.at(fh).push_back(nuevo);

      if (recolocar()) {
            int tam = nextprimo(2*data.size());
            vector<list<info> > d (tam);
            for (int i=0; i<data.size(); i++) {
                  list<info>::iterator it;
                  for (it = data.at(i).begin(); i != data.at(i).end(); ++i) {
                        int p = (*it).key % tam;
                        d.at(p).push_back(*it);
                  }
            }
            data = d;
      }
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\begin{minted}[linenos]{c++}
class iterator {
private:
      list<info>::iterator it_cub;
      vector<list<info> >::iterator it;
      vector<list<info> >::iterator fin;
public:
      iterator operator++ () {
            if (it_cub != end())
                  ++it_cub;

            else if (it != fin) {
                  ++it;
                  it_cub = (*it).begin();
            }

            else
                  it = it_cub = fin;

            return *this;
      }

      info operator * () {
            return (*it_cub);
      }

};
iterator begin() {
      iterator i;
      i.it = data.begin();
      i.fin = data.end();
      it_cub = (*i.it).begin();
      if (it_cub == (*i.it).end())
            ++it_cub;

      return this;
}

iterator end() {
      iterator i;
      i.it = data.end();
      --i.it;
      i.fin = data.end();
      it_cub = (*i.it).end();

      return *this;
}
\end{minted}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 4}
\begin{enumerate}[a)]
      \item Dado un árbol binario de enteros (positivos y negativos) implementar una función que obtenga el número de caminos, en los que la suma de las etiquetas de los nodos que los componen sumen exactamente $k$
      \mint{c++}|int NumeroCaminos (bintree<int> & ab, int k);|
      \item Construir el AVL y el APO que resultan de insertar (en ese orden) los elementos del conjunto de enteros $\{45,23,12,20,15,22,24,55,52\}$
\end{enumerate}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado a}
\begin{minted}[linenos]{c++}
int numeroCaminos_nodo (const ArbolBinario<int>::preorden_iterador &n, int k) {
    if (!n.nulo()) {
        int ac = 0;
        k -= *n;
        if (k == 0)
            ac = 1;

        return ac + numeroCaminos_nodo(n.hi(),k) + numeroCaminos_nodo(n.hd(),k);
    }
}

int numeroCaminos (const ArbolBinario<int> &ab, int k) {
    ArbolBinario<int>::preorden_iterador it;
    int contador = 0;
    for (it = ab.beginpreorden(); it != ab.endpreorden(); ++it)
        contador += numeroCaminos_nodo(it,k);

    return contador;
}
\end{minted}

\subsubsection{\textcolor[rgb]{0.5,0.8,1}Apartado b}
\begin{description}
      \item[AVL]:
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{20}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{15}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{45}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{12}
      % ,(-5,-20)*+=<10mm>[]\txt<2cm>{42}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{23}
      ,(15,-20)*+=<10mm>[]\txt<2cm>{55}
      ,(15,-30)*+=<10mm>[]\txt<2cm>{52}
      % ,(-20,-30)*+=<10mm>[]\txt<2cm>{1016}
      ,(10,-30)*+=<10mm>[]\txt<2cm>{24}
      % ,(-10,-30)*+=<10mm>[]\txt<2cm>{1016}
      ,(0,-30)*+=<10mm>[]\txt<2cm>{22}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      \ar@{-} (10,-12);(15,-18)
      \ar@{-} (15,-22);(15,-28)
      % \ar@{-} (-15,-22);(-20,-28)
      % \ar@{-} (-15,-22);(-10,-28)
      % \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      \ar@{-} (5,-22);(0,-28)
      \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]

      \item[APO]:
      \[\begin{xy}
      % ,(33,-8)*+=<10mm>[]\txt<2cm>{1.2}
      % ,(32,-12)*+=<20mm>[]\txt<2cm>{RSI(29)}
      ,(0,0)*+=<10mm>[]\txt<2cm>{12}
      % ,(7,5)*+=<10mm>[]\txt<2cm>{$h=3$}
      ,(-10,-10)*+=<10mm>[]\txt<2cm>{15}
      ,(10,-10)*+=<10mm>[]\txt<2cm>{22}
      ,(-15,-20)*+=<10mm>[]\txt<2cm>{45}
      % ,(-5,-20)*+=<10mm>[]\txt<2cm>{52}
      ,(5,-20)*+=<10mm>[]\txt<2cm>{23}
      ,(15,-20)*+=<10mm>[]\txt<2cm>{24}
      % ,(15,-30)*+=<10mm>[]\txt<2cm>{52}
      ,(-20,-30)*+=<10mm>[]\txt<2cm>{55}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{24}
      ,(-10,-30)*+=<10mm>[]\txt<2cm>{52}
      % ,(0,-30)*+=<10mm>[]\txt<2cm>{22}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(20,-30)*+=<10mm>[]\txt<2cm>{15}
      % ,(15,-40)*+=<10mm>[]\txt<2cm>{13}
      % ,(25,-40)*+=<10mm>[]\txt<2cm>{15}
      %,(-5,-30)*+=<10mm>[]\txt<2cm>{7}
      % ,(10,-30)*+=<10mm>[]\txt<2cm>{13}
      % ,(-5,-40)*+=<10mm>[]\txt<2cm>{10}

      % \ar@{->} (5,3);(0,1)
      % \ar@{->} (25,-10);(43,-10)
      \ar@{-} (0,-2);(-10,-9) % raiz al hijo izq
      \ar@{-} (0,-2);(9,-8) % raiz al hijo dcha
      \ar@{-} (-10,-12);(-15,-18) % 5 al 3
      \ar@{-} (10,-12);(5,-18)
      \ar@{-} (10,-12);(15,-18)
      % \ar@{-} (15,-22);(15,-28)
      \ar@{-} (-15,-22);(-20,-28)
      \ar@{-} (-15,-22);(-10,-28)
      % \ar@{-} (-10,-12);(-5,-18)
      % \ar@{-} (-5,-22);(-10,-28) 
      % \ar@{-} (5,-22);(0,-28)
      % \ar@{-} (5,-22);(10,-28)
      % \ar@{-} (15,-22);(10,-28) % 15 al 14
      % \ar@{-} (15,-22);(20,-28)
      % \ar@{-} (10,-32);(15,-38)
      % \ar@{-} (20,-32);(25,-38)
      % \ar@{-} (-5,-22);(-5,-28) % 7 al 8
      % \ar@{-} (0,-32);(-5,-38) % 12 al 13
      \end{xy}\]
\end{description}

\subsection{\textcolor[rgb]{0.5,0.8,1}Ejercicio 5}
\noindent
Describid las similitudes y diferencias (razonando la respuesta) en el funcionamiento del método básico de inserción de un elemento en los siguientes tipos de datos abstractos:
\begin{enumerate}[1)]
      \item vector
      \item list
      \item map
      \item set
      \item priority\_queue
      \item tabla hash abierta (unordered\_set)
\end{enumerate}

\noindent
Tanto en la lista como en la tabla hash abierta la inserción de un elemento se realiza en O(1) y son por tanto, los contenedores más eficientes en ese aspecto. En un vector la eficiencia a la hora de insertar depende de si tenemos que hacer resize o no, si no tenemos que hacer resize también tendría eficiencia O(1) pero si no, tendría eficiencia O($n$). En la cola de prioridad, como tenemos que buscar dónde insertar el elemento, la inserción se realiza en O($log_2 (n)$). Por último, en el map y en el set, al estar implementados como árboles, la inserción se realiza en O($log_2 (n)$). 

\noindent
Por tanto, podemos concluir que en lo que a eficiencia se refiere las listas y las tablas hash son las mejores a la hora de insertar elementos. Después vendrían los set, multiset y las colas de prioridad y, por último, los vectores.

\noindent
En las listas y tablas hash se hace en O(1) porque se accede directamente al sitio en el que se va a insertar el nuevo elemento. En los set, map y colas de prioridad, al tener que buscar el sitio dónde se va a realizar la inserción, ésta tarda un poco más. En los vectores también se accede directamente al lugar de inserción, pero al insertar un elemento en el peor de los casos, nos tocaría hacer resize y de ahí que su eficiencia sea O($n$).

\end{document}
\textcolor[rgb]{0.5,0.8,1}
\noindent
\hyperref[empresa_abierta_regulada]{Figura \ref*{empresa_abierta_regulada}}
\label{empresa_abierta_regulada}

\begin{minipage}{0.4\textwidth}
\begin{flushleft}
